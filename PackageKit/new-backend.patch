diff -r 4c5c579015af backends/conary/Makefile.am
--- a/backends/conary/Makefile.am	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/Makefile.am	Sun Feb 22 20:05:14 2009 -0600
@@ -1,18 +1,21 @@
 helperdir = $(datadir)/PackageKit/helpers/conary
 dist_helper_DATA = 			\
 	conaryBackend.py		\
-	conaryFilter.py		\
-	conaryCallback.py	\
-	conaryInit.py		\
-	Cache.py		\
-	pkConaryLog.py
+	conaryFilter.py			\
+	conaryCallback.py		\
+	conaryInit.py			\
+	XMLCache.py			    \
+	pkConaryLog.py			\
+	conarypk.py			    \
+    conaryProgress.py       \
+	conaryEnums.py
 
 plugindir = $(PK_PLUGIN_DIR)
 plugin_LTLIBRARIES = libpk_backend_conary.la
 libpk_backend_conary_la_SOURCES = pk-backend-conary.c
 libpk_backend_conary_la_LIBADD = $(PK_PLUGIN_LIBS)
 libpk_backend_conary_la_LDFLAGS = -module -avoid-version
-libpk_backend_conary_la_CFLAGS = $(PK_PLUGIN_CFLAGS)
+libpk_backend_conary_la_CFLAGS = $(PK_PLUGIN_CFLAGS) $(WARNINGFLAGS_C)
 
 install-data-hook:
 	chmod a+rx $(DESTDIR)$(helperdir)/*.py
diff -r 4c5c579015af backends/conary/XMLCache.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/backends/conary/XMLCache.py	Sun Feb 22 20:05:14 2009 -0600
@@ -0,0 +1,300 @@
+import os
+from xml.dom.minidom import parse
+import urllib as url
+
+
+from conary.lib import sha1helper
+from conary.lib import util
+
+from packagekit.backend import PackageKitBaseBackend
+from packagekit.enums import ERROR_NO_CACHE
+
+
+from pkConaryLog import log
+from conarypk import ConaryPk
+from conaryEnums import groupMap
+
+def getGroup( categorieList ):
+    where = mapGroup( categorieList )
+    if where.values():
+        return max( where.iteritems())[0]
+    else:
+        return None
+
+
+
+def mapGroup(categorieList):
+    where = {}
+    if  not categorieList:
+        return where
+    log.info(categorieList)
+    for cat in categorieList:
+        for group,categories in groupMap.items():
+            if cat in categories:
+                if group in where:
+                    where[group] = where[group] +1
+                else:
+                    where[group] = 1
+    return where
+
+class XMLRepo:
+    xml_path = ""
+    repository = ""
+    def __init__(self, repo, path ):
+        self.xml_path = path
+        self._setRepo(repo)
+
+    def resolve(self, search_trove):
+        """ resolve its a search with name """
+        trove =  self._getPackage(search_trove)
+        if trove:
+            return trove
+        else:
+            return None
+        
+    def search(self, search, where ):
+        if where == "name":
+            return self._searchNamePackage(search)
+        elif where == "details":
+            return self._searchDetailsPackage(search)
+        elif where == "group":
+            return self._searchGroupPackage(search)
+        else:
+            return self._searchPackage(search)
+
+    def _setRepo(self,repo):  
+        self.repo = repo
+        doc = self._open()
+        self.label = str( doc.childNodes[0].getAttribute("label") )
+
+    def _open(self):
+        try:
+            return self._repo
+        except AttributeError:
+            self._repo =   parse( open( self.xml_path + self.repo) )
+            return self._repo
+
+    def _generatePackage(self, package_node ): 
+        """ convert from package_node to dictionary """
+        pkg = {}
+        cat = []
+        for node in package_node.childNodes:
+            if pkg.has_key('category'):
+                cat.append(str(node.childNodes[0].nodeValue))
+            else:
+                pkg[str(node.nodeName)] = str(node.childNodes[0].nodeValue)
+        pkg["category"] = cat
+        return pkg
+
+    def _getPackage(self, name):
+        doc = self._open()
+        results = []
+        for packages in doc.childNodes:
+            for package in packages.childNodes:
+                pkg = self._generatePackage(package)
+                pkg["label"] = self.label
+                if name == pkg["name"]:
+                    return pkg
+        return None
+
+    def _searchNamePackage(self, name):
+        doc = self._open()
+        results = []
+        for packages in doc.childNodes:
+            for package in packages.childNodes:
+                pkg = self._generatePackage(package)
+                pkg["label"] = self.label
+                if name.lower() in pkg["name"]:
+                    results.append(pkg['name'])
+        return  [ self._getPackage(i) for i in set(results) ]
+
+    def _searchGroupPackage(self, name):
+        doc = self._open()
+        results_name = []
+        for packages in doc.childNodes:
+            for package in packages.childNodes:
+                pkg = self._generatePackage(package)
+                pkg["label"] = self.label
+                """
+                if not pkg.has_key("category"):
+                    continue
+                for j in pkg["category"]:
+                    if name.lower() in j.lower():
+                        results_name.append(pkg['name'])
+                """
+                if pkg.has_key("category"):
+                    group = getGroup(pkg["category"])
+                    if name.lower() == group:
+                        results_name.append(pkg["name"])
+            log.info(results_name)
+        return [ self._getPackage(i) for i in set(results_name) ]
+
+    def _searchDetailsPackage(self, name):
+        return self._searchPackage(name)
+    def _searchPackage(self, name):
+        doc = self._open()
+        results = []
+        for packages in doc.childNodes:
+            for package in packages.childNodes:
+                pkg = self._generatePackage(package)
+                pkg["label"] = self.label
+                for i in pkg.keys():
+                    if i  == "label":
+                        continue
+                    if i =='category':
+                        for j in pkg[i]:
+                            if name.lower() in j.lower():
+                                results.append(pkg['name'])
+                    if name.lower() in pkg[i]:
+                        results.append(pkg['name'])
+        return  [ self._getPackage(i) for i in set(results) ]
+    def _getAllPackages(self):
+        doc = self._open()
+        results = []
+        for packages in doc.childNodes:
+            for package in packages.childNodes:
+                pkg = self._generatePackage(package)
+                pkg["label"] = self.label
+                results.append(pkg)
+        return results
+
+
+class XMLCache:
+    #xml_files = ["foresight.rpath.org@fl:2"]
+    xml_files = []
+    server = "http://packages.foresightlinux.org/cache/"
+    repos = []
+    dbPath = '/var/cache/conary/'
+    jobPath = dbPath + 'jobs'
+    xml_path =  dbPath + "xmlrepo/"
+
+    def __init__(self):
+        con = ConaryPk()
+        labels = con.get_labels_from_config()
+
+        if not os.path.isdir(self.dbPath):
+            os.makedirs(self.dbPath)
+        if not os.path.isdir(self.jobPath):
+            os.mkdir(self.jobPath)
+        if not os.path.isdir( self.xml_path ):
+            os.makedirs(self.xml_path )
+ 
+        for xml_file in labels:
+           if not os.path.exists( self.xml_path + xml_file + ".xml"  ):
+                self._fetchXML()
+        for xml_file in labels :
+            self.repos.append(XMLRepo( xml_file + ".xml", self.xml_path ))
+
+    def _getJobCachePath(self, applyList):
+        applyStr = '\0'.join(['%s=%s[%s]--%s[%s]%s' % (x[0], x[1][0], x[1][1], x[2][0], x[2][1], x[3]) for x in applyList])
+        return self.jobPath + '/' + sha1helper.sha1ToString(sha1helper.sha1String(applyStr))
+
+    def checkCachedUpdateJob(self, applyList):
+        jobPath = self._getJobCachePath(applyList)
+        if os.path.exists(jobPath):
+            return jobPath
+    
+    def cacheUpdateJob(self, applyList, updJob):
+        jobPath = self._getJobCachePath(applyList)
+        if os.path.exists(jobPath):
+            util.rmtree(jobPath)
+        os.mkdir(jobPath)
+        updJob.freeze(jobPath)
+
+    def convertTroveToDict(self, troveTupleList):
+        mList = []
+        for troveTuple in troveTupleList: 
+            pkg = {}
+            pkg["name"] = troveTuple[0]
+            pkg["version"] = troveTuple[1].trailingRevision()
+            pkg["label"] = troveTuple[1].trailingLabel() 
+            mList.append(pkg)
+        return mList
+            
+    def searchByGroups(self, groups):
+        pass
+    def refresh(self):
+        self._fetchXML()
+    def resolve(self, name ):
+        for repo in self.repos:
+            r =  repo.resolve(name)
+            if r:
+                return r
+        else:
+            return None
+
+    def search(self, search, where = "name" ):
+        """ 
+            @where (string) values = name | details | group |
+        """
+        repositories_result = []
+        for repo in self.repos:
+            results = repo.search(search , where )
+            for i in results:
+                repositories_result.append(i)
+        return repositories_result
+
+    def _fetchXML(self ):
+        con = ConaryPk()
+        labels = con.get_labels_from_config()
+        for i in labels:
+            label = i + '.xml'
+            filename = self.xml_path + label
+            wwwfile = self.server + label
+            try:
+                wget = url.urlopen( wwwfile )
+            except:
+                Pk = PackageKitBaseBackend("")
+                Pk.error(ERROR_NO_CACHE," %s can not open" % wwwfile)
+            openfile = open( filename ,'w')
+            openfile.writelines(wget.readlines())
+            openfile.close()
+    def getGroup(self,categorieList):
+        return getGroup(categorieList)
+                
+    def _getCategorieBase(self, mapDict, categorieList ):
+        if not categorieList:
+            return None
+
+        tempDict = {}
+        for cat in categorieList:
+
+            if mapDict.has_key(cat):
+                map = mapDict[cat]
+            else:
+                continue
+
+            if tempDict.has_key(map):
+                tempDict[map] = tempDict[map] + 1
+            else:
+                tempDict[map] = 1
+        tmp = 0
+        t_key = ""
+        for key, value in tempDict.items():
+            if value > tmp:
+                t_key =  key
+                tmp  = value
+        return t_key
+
+    def _getAllCategories(self):
+        categories = []
+        for i in self.repos:
+            pkgs = i._getAllPackages()
+            for pkg in pkgs:
+                if pkg.has_key('category'):
+                    for cat in pkg["category"]:
+                        categories.append(cat)
+        categories.sort()
+        return set( categories )
+        
+        
+
+if __name__ == '__main__':
+  #  print ">>> name"
+   # print XMLCache().search('music', 'name' )
+   # print ">> details"
+   # l= XMLCache().search('Internet', 'group' )
+
+    #for v,p in enumerate(l):
+    #    print v,p["name"]
+    print  XMLCache().getGroup(['GTK', 'Graphics', 'Photography', 'Viewer'])
diff -r 4c5c579015af backends/conary/conaryBackend.py
--- a/backends/conary/conaryBackend.py	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/conaryBackend.py	Sun Feb 22 20:05:14 2009 -0600
@@ -28,96 +28,31 @@
 from conary import dbstore, queryrep, versions, updatecmd
 from conary.local import database
 from conary import trove
+from conary.conaryclient import cmdline
 
 from packagekit.backend import *
 from packagekit.package import *
-from conaryCallback import UpdateCallback
+from packagekit.progress import PackagekitProgress
+from conaryCallback import UpdateCallback, GetUpdateCallback, RemoveCallback, UpdateSystemCallback
 from conaryFilter import *
-#from XMLCache import XMLCache as Cache
+from XMLCache import XMLCache as Cache
+from conaryInit import *
 
-# zodman fix
-from Cache import Cache
 from conaryInit import init_conary_config, init_conary_client
 from conary import conarycfg, conaryclient
+from conarypk import ConaryPk
 
 pkpackage = PackagekitPackage()
 
-from pkConaryLog import log, pdb
+from pkConaryLog import *
 
-groupMap = {
-    '2DGraphics'          : GROUP_GRAPHICS,
-    'Accessibility'       : GROUP_ACCESSIBILITY,
-    'AdvancedSettings'    : GROUP_ADMIN_TOOLS,
-    'Application'         : GROUP_OTHER,
-    'ArcadeGame'          : GROUP_GAMES,
-    'Audio'               : GROUP_MULTIMEDIA,
-    'AudioVideo'          : GROUP_MULTIMEDIA,
-    'BlocksGame'          : GROUP_GAMES,
-    'BoardGame'           : GROUP_GAMES,
-    'Calculator'          : GROUP_ACCESSORIES,
-    'Calendar'            : GROUP_ACCESSORIES,
-    'CardGame'            : GROUP_GAMES,
-    'Compiz'              : GROUP_SYSTEM,
-    'ContactManagement'   : GROUP_ACCESSORIES,
-    'Core'                : GROUP_SYSTEM,
-    'Database'            : GROUP_SERVERS,
-    'DesktopSettings'     : GROUP_ADMIN_TOOLS,
-    'Development'         : GROUP_PROGRAMMING,
-    'Email'               : GROUP_INTERNET,
-    'FileTransfer'        : GROUP_INTERNET,
-    'Filesystem'          : GROUP_SYSTEM,
-    'GNOME'               : GROUP_DESKTOP_GNOME,
-    'GTK'                 : GROUP_DESKTOP_GNOME,
-    'GUIDesigner'         : GROUP_PROGRAMMING,
-    'Game'                : GROUP_GAMES,
-    'Graphics'            : GROUP_GRAPHICS,
-    'HardwareSettings'    : GROUP_ADMIN_TOOLS,
-    'IRCClient'           : GROUP_INTERNET,
-    'InstantMessaging'    : GROUP_INTERNET,
-    'LogicGame'           : GROUP_GAMES,
-    'Monitor'             : GROUP_ADMIN_TOOLS,
-    'Music'               : GROUP_MULTIMEDIA,
-    'Network'             : GROUP_INTERNET,
-    'News'                : GROUP_INTERNET,
-    'Office'              : GROUP_OFFICE,
-    'P2P'                 : GROUP_INTERNET,
-    'PackageManager'      : GROUP_ADMIN_TOOLS,
-    'Photography'         : GROUP_MULTIMEDIA,
-    'Player'              : GROUP_MULTIMEDIA,
-    'Presentation'        : GROUP_OFFICE,
-    'Publishing'          : GROUP_OFFICE,
-    'RasterGraphics'      : GROUP_GRAPHICS,
-    'Security'            : GROUP_SECURITY,
-    'Settings'            : GROUP_ADMIN_TOOLS,
-    'Spreadsheet'         : GROUP_OFFICE,
-    'System'              : GROUP_SYSTEM,
-    'Telephony'           : GROUP_COMMUNICATION,
-    'TerminalEmulator'    : GROUP_ACCESSORIES,
-    'TextEditor'          : GROUP_ACCESSORIES,
-    'Utility'             : GROUP_ACCESSORIES,
-    'VectorGraphics'      : GROUP_GRAPHICS,
-    'Video'               : GROUP_MULTIMEDIA,
-    'Viewer'              : GROUP_MULTIMEDIA,
-    'WebBrowser'          : GROUP_INTERNET,
-    'WebDevelopment'      : GROUP_PROGRAMMING,
-    'WordProcessor'       : GROUP_OFFICE
-}
 
-revGroupMap = {}
-
-for (con_cat, pk_group) in groupMap.items():
-    if revGroupMap.has_key(pk_group):
-        revGroupMap[pk_group].append(con_cat)
-    else:
-        revGroupMap[pk_group] = [con_cat]
-
-#from conary.lib import util
-#sys.excepthook = util.genExcepthook()
-
+from conary.lib import util
+sys.excepthook = util.genExcepthook()
 def ExceptionHandler(func):
+    return func
     def display(error):
         return str(error).replace('\n', ' ')
-
     def wrapper(self, *args, **kwargs):
         try:
             return func(self, *args, **kwargs)
@@ -133,7 +68,6 @@
         except Exception, e:
             self.error(ERROR_UNKNOWN, display(e), exit=True)
     return wrapper
-
 def _format_str(str):
     """
     Convert a multi line string to a list separated by ';'
@@ -171,8 +105,7 @@
         frzFlavor = flavor.freeze()
         return ','.join([frzVersion, frzFlavor])
 
-    def _thawData(self, data):
-        frzVersion, frzFlavor = data.split(',')
+    def _thawData(self, frzVersion, frzFlavor ):
         version = versions.ThawVersion(frzVersion)
         flavor = deps.ThawFlavor(frzFlavor)
         return version, flavor
@@ -185,90 +118,106 @@
         return ','.join(arches)
 
     @ExceptionHandler
+    def check_installed(self, troveTuple):
+        log.debug("============check installed =========")
+        cli = ConaryPk()
+        result = cli.query(troveTuple[0])
+        if result:
+            installed = INFO_INSTALLED
+        else:
+            installed = INFO_AVAILABLE
+
+        return installed
+           
+    @ExceptionHandler
     def get_package_id(self, name, versionObj, flavor):
+
         version = versionObj.trailingRevision()
+
         arch = self._get_arch(flavor)
-        data = self._freezeData(versionObj, flavor)
+
+        cache = Cache()
+        pkg  = cache.resolve(name)
+        data = versionObj.asString() + "#"
+        if pkg:
+            try:
+                data +=str(pkg)
+            except:
+                pass
         return pkpackage.get_package_id(name, version, arch, data)
 
     @ExceptionHandler
     def get_package_from_id(self, package_id):
         """ package_id(string) =
-        "pastebinit;0.7-1-1;x86;/foresight.rpath.org@fl:2-qa/1222042924.172:0.7-1-1,1#x86"
+        "dpaster;0.1-3-1;x86;/foresight.rpath.org@fl:2-qa/0.1-3-1#{'version': '0.1-3-1', 'category': [], 'name': 'dpaster', 'label': 'foresight.rpath.org@fl:2-qa'}"
         """
         log.info("=========== get package from package_id ======================")
-        log.info(package_id)
         name, verString, archString, data =  pkpackage.get_package_from_id(package_id)
-        log.info(data)
-        version, flavor = self._thawData(data)
-        return name, version, flavor
+        log.info( archString )
+        summary = data.split("#")
+        repo = summary[0]
+        if summary[1]:
+            metadata = eval(summary[1])
+        else:
+            metadata = {} 
+        cli = ConaryPk()
+        trove = cli.request_query(name)
+        if trove:
+            return trove
+        else:
+            return cli.query(name)
 
-    def _do_search(self, searchlist, filters):
+    def _do_search(self, filters, searchlist, where = "name"):
         """
-        searchlist(str)ist as the package for search like
-        filters(str) as the filter
+         searchlist(str)ist as the package for search like
+         filters(str) as the filter
         """
         fltlist = filters.split(';')
-        pkgfilter = ConaryFilter(fltlist)
-        #pkgfilter = ConaryFilter()
+        if where != "name" and where != "details" and where != "group":
+            log.info("where %s" % where)
+            self.error(ERROR_UNKNOWN, "DORK---- search where not found")
+        cache = Cache()
+        log.debug((searchlist, where))
 
-        troveSpecs = [ updatecmd.parseTroveSpec(searchlist,
-                                                allowEmptyName=False) ]
-        # get a hold of cached data
-        cache = Cache()
-        log.debug((searchlist, fltlist))
+        troveTupleList = cache.search(searchlist, where )
 
-        try:
-            troveTupleList = cache.search(searchlist)
-            log.info("FOUND!!!!!! %s"% str(troveTupleList))
-        finally:
-            pass
+        if len(troveTupleList) > 0 :
+            for i in troveTupleList:
+                log.info("FOUND!!!!!! %s " % i["name"] )
+            log.info("FOUND (%s) elements " % len(troveTupleList) )
+        else:
+            log.info("NOT FOUND %s " % searchlist )
+            pk = ConaryPk()
+            troveTupleList = pk.query(searchlist)
+            log.info(troveTupleList)
+            if not troveTupleList:
+                error = {}
+                error["group"] = ERROR_GROUP_NOT_FOUND
+                error["details"] = ERROR_PACKAGE_NOT_FOUND
+                error["name"] = error["details"]
+                self.error(error[where], "Not Found %s " % searchlist )
+            else:
+                troveTupleList = cache.convertTroveToDict( troveTupleList ) 
+                log.info("convert")
+                log.info(troveTupleList)
 
-        # Remove dupes
-        tempDict = {}
-        try:
-            for element in troveTupleList:
-                tempDict[element] = None
-        except TypeError:
-            del tempDict  # move on to the next method
-        else:
-            troveTupleList = tempDict.keys()
-
-        # Get the latest first
-        troveTupleList.sort()
-        troveTupleList.reverse()
-
-        for troveTuple in troveTupleList:
-            troveTuple = tuple([item.encode('UTF-8') for item in troveTuple])
-            name = troveTuple[0]
-            version = versions.ThawVersion(troveTuple[1])
-            flavor = deps.ThawFlavor(troveTuple[2])
-            troveTuple = tuple([name, version, flavor])
-            log.info("TROVETUPLE %s" % str(troveTuple))
-            installed = self.check_installed(troveTuple)
-
-            if installed is "installed":
-                pkgfilter.add_installed([troveTuple])
-                log.info(" === Installed ========= %s" % name)
-            else:
-                pkgfilter.add_available([troveTuple])
-                log.info("=== Available====== %s" % name)
-
-        # we couldn't do this when generating the list
-
-        package_list = pkgfilter.post_process()
-        log.info("package_list %s" %package_list)
-        self._show_package_list(package_list)
+        self._resolve_list( fltlist, troveTupleList  )
 
     def _get_update(self, applyList, cache=True):
+        from conary.conaryclient.update import NoNewTrovesError
         updJob = self.client.newUpdateJob()
-        suggMap = self.client.prepareUpdateJob(updJob, applyList)
+        try:
+            suggMap = self.client.prepareUpdateJob(updJob, applyList)
+        except NoNewTrovesError:
+            self.error(ERROR_NO_PACKAGES_TO_UPDATE, "No new apps were found")
         if cache:
             Cache().cacheUpdateJob(applyList, updJob)
         return updJob, suggMap
 
     def _do_update(self, applyList):
+        log.info("========= _do_update ========")
         jobPath = Cache().checkCachedUpdateJob(applyList)
+        log.info(jobPath)
         if jobPath:
             updJob = self.client.newUpdateJob()
             try:
@@ -278,7 +227,10 @@
         else:
             updJob = self._get_update(applyList, cache=False)
         self.allow_cancel(False)
-        restartDir = self.client.applyUpdateJob(updJob)
+        try:
+            restartDir = self.client.applyUpdateJob(updJob)
+        except errors.InternalConaryError:
+            self.error(ERROR_NO_PACKAGES_TO_UPDATE,"get-updates first and then update sytem")
         return updJob
 
     def _get_package_update(self, name, version, flavor):
@@ -295,111 +247,146 @@
             applyList = [(name, (None, None), (version, flavor), True)]
         return self._do_update(applyList)
 
+    def _resolve_list(self, filters, pkgsList ):
+        log.info("======= _resolve_list =====")
+        specList = []
+        cli = ConaryPk()
+        for pkg in pkgsList:
+            name = pkg["name"]
+            repo = pkg["label"]
+            version = pkg["version"]
+            trove = name, None , cli.flavor
+            specList.append( trove  )
+        trovesList = cli.repos.findTroves(cli.default_label, specList, allowMissing=True )
+        pkgFilter = ConaryFilter(filters)
+        troves = trovesList.values()
+        for trovelst in troves:
+            t = trovelst[0]
+            installed = pkgFilter._pkg_is_installed( t[0] )
+            if installed:
+                pkgFilter.add_installed( trovelst )
+            else:
+                pkgFilter.add_available( trovelst )
+
+       
+        package_list = pkgFilter.post_process()
+        self._show_package_list(package_list)
+ 
     @ExceptionHandler
-    def resolve(self, filters, packages):
+    def resolve(self, filters, package ):
+        """ 
+            @filters  (list)  list of filters
+            @package (list ) list with packages name for resolve
+        """
         self.allow_cancel(True)
         self.percentage(None)
         self.status(STATUS_INFO)
+
         log.info("======== resolve =========")
-        log.info("filters: %s package:%s " % (filters, packages))
-        if len(packages):
-            for i in packages:
-                self._do_search(i, filters)
+        log.info("filters: %s package:%s " % (filters, package))
+
+        cache = Cache()
+        pkg_dict = cache.resolve( package[0] )
+        log.info("doing a resolve")
+        conary_cli = ConaryPk()
+        solved = False
+        if pkg_dict is None:
+            # verifica si esta en repositorios
+            log.info("doing a rq")
+            troveTuple = conary_cli.query(package[0])
+            if not troveTuple:
+                self.error(ERROR_INTERNAL_ERROR, "Package Not found")
+                log.info("PackageNot found on resolve")
+
+            else:
+                pkg_dict = {}
+                pkg_dict["name"] =  troveTuple[0][0]
+                solved = True
+            
+
+        filter = ConaryFilter(filters)
+
+        installed = filter._pkg_is_installed( pkg_dict["name"] )
+        
+        if solved == False:
+            troveTuple =  conary_cli.request_query( package[0] )
+
+        log.info(">>> %s" % troveTuple)
+
+        if installed:
+            filter.add_installed( troveTuple  )
         else:
-            self._do_search(packages, filters)
+            filter.add_available( troveTuple )
 
-    @ExceptionHandler
-    def check_installed(self, troveTuple):
-        log.debug("============check installed =========")
-        log.info(troveTuple)
-        db = conaryclient.ConaryClient(self.cfg).db
-        try:
-            troveTuple = troveTuple[0], troveTuple[1], troveTuple[2]
-            localInstall = db.findTrove(None, troveTuple)
-            installed = INFO_INSTALLED
-        except:
-            installed = INFO_AVAILABLE
-        log.info(installed)
-        return installed
-
-    def _pkg_is_installed(self, pkg):
-        '''
-        Return if the package is installed.
-        '''
-        return self.check_installed(pkg)
-
-    @ExceptionHandler
-    def search_group(self, filters, key):
-        '''
-        Implement the {backend}-search-name functionality
-        FIXME: Ignoring filters for now.
-        '''
-        self.allow_cancel(True)
-        self.percentage(None)
-        self.status(STATUS_QUERY)
-
-        fltlist = filters.split(';')
-        pkgfilter = ConaryFilter(fltlist)
-        pkgfilter = ConaryFilter(fltlist)
-        cache = Cache()
-
-        try:
-            troveTupleList = cache.searchByGroups(revGroupMap[key])
-        finally:
-            # FIXME: Really need to send an error here
-            pass
-
-        troveTupleList.sort()
-        troveTupleList.reverse()
-
-        for troveTuple in troveTupleList:
-            troveTuple = tuple([item.encode('UTF-8') for item in troveTuple[0:2]])
-            name = troveTuple[0]
-            version = versions.ThawVersion(troveTuple[1])
-            flavor = deps.ThawFlavor(troveTuple[2])
-            category = troveTuple[3][0]
-            category = category.encode('UTF-8')
-            troveTuple = tuple([name, version, flavor])
-            installed = self.check_installed(troveTuple)
-            if installed:
-                pkgfilter.add_installed([troveTuple])
-            else:
-                pkgfilter.add_available([troveTuple])
-
-        # we couldn't do this when generating the list
-        package_list = pkgfilter.post_process()
+        package_list = filter.post_process()
         log.info("package_list %s" % package_list)
         self._show_package_list(package_list)
 
     def _show_package_list(self, lst):
-        log.info("------------- show_package_list ----------")
-        log.info(lst)
+        """ 
+            HOW its showed on packageKit
+            @lst(list(tuple) = [ ( troveTuple, status ) ]
+        """
         for troveTuple, status in lst:
+            # take the basic info
             name = troveTuple[0]
             version = troveTuple[1]
             flavor = troveTuple[2]
+            # get the string id from packagekit 
             package_id = self.get_package_id(name, version, flavor)
-            log.info("pkg id")
-            log.info(package_id)
-            summary = self._get_metadata(package_id, 'shortDesc') or " "
-            #summary = " "
-            log.info("####Package %s %s %s" % (package_id, status, summary ))
-            self.package(package_id, status, summary)
+            
+            # split the list for get Determine info
+            summary = package_id.split(";")
+            data = summary[3].split("#")
+            if data[1]:
+                metadata = eval(summary[3].split("#")[1])
+            else:
+                metadata = {}
+            log.info("====== show the package ")
+            log.info(metadata)
+            if metadata.has_key("shortDesc"):
+                meta = metadata["shortDesc"]
+            else:
+                meta = " "
+            self.package(package_id, status, meta )
+
+    @ExceptionHandler
+    def search_group(self, options, searchlist):
+        '''
+        Implement the {backend}-search-group functionality
+        '''
+        log.info("============= search_group ========")
+        self.allow_cancel(True)
+        self.percentage(None)
+        self.status(STATUS_QUERY)
+        log.info("options: %s searchlist:%s "%(options, searchlist))
+        self._do_search(options, searchlist, 'group')
+
 
     @ExceptionHandler
     def search_name(self, options, searchlist):
         '''
         Implement the {backend}-search-name functionality
         '''
+        log.info("============= search_name ========")
         self.allow_cancel(True)
         self.percentage(None)
         self.status(STATUS_QUERY)
-        log.info("============= search_name ========")
         log.info("options: %s searchlist:%s "%(options, searchlist))
-        self._do_search(searchlist, options)
+        self._do_search(options, searchlist, 'name')
 
-    def search_details(self, opt, key):
-        pass
+    @ExceptionHandler
+    def search_details(self, options, search):
+        '''
+        Implement the {backend}-search-details functionality
+        '''
+        log.info("============= search_details ========")
+        self.allow_cancel(True)
+        #self.percentage(None)
+        self.status(STATUS_QUERY)
+        log.info("options: %s searchlist:%s "%(options, search))
+        self._do_search(options, search, 'details' )
+       
 
     def get_requires(self, filters, package_ids, recursive_text):
         pass
@@ -443,32 +430,41 @@
                                                  withFiles = True):
                     files.append(path)
             return files
+        
+        for package in package_id.split("&"):
+            log.info(package)
+            name, version, flavor, installed = self._findPackage(package)
 
-        name, version, flavor, installed = self._findPackage(package_id)
+            if installed == INFO_INSTALLED:
+                files = _get_files(self.client.db, name, version, flavor)
+            else:
+                files = _get_files(self.client.repos, name, version, flavor)
 
-        if installed == INFO_INSTALLED:
-            files = _get_files(self.client.db, name, version, flavor)
-        else:
-            files = _get_files(self.client.repos, name, version, flavor)
-
-        self.files(package_id, ';'.join(files))
+            self.files(package_id, ';'.join(files))
 
     @ExceptionHandler
     def update_system(self):
         self.allow_cancel(True)
+        self.status(STATUS_UPDATE)
+        self.client.setUpdateCallback( UpdateSystemCallback(self, self.cfg) )
         updateItems = self.client.fullUpdateItemList()
+        pprint(updateItems)
         applyList = [ (x[0], (None, None), x[1:], True) for x in updateItems ]
-        updJob, suggMap = self._do_update(applyList)
 
-    @ExceptionHandler
+        log.info(">>>>>>>>>> get update >>>>>>>>>>>>")
+        #self._get_update(applyList)
+        log.info(">>>>>>>>>> DO Update >>>>>>>>>>>>")
+        self._do_update(applyList)
+        log.info(">>>>>>>>>>END DO Update >>>>>>>>>>>>")
+        self.client.setUpdateCallback(self.callback )
+
+#    @ExceptionHandler
     def refresh_cache(self):
         #log.debug("refresh-cache command ")
         self.percentage()
         self.status(STATUS_REFRESH_CACHE)
         cache = Cache()
-        if not cache.is_populate_database:
-            self.status(STATUS_WAIT)
-            cache.populate_database()
+        cache.refresh()
 
     @ExceptionHandler
     def update(self, package_ids):
@@ -478,11 +474,13 @@
         self.allow_cancel(True)
         self.percentage(0)
         self.status(STATUS_RUNNING)
-
+        
         for package in package_ids.split(" "):
             name, version, flavor, installed = self._findPackage(package)
             if name:
-                self._do_package_update(name, version, flavor)
+               # self._do_package_update(name, version, flavor)
+               cli = ConaryPk()
+               cli.update(name)
             else:
                 self.error(ERROR_PACKAGE_ALREADY_INSTALLED, 'No available updates')
 
@@ -497,12 +495,10 @@
         '''
         Implement the {backend}-{install, update}-packages functionality
         '''
-        log.info(package_ids)
-        #for package_id in package_ids.split('%'):
+
         for package_id in package_ids:
-            log.info(package_id)
             name, version, flavor, installed = self._findPackage(package_id)
-            log.info((name, version))
+            log.info((name, version, flavor, installed ))
 
             self.allow_cancel(True)
             self.percentage(0)
@@ -513,8 +509,10 @@
                     self.error(ERROR_PACKAGE_ALREADY_INSTALLED,
                         'Package already installed')
 
-                self.status(INFO_INSTALLING)
+                self.status(STATUS_INSTALL)
+                log.info(">>> Prepare Update")
                 self._get_package_update(name, version, flavor)
+                log.info(">>> end Prepare Update")
                 self._do_package_update(name, version, flavor)
             else:
                 self.error(ERROR_PACKAGE_ALREADY_INSTALLED, 'Package was not found')
@@ -528,20 +526,27 @@
         self.percentage(0)
         self.status(STATUS_RUNNING)
         log.info("========== Remove Packages ============ ")
+        log.info( allowDeps ) 
+        self.client.setUpdateCallback(RemoveCallback(self, self.cfg))
+        errors = ""
         #for package_id in package_ids.split('%'):
         for package_id in package_ids:
             name, version, flavor, installed = self._findPackage(package_id)
-
             if name:
                 if not installed == INFO_INSTALLED:
                     self.error(ERROR_PACKAGE_NOT_INSTALLED, 'The package %s is not installed' % name)
 
                 name = '-%s' % name
-                self.status(INFO_REMOVING)
+                self.status(STATUS_REMOVE)
                 self._get_package_update(name, version, flavor)
+                callback = self.client.getUpdateCallback()
+                if callback.error:
+                    self.error(ERROR_DEP_RESOLUTION_FAILED,', '.join(callback.error))
+                        
                 self._do_package_update(name, version, flavor)
             else:
                 self.error(ERROR_PACKAGE_ALREADY_INSTALLED, 'The package was not found')
+        self.client.setUpdateCallback(self.callback)
 
     def _get_metadata(self, package_id, field):
         '''
@@ -625,11 +630,11 @@
         #vendor_url = _format_list(urls['vendor'])
         vendor_url = ""
         reboot = "none"
-        desc = self._get_metadata(package_id, 'longDesc') or " "
+        desc = " "
         self.update_detail(package_id, update, obsolete, vendor_url, bz_url, cve_url,
                 reboot, desc, changelog="", state="", issued="", updated="")
 
-    @ExceptionHandler
+   # @ExceptionHandler
     def get_details(self, package_ids):
         '''
         Print a detailed description for a given package
@@ -642,26 +647,58 @@
         log.info(package_ids[0])
         package_id = package_ids[0]
         name, version, flavor, installed = self._findPackage(package_id)
+        
+        summary = package_id.split(";")
+        log.info("====== summar")
+        log.info(summary)
 
-        log.info("name--------------------")
-        log.info((package_id, name))
+        repo = summary[3].split("#")[0]
+        if summary[3].split("#")[1]:
+            metadata = eval(summary[3].split("#")[1])
+        else:
+            metadata = {}
+        short_package_id  = ""
+        for i in summary[0:3]:
+            short_package_id += i +';'
+
+        log.info("Metadata--------------------")
+        log.info(metadata)
 
         if name:
-            shortDesc = self._get_metadata(package_id, 'shortDesc') or name
-            longDesc = self._get_metadata(package_id, 'longDesc') or ""
-            url = "http://www.foresightlinux.org/packages/" + name + ".html"
-            categories = self._get_metadata(package_id, 'categories') or "unknown"
+            if metadata.has_key("shortDesc"):
+                shortDesc = metadata["shortDesc"] 
+            else:
+                shortDesc = ""
+            if metadata.has_key("longDesc"):
+                longDesc = metadata["longDesc"] 
+            else:
+                longDesc = ""
 
+            url = "http://www.foresightlinux.org/packages/%s.html" % name
+
+            categories  = ""
+            if metadata.has_key("category"):
+                categories =  Cache().getGroup( metadata['category'])
+            else:
+                categories = None
             # Package size goes here, but I don't know how to find that for conary packages.
-            self.details(package_id, None, categories, longDesc, url, 0)
+            self.details(short_package_id, None, categories, longDesc, url, 0)
         else:
             self.error(ERROR_PACKAGE_NOT_FOUND, 'Package was not found')
 
     def _show_package(self, name, version, flavor, status):
         '''  Show info about package'''
         package_id = self.get_package_id(name, version, flavor)
-        summary = self._get_metadata(package_id, 'shortDesc') or ""
-        self.package(package_id, status, summary)
+        summary = package_id.split(";")
+        if summary[3].split("#")[1]:
+            metadata = eval(summary[3].split("#")[1])
+        else:
+            metadata = {}
+        if metadata.has_key("shortDesc"):
+            meta = metadata["shortDesc"]
+        else:
+            meta = " "
+        self.package(package_id, status, meta)
 
     def _get_status(self, notice):
         # We need to figure out how to get this info, this is a place holder
@@ -676,18 +713,29 @@
     @ExceptionHandler
     def get_updates(self, filters):
         self.allow_cancel(True)
-        self.percentage(None)
+        self.percentage(0)
         self.status(STATUS_INFO)
+        getUpdateC= GetUpdateCallback(self,self.cfg)
+        self.client.setUpdateCallback(getUpdateC)
+        log.info("callback changed")
         log.info("============== get_updates ========================")
-        updateItems = self.client.fullUpdateItemList()
+        cli = ConaryPk()
+        updateItems =cli.cli.fullUpdateItemList()
+#        updateItems = cli.cli.getUpdateItemList()
+        for i in updateItems:
+            log.info(i[0])
         applyList = [ (x[0], (None, None), x[1:], True) for x in updateItems ]
+        log.info("_get_update ....")
         updJob, suggMap = self._get_update(applyList)
+        log.info("_get_update ....end.")
 
         jobLists = updJob.getJobs()
+        log.info("get Jobs")
 
         totalJobs = len(jobLists)
         for num, job in enumerate(jobLists):
             status = '2'
+            log.info( (num, job)  )
             name = job[0][0]
 
             # On an erase display the old version/flavor information.
@@ -704,6 +752,8 @@
             troveTuple.append(version)
             installed = self.check_installed(troveTuple)
             self._show_package(name, version, flavor, INFO_NORMAL)
+        log.info("============== end get_updates ========================")
+        self.client.setUpdateCallback(self.callback)
 
     def _findPackage(self, package_id):
         '''
@@ -711,12 +761,17 @@
         '''
         log.info("========== _findPackage ==========")
         log.info(package_id)
-        name, version, flavor = self.get_package_from_id(package_id)
-        troveTuple = (name, version, flavor)
-        log.info("======== trove ")
-        log.info(troveTuple)
-        installed = self.check_installed(troveTuple)
-        return name, version, flavor, installed
+        troveTuples = self.get_package_from_id(package_id)
+        log.info(troveTuples)
+        for troveTuple in troveTuples:
+            log.info("======== trove ")
+            log.info(troveTuple)
+            installed = self.check_installed(troveTuple)
+            log.info(installed)
+            name, version, flavor = troveTuple
+            return name, version, flavor, installed
+        else:
+            self.error(ERROR_INTERNAL_ERROR, "package_id Not Correct ")
 
     def repo_set_data(self, repoid, parameter, value):
         '''
@@ -736,6 +791,8 @@
         '''
         pass
 
+from pkConaryLog import pdb
+
 def main():
     backend = PackageKitConaryBackend('')
     log.info("======== argv =========== ")
diff -r 4c5c579015af backends/conary/conaryCallback.py
--- a/backends/conary/conaryCallback.py	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/conaryCallback.py	Sun Feb 22 20:05:14 2009 -0600
@@ -17,110 +17,379 @@
 #
 # Copyright (C) 2007 Elliot Peele <elliot@bentlogic.net>
 # Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
-
 from conary import callbacks
 from packagekit.backend import *
+from conaryProgress import PackagekitProgress
 from pkConaryLog import log
 
-class UpdateCallback(callbacks.UpdateCallback):
+MEGA = 1048576.0
+
+class UpdateSystemCallback(callbacks.UpdateCallback):
+    def __init__(self, backend, cfg=None):
+        callbacks.UpdateCallback.__init__(self)
+        log.info("==== callback ==== ")
+        if cfg:
+            self.setTrustThreshold(cfg.trustThreshold)
+
+        self.backend = backend
+        self.currentJob = None
+        self.smallUpdate = False
+        self.error = []
+        self.progress = PackagekitProgress()
+        self.progress.set_steps([ 50 ]  )
+        self.disablepercent = False
+        self.dostep = True
+    #1
+    #3
+    def requestingChangeSet(self):
+        log.info("Callback UpdateSystem........ STATUS_REQUEST changeset ")
+        self.backend.status(STATUS_DOWNLOAD)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        if not self.disablepercent:
+            self.progress.step()
+    #2
+    def downloadingChangeSet(self, got, need):
+        log.info("Callback UpdateSystem........ STATUS_DOWNLOAD  Changeset %.2f percent %.2f/%.2f Mbytes" % ( got*100/float(need), got/MEGA,need/MEGA) )
+        if not self.disablepercent:
+            self.progress.set_subpercent( got*100 / float(need) )
+        self.backend.percentage( self.progress.percent )
+        log.info( "%s percent" % self.progress.percent)
+
+    #4
+    def resolvingDependencies(self):
+        log.info("Callback UpdateSystem........ STATUS_DEP_RESOLVE ")
+        self.backend.percentage(self.progress.percent)
+        self.backend.status(STATUS_DEP_RESOLVE)
+        self.progress.step()
+    #5  >> request> download
+    def setChangesetHunk(self, num, total):
+        log.info("callback. .......... set Changeset HUnk %s/%s" % (num, total ) )
+        if total > 0:
+            p = num*100/float(total)
+        else:
+            p = 0
+        self.progress.set_subpercent(p)
+        self.disablepercent = True
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        if num == total:
+            self.dostep =True
+    #6 
+    def setUpdateHunk(self, hunk, hunkCount):
+        log.info("callback. .......... set update HUnk %s/%s" % ( hunk, hunkCount))
+        if self.dostep:
+            self.progress.step()
+            self.disablepercent = True
+            self.dostep = False
+
+
+        if hunk < hunkCount:
+            p = hunk*100/float(hunkCount)
+            self.progress.set_subpercent( p )
+        else:
+            self.smallUpdate = True
+
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+    def setUpdateJob(self, job):
+        self.currentJob = job
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+    def creatingRollback(self):
+        #self.backend.status('Creating Rollback')
+        self.backend.status(STATUS_ROLLBACK)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+
+    def preparingUpdate(self, troveNum, troveCount, add=0):
+        #self.progress.step()
+        if not self.currentJob or len(self.currentJob) == 0 or troveNum > troveCount:
+            return
+
+
+        self.backend.percentage(self.progress.percent)
+        if troveNum > 0:
+            troveNum -= 1
+        job = self.currentJob[troveNum]
+        name = job[0]
+        oldVersion, oldFlavor = job[1]
+        newVersion, newFlavor = job[2]
+        #log.info("JOB>>>>>>>> %s " % str(job) )
+        if oldVersion and newVersion:
+            self.backend.status(STATUS_UPDATE)
+            package_id = self.backend.get_package_id(name, newVersion, newFlavor)
+            self.backend.package(package_id, INFO_UPDATING, '')
+        elif oldVersion and not newVersion:
+            self.backend.status(STATUS_REMOVE)
+            package_id = self.backend.get_package_id(name, oldVersion, oldFlavor)
+            self.backend.package(package_id, INFO_REMOVING, '')
+        elif not oldVersion and newVersion:
+            self.backend.status(STATUS_INSTALL)
+            package_id = self.backend.get_package_id(name, newVersion, newFlavor)
+            self.backend.package(package_id, INFO_INSTALLING, '')
+        log.info(self.progress.percent)
+
+    def creatingDatabaseTransaction(self, troveNum, troveCount):
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        self.preparingUpdate(troveNum, troveCount, add=troveCount)
+
+    def committingTransaction(self):
+        #self.backend.status('Committing Transaction')
+
+        self.backend.status(STATUS_COMMIT)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+    def updateDone(self):
+        log.info("callback. ..........  update done")
+        self.backend.percentage(self.progress.percent)
+        self.currentJob = None
+        log.info(self.progress.percent)
+
+    def downloadingFileContents(self, got, need):
+        #self.backend.status('Downloading files for changeset')
+        log.info("Callback ........ STATUS_DOWNLOAD  FIle Contents %s " %  str( got*100/need  ))
+        self.backend.status(STATUS_DOWNLOAD)
+        #self.backend.sub_percentage(got*100/need)
+
+    def requestingFileContents(self):
+        #self.backend.status('Requesting File Contents')
+        log.info("Callback ........ STATUS_REQUEST request File contents ")
+        self.backend.status(STATUS_REQUEST)
+
+    def removeFiles(self, filenum, total):
+        log.info("Callback ........ STATUS_REMOVE %s/%sfiles" %( filenum, total) )
+        self.backend.status(STATUS_REMOVE)
+        self.preparingUpdate(filenum, total, add=total)
+    
+    def done(self):
+        #self.backend.status('Done')
+    #    self.progress.step()
+        log.info("DONEEEEEEEEEEEE")
+ 
+    def warning(self, msg, *args, **kwargs):
+        e = msg %args
+        log.error("<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
+        log.error(e)
+        self.backend.error(ERROR_DEP_RESOLUTION_FAILED, e, False )
+        
+    def tagHandlerOutput(self, tag, msg, stderr = False):
+        pass
+
+    def troveScriptOutput(self, typ, msg):
+        pass
+
+class GetUpdateCallback(callbacks.UpdateCallback):
+    def __init__(self, backend, cfg=None):
+        callbacks.UpdateCallback.__init__(self)
+        log.info("==== callback ==== ")
+        if cfg:
+            self.setTrustThreshold(cfg.trustThreshold)
+
+        self.backend = backend
+        self.currentJob = None
+        self.smallUpdate = False
+        self.error = []
+        self.progress = PackagekitProgress()
+        self.progress.set_steps([1,50, 100 ]  )
+    # 1 >> downloadingChangeSet
+    # 2 >> downloadingChangeSet
+    def requestingChangeSet(self):
+        log.info("Callback getUpdates ........ STATUS_REQUEST changeset ")
+        self.backend.status(STATUS_REQUEST)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        self.progress.step()
+
+    def downloadingChangeSet(self, got, need):
+        log.info("Callback getUpdates. Changeset %s percent of %.2f/%.2f bytes" % ( int( got*100/float(need)), got/MEGA,need/MEGA) )
+        self.backend.status(STATUS_DOWNLOAD)
+        self.progress.set_subpercent( got*100 / float(need) )
+        self.backend.percentage( self.progress.percent )
+        log.info( "%s percent" % self.progress.percent)
+    # 3
     def resolvingDependencies(self):
         #self.backend.status('Resolving Dependencies')
         self.backend.status(STATUS_DEP_RESOLVE)
+        self.progress.step()
+        log.info("Callback getUpdates........ STATUS_DEP_RESOLVE ")
+        self.backend.percentage(self.progress.percent)
+        log.info("do a step>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
 
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+  
+class UpdateCallback(callbacks.UpdateCallback):
+    def __init__(self, backend, cfg=None):
+        callbacks.UpdateCallback.__init__(self)
+        log.info("==== callback ==== ")
+        if cfg:
+            self.setTrustThreshold(cfg.trustThreshold)
+
+        self.backend = backend
+        self.currentJob = None
+        self.smallUpdate = False
+        self.error = []
+        self.progress = PackagekitProgress()
+        self.progress.set_steps([ 
+            1, # requestingChangeSet 1
+            50, # resolveDeps2
+            51, # SetChangesetHunk3
+            52, # requestingChangeSet4
+            80,# setUpdateHUnk5
+            81,# setUpdateJob6
+            ]  )
+    # 1 >> download
+    # 4 >> download
+    def requestingChangeSet(self):
+        log.info("Callback ........ STATUS_REQUEST changeset ")
+        self.backend.status(STATUS_DOWNLOAD)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        self.progress.step()
+
+    def downloadingChangeSet(self, got, need):
+        log.info("Callback ........ STATUS_DOWNLOAD  Changeset %s percent %.2f/%.2f bytes" % ( got*100/float(need), got/MEGA,need/MEGA) )
+        self.progress.set_subpercent( got*100 / float(need) )
+        self.backend.percentage( self.progress.percent )
+        log.info( "%s percent" % self.progress.percent)
+
+
+
+    # 2  
+    def resolvingDependencies(self):
+        #self.backend.status('Resolving Dependencies')
+        log.info("Callback ........ STATUS_DEP_RESOLVE ")
+        self.backend.percentage(self.progress.percent)
+        self.backend.status(STATUS_DEP_RESOLVE)
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    # 3 
+    def setChangesetHunk(self, num, total):
+        log.info("callback. .......... set Changeset HUnk %s/%s" % (num, total ) )
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+   # 5
+    def setUpdateHunk(self, hunk, hunkCount):
+        log.info("callback. .......... set update HUnk %s/%s" % ( hunk, hunkCount))
+        self.progress.step()
+
+        if hunk < hunkCount:
+            p = hunk / float(hunkCount) * 100.0
+            self.progress.set_subpercent(p)
+        else:
+            self.smallUpdate = True
+
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    # 6
+    def setUpdateJob(self, job):
+        log.info("callback. .......... set update Job")
+        self.currentJob = job
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+
+    #7 >> preparing update
     def creatingRollback(self):
         #self.backend.status('Creating Rollback')
-        log.info("Callback ........ STATUS_ROLLBACK ")
+        log.info("Callback ........ STATUS_ROLLBACK  ")
         self.backend.status(STATUS_ROLLBACK)
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
 
-    def committingTransaction(self):
-        #self.backend.status('Committing Transaction')
-        log.info("Callback ........ STATUS_COMMIT ")
-
-        self.backend.status(STATUS_COMMIT)
-
-    def downloadingFileContents(self, got, need):
-        #self.backend.status('Downloading files for changeset')
-        log.info("Callback ........ STATUS_DOWNLOAD ")
-        self.backend.status(STATUS_DOWNLOAD)
-
-    def downloadingChangeSet(self, got, need):
-        log.info("Callback ........ STATUS_DOWNLOAD  changeset")
-        self.backend.status(STATUS_DOWNLOAD)
-
-    def requestingFileContents(self):
-        #self.backend.status('Requesting File Contents')
-        log.info("Callback ........ STATUS_REQUEST ")
-        self.backend.status(STATUS_REQUEST)
-
-    def requestingChangeSet(self):
-        #self.backend.status('Requesting Changeset')
-        log.info("Callback ........ STATUS_REQUEST changeset ")
-        self.backend.status(STATUS_REQUEST)
-
-    def removeFiles(self, filenum, total):
-        log.info("Callback ........ STATUS_REMOVE")
-        self.backend.status(STATUS_REMOVE)
-        self.preparingUpdate(filenum, total, add=total)
-    def done(self):
-        #self.backend.status('Done')
-
-        log.info("Callback ........ done! ")
-        pass
 
     def preparingUpdate(self, troveNum, troveCount, add=0):
+        log.info("callback ....... preparing Update  trove %s/%s" % (troveNum, troveCount) )
+        #self.progress.step()
         if not self.currentJob or len(self.currentJob) == 0 or troveNum > troveCount:
             return
 
         if troveNum > 0 and troveCount > 0:
             sub_percent = (add + troveNum) / (2 * float(troveCount)) * 100
-            self.backend.sub_percentage(sub_percent)
+            self.progress.set_subpercent(sub_percent)
 
-            if self.smallUpdate:
-                self.backend.percentage(sub_percent)
-
-        if troveNum != 0:
+        self.backend.percentage(self.progress.percent)
+        if troveNum > 0:
             troveNum -= 1
-
+        log.info("currentJob")
+        log.info(self.currentJob[troveNum])
         job = self.currentJob[troveNum]
         name = job[0]
         oldVersion, oldFlavor = job[1]
         newVersion, newFlavor = job[2]
-        log.info((oldVersion, newVersion))
+        #log.info("JOB>>>>>>>> %s " % str(job) )
         if oldVersion and newVersion:
-            log.info("Callback ........ STATUS_UPDATE ")
+            log.info("Callback ........ STATUS_UPDATE preparing Update ")
             self.backend.status(STATUS_UPDATE)
             package_id = self.backend.get_package_id(name, newVersion, newFlavor)
             self.backend.package(package_id, INFO_UPDATING, '')
-        elif oldVersion and not newVersion:
-            log.info("Callback ........ STATUS_REMOVE ")
-            self.backend.status(STATUS_REMOVE)
-            package_id = self.backend.get_package_id(name, oldVersion, oldFlavor)
-            self.backend.package(package_id, INFO_REMOVING, '')
         elif not oldVersion and newVersion:
-            log.info("Callback ........ STATUS_INSTALL ")
+            log.info("Callback ........ STATUS_INSTALL preparing Update")
             self.backend.status(STATUS_INSTALL)
             package_id = self.backend.get_package_id(name, newVersion, newFlavor)
             self.backend.package(package_id, INFO_INSTALLING, '')
-
+        log.info(self.progress.percent)
+    #8
     def creatingDatabaseTransaction(self, troveNum, troveCount):
+        log.info("callback. .......... creating Database Transactions")
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
         self.preparingUpdate(troveNum, troveCount, add=troveCount)
 
-    def setChangesetHunk(self, num, total):
-        pass
+    # 9
+    def committingTransaction(self):
+        #self.backend.status('Committing Transaction')
+        log.info("Callback ........ STATUS_COMMIT  transactions ")
 
-    def setUpdateHunk(self, hunk, hunkCount):
-        if hunk > 0 and hunkCount > 0:
-            percentage = hunk / float(hunkCount) * 100.0
-            self.backend.percentage(percentage)
-        else:
-            self.smallUpdate = True
+        self.backend.status(STATUS_COMMIT)
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
 
-    def setUpdateJob(self, job):
-        self.currentJob = job
+    #10
+    def updateDone(self):
+        log.info("callback. ..........  update done")
+        self.backend.percentage(self.progress.percent)
+        self.currentJob = None
+        log.info(self.progress.percent)
 
-    def updateDone(self):
-        self.currentJob = None
 
+
+    def downloadingFileContents(self, got, need):
+        #self.backend.status('Downloading files for changeset')
+        log.info("Callback ........ STATUS_DOWNLOAD  FIle Contents %s " %  str( got*100/need  ))
+        self.backend.status(STATUS_DOWNLOAD)
+        #self.backend.sub_percentage(got*100/need)
+
+    def requestingFileContents(self):
+        #self.backend.status('Requesting File Contents')
+        log.info("Callback ........ STATUS_REQUEST request File contents ")
+        self.backend.status(STATUS_REQUEST)
+
+    def removeFiles(self, filenum, total):
+        log.info("Callback ........ STATUS_REMOVE %s/%sfiles" %( filenum, total) )
+        self.backend.status(STATUS_REMOVE)
+        self.preparingUpdate(filenum, total, add=total)
+    
+    def done(self):
+        #self.backend.status('Done')
+    #    self.progress.step()
+        log.info("DONEEEEEEEEEEEE")
+ 
+    def warning(self, msg, *args, **kwargs):
+        e = msg %args
+        log.error("<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
+        log.error(e)
+        self.backend.error(ERROR_DEP_RESOLUTION_FAILED, e, False )
+        
     def tagHandlerOutput(self, tag, msg, stderr = False):
         pass
 
@@ -130,6 +399,7 @@
     def troveScriptFailure(self, typ, errcode):
         pass
 
+class RemoveCallback(callbacks.UpdateCallback):
     def __init__(self, backend, cfg=None):
         callbacks.UpdateCallback.__init__(self)
         log.info("==== callback ==== ")
@@ -139,3 +409,118 @@
         self.backend = backend
         self.currentJob = None
         self.smallUpdate = False
+        self.error = []
+        self.progress = PackagekitProgress()
+        self.progress.set_steps([ 2,5,7,8,90,100 ]  )
+     # 1
+    def resolvingDependencies(self):
+        #self.backend.status('Resolving Dependencies')
+        log.info("Callback ........ STATUS_DEP_RESOLVE ")
+        self.backend.percentage(self.progress.percent)
+        self.backend.status(STATUS_DEP_RESOLVE)
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    #2
+    def setChangesetHunk(self, num, total):
+        log.info("callback. .......... set Changeset HUnk %s/%s" % (num, total ) )
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    #3
+    def setUpdateHunk(self, hunk, hunkCount):
+        log.info("callback. .......... set update HUnk %s/%s" % ( hunk, hunkCount))
+        if hunk < hunkCount:
+            p = hunk / float(hunkCount) * 100.0
+            self.progress.set_subpercent(p)
+        else:
+            self.smallUpdate = True
+
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    #4
+    def setUpdateJob(self, job):
+        log.info("callback. .......... set update Job")
+        self.currentJob = job
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    #5
+    def creatingRollback(self):
+        #self.backend.status('Creating Rollback')
+        log.info("Callback ........ STATUS_ROLLBACK  ")
+        self.backend.status(STATUS_ROLLBACK)
+        self.progress.step()
+        #self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+     #6
+    def removeFiles(self, filenum, total):
+        log.info("Callback ........ STATUS_REMOVE %s percent %s/%s files" %(filenum*100/float(total), filenum, total) )
+        self.progress.set_subpercent( filenum*100/float(total) )
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        self.backend.status(STATUS_REMOVE)
+        self.preparingUpdate(filenum, total, add=total)
+
+    def preparingUpdate(self, troveNum, troveCount, add=0):
+        log.info("callback ....... preparing Update  trove %s/%s" % (troveNum, troveCount) )
+        #self.progress.step()
+        if not self.currentJob or len(self.currentJob) == 0 or troveNum > troveCount:
+            return
+
+        log.info("currentJob %s" % troveNum)
+        log.info("job %s" % self.currentJob)
+        if len(self.currentJob) > troveNum:
+            job = self.currentJob[troveNum]
+        else:
+            return
+        name = job[0]
+        oldVersion, oldFlavor = job[1]
+        newVersion, newFlavor = job[2]
+        #log.info("JOB>>>>>>>> %s " % str(job) )
+        if oldVersion and newVersion:
+            log.info("Callback ........ STATUS_UPDATE preparing Update ")
+            self.backend.status(STATUS_UPDATE)
+            package_id = self.backend.get_package_id(name, newVersion, newFlavor)
+            self.backend.package(package_id, INFO_UPDATING, '')
+        elif oldVersion and not newVersion:
+            log.info("Callback ........ STATUS_REMOVE preparing Update ")
+            self.backend.status(STATUS_REMOVE)
+            package_id = self.backend.get_package_id(name, oldVersion, oldFlavor)
+            self.backend.package(package_id, INFO_REMOVING, '')
+
+    def creatingDatabaseTransaction(self, troveNum, troveCount):
+        log.info("callback. .......... creating Database Transactions")
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+        #self.preparingUpdate(troveNum, troveCount, add=troveCount)
+    #8
+    def committingTransaction(self):
+        #self.backend.status('Committing Transaction')
+        log.info("Callback ........ STATUS_COMMIT  transactions ")
+
+        self.backend.status(STATUS_COMMIT)
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        log.info(self.progress.percent)
+    #9
+    def updateDone(self):
+        log.info("callback. ..........  update done")
+        self.progress.step()
+        self.backend.percentage(self.progress.percent)
+        self.currentJob = None
+        log.info(self.progress.percent)
+  
+    def done(self):
+    #    self.progress.step()
+        log.info("Some Problem ...............>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
+        log.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
+ 
+    def warning(self, msg, *args, **kwargs):
+        e = msg %args
+        self.error.append(e)
+        log.error("<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
+        log.error( args )
+        
+ 
diff -r 4c5c579015af backends/conary/conaryEnums.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/backends/conary/conaryEnums.py	Sun Feb 22 20:05:14 2009 -0600
@@ -0,0 +1,68 @@
+from packagekit.enums import GROUP_ACCESSIBILITY, GROUP_ACCESSORIES, GROUP_EDUCATION, GROUP_GAMES, GROUP_GRAPHICS, GROUP_INTERNET, GROUP_MULTIMEDIA, GROUP_OFFICE, GROUP_OTHER,  GROUP_PROGRAMMING,  GROUP_SYSTEM
+
+"""
+Classify the Categories and help me to make a backend
+
+#    from XMLCache import XMLCache 
+#    print "categoryMap = {",
+#    for i in XMLCache()._getAllCategories():
+#        print "'%s':" % i
+#    print "}",
+
+"""
+
+categoryMap = { 
+'VectorGraphics': GROUP_GRAPHICS,
+'Network': GROUP_INTERNET,
+'Spreadsheet': GROUP_OFFICE,
+'Application': GROUP_OTHER,
+'X-GNOME-NetworkSettings': GROUP_INTERNET,
+'Music': GROUP_MULTIMEDIA,
+'P2P': GROUP_INTERNET,
+'WordProcessor': GROUP_OFFICE,
+'X-GNOME-PersonalSettings': GROUP_SYSTEM,
+'Presentation': GROUP_OFFICE,
+'Email': GROUP_OFFICE,
+'Monitor': GROUP_SYSTEM,
+'Development': GROUP_PROGRAMMING,
+'Core': GROUP_SYSTEM,
+'RasterGraphics': GROUP_GRAPHICS,
+'Telephony': GROUP_INTERNET,
+'Photography': GROUP_GRAPHICS,
+'HardwareSettings': GROUP_SYSTEM,
+'News': GROUP_INTERNET,
+'X-SuSE-Core-Office': GROUP_SYSTEM,
+'X-Red-Hat-Base': GROUP_SYSTEM,
+#'GNOME': GROUP_OTHER,
+'Settings': GROUP_SYSTEM,
+#'GTK': GROUP_OTHER,
+'System': GROUP_SYSTEM,
+'Graphics': GROUP_GRAPHICS,
+'X-Ximian-Main': GROUP_OFFICE,
+'Security': GROUP_SYSTEM,
+'Audio': GROUP_MULTIMEDIA,
+'ContactManagement': GROUP_ACCESSORIES,
+'X-Novell-Main': GROUP_OFFICE,
+'AudioVideo': GROUP_MULTIMEDIA,
+'WebDevelopment': GROUP_PROGRAMMING,
+'X-GNOME-SystemSettings': GROUP_SYSTEM,
+'Office': GROUP_OFFICE,
+'Viewer': GROUP_ACCESSORIES,
+'Player': GROUP_OTHER,
+'DesktopSettings': GROUP_SYSTEM,
+'WebBrowser': GROUP_INTERNET,
+'Utility': GROUP_ACCESSORIES,
+'GUIDesigner': GROUP_PROGRAMMING,
+'TerminalEmulator': GROUP_ACCESSORIES,
+}
+
+groupMap = {}
+
+for (con_cat, pk_group) in categoryMap.items():
+    if groupMap.has_key(pk_group):
+        groupMap[pk_group].append(con_cat)
+    else:
+        groupMap[pk_group] = [con_cat]
+
+if __name__ == "__main__":
+    print groupMap
diff -r 4c5c579015af backends/conary/conaryFilter.py
--- a/backends/conary/conaryFilter.py	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/conaryFilter.py	Sun Feb 22 20:05:14 2009 -0600
@@ -24,7 +24,8 @@
 
 import re
 from pkConaryLog import log
-from conaryInit import conary_db
+from conarypk import ConaryPk
+
 class ConaryFilter(PackagekitFilter):
 
     def _pkg_get_unique(self, pkg):
@@ -44,18 +45,13 @@
         '''
         Return if the packages are installed
         '''
-        log.info("======= FILTER ===== " )
-        log.info(pkg)
-        troveTuple = pkg
-        db = conary_db()
-        try:
-            troveTuple = troveTuple[0], troveTuple[1], troveTuple[2]
-            localInstall = db.findTrove(None, troveTuple)
-            installed = True
-        except:
-            installed = False
-        log.info("Installed ???")
-        log.info(installed)
-        return installed
+        if type(pkg) == tuple:
+            pkg = pkg[0]
+        conary_cli = ConaryPk()
+        result = conary_cli.query(pkg)
+        if result:
+            return True
+        else:
+            return False
 
 
diff -r 4c5c579015af backends/conary/conaryProgress.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/backends/conary/conaryProgress.py	Sun Feb 22 20:05:14 2009 -0600
@@ -0,0 +1,105 @@
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# Copyright (C) 2008
+#    Richard Hughes <richard@hughsie.com>
+
+class PackagekitProgress:
+    '''
+    Progress class there controls the total progress of a transaction
+    the transaction is divided in n milestones. the class contains a subpercentage
+    of the current step (milestone n -> n+1) and the percentage of the whole transaction
+
+    Usage:
+
+    from packagekit import PackagekitProgress
+
+    steps = [10, 30, 50, 70] # Milestones in %
+    progress = PackagekitProgress()
+    progress.set_steps(steps)
+    for milestone in range(len(steps)):
+        # do the action is this step
+        for i in range(100):
+            # do some action
+            progress.set_subpercent(i+1)
+            print "progress : %s " % progress.percent
+        progress.step() # step to next milestone
+
+
+    *** NOTE! a BIGNOTE:
+        if you do a progress.step() and if the next is a sub_percent()  _not print the percente_ first
+        set_subpercent an then print progress.percent.
+    '''
+
+    #TODO: Add support for elapsed/remaining time
+
+    def __init__(self):
+        self.percent = 0
+        self.steps = []
+        self.current_step = 0
+        self.subpercent = 0
+
+    def set_steps(self, steps):
+        '''
+        Set the steps for the whole transaction
+        @param steps: list of int representing the percentage of each step in the transaction
+        '''
+        self.reset()
+        self.steps = steps
+        self.current_step = 0
+
+    def reset(self):
+        self.percent = 0
+        self.steps = []
+        self.current_step = 0
+        self.subpercent = 0
+
+    def step(self):
+        '''
+        Step to the next step in the transaction
+        '''
+        if self.current_step < len(self.steps)-1:
+            self.current_step += 1
+            self.percent = self.steps[self.current_step]
+            self.subpercent = 0
+        else:
+            self.percent = 100
+            self.subpercent = 0
+
+    def set_subpercent(self, pct):
+        '''
+        Set subpercentage and update percentage
+        '''
+        self.subpercent = pct
+        self._update_percent()
+
+    def _update_percent(self):
+        '''
+        Increment percentage based on current step and subpercentage
+        '''
+        if self.current_step == 0:
+            startpct = 0
+        else:
+            startpct = self.steps[self.current_step-1]
+        if self.current_step < len(self.steps)-1:
+            endpct = self.steps[self.current_step]
+        else:
+            endpct = 100
+        deltapct = endpct -startpct
+        f = float(self.subpercent)/100.0
+        incr = int(f*deltapct)
+        self.percent = startpct + incr
+
diff -r 4c5c579015af backends/conary/conarypk.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/backends/conary/conarypk.py	Sun Feb 22 20:05:14 2009 -0600
@@ -0,0 +1,119 @@
+#!/usr/bin/python
+### compatible with conary 2.0.35
+###  greets mkj
+### zodman@foresightlinux.org under the WTFPL http://sam.zoy.org/wtfpl/
+
+from conary.conaryclient import ConaryClient, cmdline
+from conary import conarycfg
+from conary.versions import Label
+from conary.errors import TroveNotFound
+from conary.conaryclient.update import NoNewTrovesError
+
+from pkConaryLog import log
+
+class ConaryPk:
+    def __init__(self):
+        # get configs from /etc/conary
+        cfg = conarycfg.ConaryConfiguration( readConfigFiles = True)
+        # get if the machine its x86 or x86_64
+        cfg.initializeFlavors()
+        self.cfg = cfg
+
+        cli = ConaryClient(cfg)
+
+        # labels enable on /etc/conary/config.d/
+        self.default_label = self.cfg.installLabelPath
+
+        # get if x86 or x86_64
+        self.flavor = self.cfg.flavor[0]
+        # for client
+        self.cli = cli
+        # for query on system (database)
+        self.db = cli.db
+        # for request query on repository (repos)
+        self.repos = cli.repos
+
+    def _get_db(self):
+        """ get the database for do querys """
+        return self.db 
+
+    def _get_repos(self):
+        """ get repos for do request query """
+        return self.repos
+
+    def label(self, installLabel = None):
+        """ get label from config or custom installLabel """
+        if installLabel:
+            return Label(installLabel)
+        return self.default_label
+    def get_labels_from_config(self):
+        labels = []
+        for i in self.default_label:
+            if "foresight.rpath.org" in i.asString():
+                labels.append(i.asString())
+        return labels
+
+    def query(self, name):
+        """ do a conary query """
+        if name is None or name == "":
+            return []
+        db = self._get_db()
+        try:
+            troves = db.findTrove( None ,(name , None, None ))
+            #return db.getTroves(troves)
+            return troves
+        except TroveNotFound:
+            return []
+
+    def request_query(self, name, installLabel = None):
+        """ Do a conary request query """
+        label = self.label( installLabel )
+        repos = self._get_repos()
+        try:
+            troves = repos.findTrove( label ,( name, None ,self.flavor ) )
+            #return repos.getTroves(troves)
+            return troves
+        except TroveNotFound:
+            return []
+
+    def get_metadata( self, name , installLabel = None):
+        pass
+        
+    def remove(self, name):
+        return self.update(name, remove = True )
+    def update(self, name, installLabel= None, remove  = False ):
+        cli = self.cli
+        #get a trove
+        troves = self.request_query(name, installLabel)
+        for trove in troves:
+            trovespec =  self.trove_to_spec( trove, remove )
+        try:
+            # create a Job
+            job = cli.newUpdateJob()
+            # Add Update task to Job
+            cli.prepareUpdateJob(job, cmdline.parseChangeList(trovespec))
+            # Apply the Job
+            cli.applyUpdateJob(job)
+            # im rulz
+            return "Update Success of %s" %  trovespec
+        except NoNewTrovesError:
+            return "no new Troves Found by %s " % trovespec
+    
+    def trove_to_spec(self, trove, remove = False ):
+        # add a -app=blah.rpath.org@rpl:devel for remove packages
+        if remove:
+            tmp = '-'
+        else:
+            tmp = ""
+        return tmp + cmdline.toTroveSpec( trove[0], str(trove[1]), None)
+
+if __name__ == "__main__":
+    conary = ConaryPk()
+    print conary.query("vim-scripts")
+    #print conary.query("gimpasdas")
+    #print conary.request_query("dpaster",'zodyrepo.rpath.org@rpl:devel')
+    #print conary.request_query("gimp")
+    #print conary.request_query("gimpasdasd")
+    #print conary.update("amsn")
+    #print conary.remove("amsn")
+
diff -r 4c5c579015af backends/conary/pk-backend-conary.c
--- a/backends/conary/pk-backend-conary.c	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/pk-backend-conary.c	Sun Feb 22 20:05:14 2009 -0600
@@ -239,6 +239,32 @@
 }
 
 /**
+    pk_backend_search_groups
+*/
+static void
+backend_search_group (PkBackend *backend, PkBitfield filters, const gchar *search)
+{
+	gchar *filters_text;
+	filters_text = pk_filter_bitfield_to_text (filters);
+	pk_backend_spawn_helper (spawn, "conaryBackend.py", "search-group", filters_text, search, NULL);
+	g_free (filters_text);
+}
+
+
+
+/**
+    pk_backend_search_details
+*/
+static void
+backend_search_details (PkBackend *backend, PkBitfield filters, const gchar *search)
+{
+	gchar *filters_text;
+	filters_text = pk_filter_bitfield_to_text (filters);
+	pk_backend_spawn_helper (spawn, "conaryBackend.py", "search-details", filters_text, search, NULL);
+	g_free (filters_text);
+}
+
+/**
  * pk_backend_update_packages:
  */
 static void
@@ -324,9 +350,9 @@
 	NULL,					/* repo_set_data */
 	backend_resolve,			/* resolve */
 	NULL,					/* rollback */
-	NULL,					/* search_details */
+	backend_search_details,					/* search_details */
 	NULL,					/* search_file */
-	NULL,					/* search_group */
+	backend_search_group,					/* search_group */
 	backend_search_name,			/* search_name */
 	backend_update_packages,		/* update_packages */
 	backend_update_system,			/* update_system */
diff -r 4c5c579015af backends/conary/pkConaryLog.py
--- a/backends/conary/pkConaryLog.py	Tue Feb 17 02:00:05 2009 -0600
+++ b/backends/conary/pkConaryLog.py	Sun Feb 22 20:05:14 2009 -0600
@@ -1,5 +1,5 @@
 #!/usr/bin/python
-
+import pprint as p
 import logging as log
 import pdb
 log.basicConfig(level=log.DEBUG,
@@ -7,3 +7,8 @@
      filename='/tmp/conarybackend.log',
                     filemode='a'
     )
+
+
+def pprint(str):
+    log.info(str)
+#    log.info( p.pprint( str, width= 10) )
