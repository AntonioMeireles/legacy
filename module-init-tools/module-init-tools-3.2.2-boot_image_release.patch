--- module-init-tools-3.2.2/Makefile.am.jau	2005-08-09 00:54:28.000000000 -0400
+++ module-init-tools-3.2.2/Makefile.am	2007-04-19 15:53:24.000000000 -0400
@@ -18,6 +18,10 @@
 EXTRA_depmod_SOURCES = moduleops_core.c
 EXTRA_modinfo_SOURCES = backwards_compat.c
 
+modprobe_SOURCES += boot_image_release.c
+depmod_SOURCES += boot_image_release.c
+modinfo_SOURCES += boot_image_release.c
+
 MAN5 = modprobe.conf.5 modules.dep.5
 MAN8 = depmod.8 insmod.8 lsmod.8 rmmod.8 modprobe.8 modinfo.8
 SGML = $(addprefix doc/,  $(MAN5:%.5=%.sgml) $(MAN8:%.8=%.sgml))
--- module-init-tools-3.2.2/modinfo.c.jau	2005-01-17 22:25:23.000000000 -0500
+++ module-init-tools-3.2.2/modinfo.c	2007-05-03 13:21:37.000000000 -0400
@@ -22,6 +22,8 @@
 #define MODULE_DIR "/lib/modules"
 #endif
 
+extern int boot_image_release(struct utsname *);
+
 static int elf_endian;
 static int my_endian;
 
@@ -290,9 +292,19 @@
 	}
 
 	/* Search for it in modules.dep. */
-	uname(&buf);
-	asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR, buf.release);
-	data = grab_file(depname, size);
+	if (boot_image_release(&buf) == 0) {
+		asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR,
+			 buf.release);
+		if (!(data = grab_file(depname, size))) {
+			free(depname);
+		}
+	}
+	if (!data) {		/* fallback */
+		uname(&buf);
+		asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR,
+			 buf.release);
+		data = grab_file(depname, size);
+	}
 	if (!data) {
 		fprintf(stderr, "modinfo: could not open %s\n", depname);
 		free(depname);
--- module-init-tools-3.2.2/depmod.c.jau	2007-05-03 14:52:27.000000000 -0400
+++ module-init-tools-3.2.2/depmod.c	2007-05-03 14:55:02.000000000 -0400
@@ -29,6 +29,8 @@
 #define MODULE_DIR "/lib/modules/"
 #endif
 
+extern int boot_image_release(struct utsname *);
+
 static int verbose;
 static unsigned int skipchars;
 
@@ -747,7 +749,7 @@
 int main(int argc, char *argv[])
 {
 	int opt, all = 0, maybe_all = 0, doing_stdout = 0;
-	char *basedir = "", *dirname, *version, *badopt = NULL,
+	char *basedir = "", *dirname = NULL, *version, *badopt = NULL,
 		*system_map = NULL;
 	struct module *list = NULL;
 	int i;
@@ -810,7 +812,21 @@
 		optind++;
 	} else {
 		struct utsname buf;
-		uname(&buf);
+		if (boot_image_release(&buf) == 0) {
+			struct stat st;
+			dirname = NOFAIL(malloc(strlen(basedir)
+						+ strlen(MODULE_DIR)
+						+ strlen(buf.release) + 1));
+			sprintf(dirname, "%s%s%s", basedir, MODULE_DIR,
+				buf.release);
+			if ((stat(dirname, &st) != 0) || !S_ISDIR(st.st_mode)) {
+				free(dirname);
+				dirname = NULL;
+			}
+		}
+		if (!dirname) { /* fallback  */
+			uname(&buf);
+		}
 		version = strdup(buf.release);
 	}
 
@@ -829,10 +845,12 @@
 	if (optind == argc)
 		all = 1;
 
-	dirname = NOFAIL(malloc(strlen(basedir)
-			 + strlen(MODULE_DIR)
-			 + strlen(version) + 1));
-	sprintf(dirname, "%s%s%s", basedir, MODULE_DIR, version);
+	if (!dirname) {
+		dirname = NOFAIL(malloc(strlen(basedir)
+					+ strlen(MODULE_DIR)
+					+ strlen(version) + 1));
+		sprintf(dirname, "%s%s%s", basedir, MODULE_DIR, version);
+	}
 
 	if (maybe_all) {
 		if (!doing_stdout && !depfile_out_of_date(dirname))
--- module-init-tools-3.2.2/modprobe.c.jau	2005-12-01 18:42:09.000000000 -0500
+++ module-init-tools-3.2.2/modprobe.c	2007-05-03 16:00:59.000000000 -0400
@@ -48,6 +48,7 @@
 
 extern long init_module(void *, unsigned long, const char *);
 extern long delete_module(const char *, unsigned int);
+extern int boot_image_release(struct utsname *);
 
 struct module {
 	struct list_head list;
@@ -1412,7 +1413,7 @@
 	unsigned int i, num_modules;
 	char *type = NULL;
 	const char *config = NULL;
-	char *dirname, *optstring;
+	char *dirname = NULL, *optstring;
 	char *newname = NULL;
 	char *aliasfilename, *symfilename;
 	errfn_t error = fatal;
@@ -1429,7 +1430,21 @@
 	if (opt == argc)
 		try_old_version("modprobe", argv);
 
-	uname(&buf);
+	if (boot_image_release(&buf) == 0) {
+		struct stat st;
+		dirname = NOFAIL(malloc(strlen(buf.release)
+					+ sizeof(MODULE_DIR) + 1));
+		sprintf(dirname, "%s/%s", MODULE_DIR, buf.release);
+		if ((stat(dirname, &st) != 0) || !S_ISDIR(st.st_mode)) {
+			free(dirname);
+			dirname = NULL;
+		}
+	}
+	if (!dirname) {		/* fallback */
+		uname(&buf);
+	}
+	free(dirname);
+
 	while ((opt = getopt_long(argc, argv, "vVC:o:rknqQsclt:aifb", options, NULL)) != -1){
 		switch (opt) {
 		case 'v':
