From: H. Peter Anvin <hpa@zytor.com>
Date: Sat, 28 Mar 2009 20:53:26 +0000 (-0700)
Subject: x86, setup: preemptively save/restore edi and ebp around INT 15 E820
X-Git-Url: http://git.kernel.org/?p=linux%2Fkernel%2Fgit%2Ftorvalds%2Flinux-2.6.git;a=commitdiff_plain;h=32ec7fd08b597586774b92ac1cd2678021ccac1b

x86, setup: preemptively save/restore edi and ebp around INT 15 E820

Impact: BIOS bugproofing

Since there are BIOSes known to clobber %ebx and %esi for INT 15 E820,
assume there is something out there clobbering %edi and/or %ebp too,
and don't wait for it to fail.

Signed-off-by: H. Peter Anvin <hpa@zytor.com>
---

diff --git a/arch/x86/boot/memory.c b/arch/x86/boot/memory.c
index a99dbbe..fcdb10a 100644
--- a/arch/x86/boot/memory.c
+++ b/arch/x86/boot/memory.c
@@ -20,7 +20,7 @@ static int detect_memory_e820(void)
 {
 	int count = 0;
 	u32 next = 0;
-	u32 size, id;
+	u32 size, id, edi;
 	u8 err;
 	struct e820entry *desc = boot_params.e820_map;
 
@@ -29,10 +29,11 @@ static int detect_memory_e820(void)
 
 		/* Important: %edx and %esi are clobbered by some BIOSes,
 		   so they must be either used for the error output
-		   or explicitly marked clobbered. */
-		asm("int $0x15; setc %0"
+		   or explicitly marked clobbered.  Given that, assume there
+		   is something out there clobbering %ebp and %edi, too. */
+		asm("pushl %%ebp; int $0x15; popl %%ebp; setc %0"
 		    : "=d" (err), "+b" (next), "=a" (id), "+c" (size),
-		      "=m" (*desc)
+		      "=D" (edi), "=m" (*desc)
 		    : "D" (desc), "d" (SMAP), "a" (0xe820)
 		    : "esi");
 
