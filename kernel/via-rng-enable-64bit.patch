Applying patch ../patches/1-linux-2.6-via.git-335095425dbd81b324a3048deab95c7616c79ae8.patch

Applying patch ../patches/2-linux-2.6-via.git-fe96668d06398ede62535739fb9483853bd29b35.patch

Applying patch ../patches/3-linux-2.6-via.git-1507086e4223df7d5e1cc38596930b17293f3daf.patch

Applying patch ../patches/4-linux-2.6-via.git-e4839e519ba71cba2c6d8c8a90db830a3c4298de.patch

--- work-2.6.29.4.orig/drivers/char/hw_random/via-rng.c
+++ work-2.6.29.4/drivers/char/hw_random/via-rng.c
@@ -132,6 +132,19 @@ static int via_rng_init(struct hwrng *rn
 	struct cpuinfo_x86 *c = &cpu_data(0);
 	u32 lo, hi, old_lo;
 
+	/* VIA Nano CPUs don't have the MSR_VIA_RNG anymore.  The RNG
+	 * is always enabled if CPUID rng_en is set.  There is no
+	 * RNG configuration like it used to be the case in this
+	 * register */
+	if ((c->x86 == 6) && (c->x86_model >= 0x0f)) {
+		if (!cpu_has_xstore_enabled) {
+			printk(KERN_ERR PFX "can't enable hardware RNG "
+				"if XSTORE is not enabled\n");
+			return -ENODEV;
+		}
+		return 0;
+	}
+
 	/* Control the RNG via MSR.  Tread lightly and pay very close
 	 * close attention to values written, as the reserved fields
 	 * are documented to be "undefined and unpredictable"; but it
@@ -205,5 +218,5 @@ static void __exit mod_exit(void)
 module_init(mod_init);
 module_exit(mod_exit);
 
-MODULE_DESCRIPTION("H/W RNG driver for VIA chipsets");
+MODULE_DESCRIPTION("H/W RNG driver for VIA CPU with PadLock");
 MODULE_LICENSE("GPL");
--- work-2.6.29.4.orig/drivers/char/hw_random/Kconfig
+++ work-2.6.29.4/drivers/char/hw_random/Kconfig
@@ -74,7 +74,7 @@ config HW_RANDOM_N2RNG
 
 config HW_RANDOM_VIA
 	tristate "VIA HW Random Number Generator support"
-	depends on HW_RANDOM && X86_32
+	depends on HW_RANDOM && X86
 	default HW_RANDOM
 	---help---
 	  This driver provides kernel-side support for the Random Number
