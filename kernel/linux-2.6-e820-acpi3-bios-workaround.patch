From: H. Peter Anvin <hpa@zytor.com>
Date: Sat, 28 Mar 2009 20:53:26 +0000 (-0700)
Subject: x86, setup: ACPI 3, BIOS workaround for E820-probing code
X-Git-Url: http://git.kernel.org/?p=linux%2Fkernel%2Fgit%2Ftorvalds%2Flinux-2.6.git;a=commitdiff_plain;h=c549e71d073a6e9a4847497344db28a784061455

x86, setup: ACPI 3, BIOS workaround for E820-probing code

Impact: ACPI 3 spec compliance, BIOS bug workaround

The ACPI 3 spec added another field to the E820 buffer -- which is
backwards incompatible, since it contains a validity bit.
Furthermore, there has been at least one report of a BIOS which
assumes that the buffer it is pointed at is the same buffer as for the
previous E820 call.  Therefore, read the data into a temporary buffer
and copy the standard part of it if and only if the valid bit is set.

Signed-off-by: H. Peter Anvin <hpa@zytor.com>
---

diff --git a/arch/x86/boot/memory.c b/arch/x86/boot/memory.c
index fcdb10a..d5d2360 100644
--- a/arch/x86/boot/memory.c
+++ b/arch/x86/boot/memory.c
@@ -2,6 +2,7 @@
  *
  *   Copyright (C) 1991, 1992 Linus Torvalds
  *   Copyright 2007 rPath, Inc. - All Rights Reserved
+ *   Copyright 2009 Intel Corporation; author H. Peter Anvin
  *
  *   This file is part of the Linux kernel, and is made available under
  *   the terms of the GNU General Public License version 2.
@@ -16,6 +17,11 @@
 
 #define SMAP	0x534d4150	/* ASCII "SMAP" */
 
+struct e820_ext_entry {
+	struct e820entry std;
+	u32 ext_flags;
+} __attribute__((packed));
+
 static int detect_memory_e820(void)
 {
 	int count = 0;
@@ -23,9 +29,10 @@ static int detect_memory_e820(void)
 	u32 size, id, edi;
 	u8 err;
 	struct e820entry *desc = boot_params.e820_map;
+	static struct e820_ext_entry buf; /* static so it is zeroed */
 
 	do {
-		size = sizeof(struct e820entry);
+		size = sizeof buf;
 
 		/* Important: %edx and %esi are clobbered by some BIOSes,
 		   so they must be either used for the error output
@@ -33,8 +40,8 @@ static int detect_memory_e820(void)
 		   is something out there clobbering %ebp and %edi, too. */
 		asm("pushl %%ebp; int $0x15; popl %%ebp; setc %0"
 		    : "=d" (err), "+b" (next), "=a" (id), "+c" (size),
-		      "=D" (edi), "=m" (*desc)
-		    : "D" (desc), "d" (SMAP), "a" (0xe820)
+		      "=D" (edi), "+m" (buf)
+		    : "D" (&buf), "d" (SMAP), "a" (0xe820)
 		    : "esi");
 
 		/* BIOSes which terminate the chain with CF = 1 as opposed
@@ -53,8 +60,14 @@ static int detect_memory_e820(void)
 			break;
 		}
 
+		/* ACPI 3.0 added the extended flags support.  If bit 0
+		   in the extended flags is zero, we're supposed to simply
+		   ignore the entry -- a backwards incompatible change! */
+		if (size > 20 && !(buf.ext_flags & 1))
+			continue;
+
+		*desc++ = buf.std;
 		count++;
-		desc++;
 	} while (next && count < ARRAY_SIZE(boot_params.e820_map));
 
 	return boot_params.e820_entries = count;
