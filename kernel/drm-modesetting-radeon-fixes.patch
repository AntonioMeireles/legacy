diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c
index 5332de5..b7a2a6c 100644
--- a/drivers/gpu/drm/radeon/atombios_crtc.c
+++ b/drivers/gpu/drm/radeon/atombios_crtc.c
@@ -222,7 +222,7 @@ atombios_crtc_set_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)
 			if (!radeon_is_avivo(dev_priv)) {
 				if (encoder->encoder_type != DRM_MODE_ENCODER_DAC)
 					pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;
-				if (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)
+				if (!radeon_is_avivo(dev_priv) && (encoder->encoder_type == DRM_MODE_ENCODER_LVDS))
 					pll_flags |= RADEON_PLL_USE_REF_DIV;
 			}
 			radeon_encoder = to_radeon_encoder(encoder);
@@ -342,8 +342,8 @@ int atombios_crtc_set_base(struct drm_crtc *crtc, int x, int y,
 	RADEON_WRITE(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
 	RADEON_WRITE(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);
 	RADEON_WRITE(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);
-	RADEON_WRITE(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, crtc->mode.hdisplay); /*XXX fb width in pixels*/
-	RADEON_WRITE(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, crtc->mode.vdisplay); /*XXX fb height in pixels*/
+	RADEON_WRITE(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, crtc->fb->width);
+	RADEON_WRITE(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, crtc->fb->height);
 
 	fb_pitch_pixels = crtc->fb->pitch / (crtc->fb->bits_per_pixel / 8);
 	RADEON_WRITE(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset, fb_pitch_pixels);
diff --git a/drivers/gpu/drm/radeon/radeon_buffer.c b/drivers/gpu/drm/radeon/radeon_buffer.c
index 86ab054..6ea52a8 100644
--- a/drivers/gpu/drm/radeon/radeon_buffer.c
+++ b/drivers/gpu/drm/radeon/radeon_buffer.c
@@ -447,11 +447,18 @@ fallback:
  */
 uint64_t radeon_evict_flags(struct drm_buffer_object *bo)
 {
+	struct drm_device *dev = bo->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int cached = 0;
+
+	if (!(dev_priv->flags & RADEON_IS_AGP))
+		cached = DRM_BO_FLAG_CACHED;
+
 	switch (bo->mem.mem_type) {
 	case DRM_BO_MEM_LOCAL:
 	case DRM_BO_MEM_TT:
-		return DRM_BO_FLAG_MEM_LOCAL;
+		return DRM_BO_FLAG_MEM_LOCAL | cached;
 	default:
-		return DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_MEM_LOCAL;
+		return DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_MEM_LOCAL | cached;
 	}
 }
diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c
index cb750f1..a8d82d4 100644
--- a/drivers/gpu/drm/radeon/radeon_combios.c
+++ b/drivers/gpu/drm/radeon/radeon_combios.c
@@ -528,8 +528,8 @@ bool radeon_combios_get_clock_info(struct drm_device *dev)
 		}
 
 		/* default sclk/mclk */
-		sclk = radeon_bios16(dev_priv, pll_info + 0x8);
-		mclk = radeon_bios16(dev_priv, pll_info + 0xa);
+		sclk = radeon_bios16(dev_priv, pll_info + 0xa);
+		mclk = radeon_bios16(dev_priv, pll_info + 0x8);
 		if (sclk == 0)
 			sclk = 200;
 		if (mclk == 0)
diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c
index 531774a..7ddc8fd 100644
--- a/drivers/gpu/drm/radeon/radeon_cursor.c
+++ b/drivers/gpu/drm/radeon/radeon_cursor.c
@@ -160,7 +160,8 @@ int radeon_crtc_cursor_set(struct drm_crtc *crtc,
 	if (!handle) {
 		/* turn off cursor */
 		radeon_hide_cursor(crtc);
-		return 0;
+		obj = NULL;
+		goto unpin;
 	}
 
 	if ((width > CURSOR_WIDTH) || (height > CURSOR_HEIGHT)) {
@@ -184,6 +185,7 @@ int radeon_crtc_cursor_set(struct drm_crtc *crtc,
 	radeon_show_cursor(crtc);
 	radeon_lock_cursor(crtc, false);
 
+unpin:
 	if (radeon_crtc->cursor_bo) {
 		radeon_gem_object_unpin(radeon_crtc->cursor_bo);
 		mutex_lock(&crtc->dev->struct_mutex);
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 2d5ffc9..2bbdd39 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -242,6 +242,7 @@ int radeon_ddc_get_modes(struct radeon_connector *radeon_connector)
 		kfree(edid);
 		return ret;
 	}
+	drm_mode_connector_update_edid_property(&radeon_connector->base, NULL);
 	return -1;
 }
 
diff --git a/drivers/gpu/drm/radeon/radeon_drv.h b/drivers/gpu/drm/radeon/radeon_drv.h
index f3e4109..b789378 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.h
+++ b/drivers/gpu/drm/radeon/radeon_drv.h
@@ -2211,7 +2211,7 @@ struct drm_radeon_gem_object {
 	struct drm_buffer_object *bo;
 	struct drm_fence_object *fence;
 	struct drm_gem_object *obj;
-	
+	int pin_count;
 };
 
 #define RADEON_IB_MEMORY (1*1024*1024)
diff --git a/drivers/gpu/drm/radeon/radeon_encoders.c b/drivers/gpu/drm/radeon/radeon_encoders.c
index d3777a4..433ebc9 100644
--- a/drivers/gpu/drm/radeon/radeon_encoders.c
+++ b/drivers/gpu/drm/radeon/radeon_encoders.c
@@ -219,8 +219,7 @@ static bool radeon_atom_mode_fixup(struct drm_encoder *encoder,
 }
 
 static void
-atombios_dac_setup(struct drm_encoder *encoder,
-		   struct drm_display_mode *mode)
+atombios_dac_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
@@ -245,7 +244,7 @@ atombios_dac_setup(struct drm_encoder *encoder,
 		break;
 	}
 
-	args.ucAction = ATOM_ENABLE;
+	args.ucAction = action;
 
 	if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
 		args.ucDacStandard = ATOM_DAC1_PS2;
@@ -268,15 +267,14 @@ atombios_dac_setup(struct drm_encoder *encoder,
 			break;
 		}
 	}
-	args.usPixelClock = cpu_to_le16(mode->clock / 10);
+	args.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 
 	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
 
 }
 
 static void
-atombios_tv_setup(struct drm_encoder *encoder,
-		  struct drm_display_mode *mode)
+atombios_tv_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
@@ -290,7 +288,7 @@ atombios_tv_setup(struct drm_encoder *encoder,
 
 	index = GetIndexIntoMasterTable(COMMAND, TVEncoderControl);
 
-	args.sTVEncoder.ucAction = ATOM_ENABLE;
+	args.sTVEncoder.ucAction = action;
 
 	if (radeon_encoder->devices & (ATOM_DEVICE_CV_SUPPORT))
 		args.sTVEncoder.ucTvStandard = ATOM_TV_CV;
@@ -326,18 +324,18 @@ atombios_tv_setup(struct drm_encoder *encoder,
 		}
 	}
 
-	args.sTVEncoder.usPixelClock = cpu_to_le16(mode->clock / 10);
+	args.sTVEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 
 	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
 
 }
 
 void
-atombios_external_tmds_setup(struct drm_encoder *encoder,
-			     struct drm_display_mode *mode)
+atombios_external_tmds_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION args;
 	int index = 0;
 
@@ -345,9 +343,9 @@ atombios_external_tmds_setup(struct drm_encoder *encoder,
 
 	index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);
 
-	args.sXTmdsEncoder.ucEnable = ATOM_ENABLE;
+	args.sXTmdsEncoder.ucEnable = action;
 
-	if (mode->clock > 165000)
+	if (radeon_encoder->pixel_clock > 165000)
 		args.sXTmdsEncoder.ucMisc = PANEL_ENCODER_MISC_DUAL;
 
 	/*if (pScrn->rgbBits == 8)*/
@@ -358,11 +356,11 @@ atombios_external_tmds_setup(struct drm_encoder *encoder,
 }
 
 static void
-atombios_ddia_setup(struct drm_encoder *encoder,
-		    struct drm_display_mode *mode)
+atombios_ddia_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	DVO_ENCODER_CONTROL_PS_ALLOCATION args;
 	int index = 0;
 
@@ -370,10 +368,10 @@ atombios_ddia_setup(struct drm_encoder *encoder,
 
 	index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);
 
-	args.sDVOEncoder.ucAction = ATOM_ENABLE;
-	args.sDVOEncoder.usPixelClock = cpu_to_le16(mode->clock / 10);
+	args.sDVOEncoder.ucAction = action;
+	args.sDVOEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 
-	if (mode->clock > 165000)
+	if (radeon_encoder->pixel_clock > 165000)
 		args.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute = PANEL_ENCODER_MISC_DUAL;
 
 	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
@@ -386,8 +384,7 @@ union lvds_encoder_control {
 };
 
 static void
-atombios_digital_setup(struct drm_encoder *encoder,
-		       struct drm_display_mode *mode)
+atombios_digital_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
@@ -442,12 +439,12 @@ atombios_digital_setup(struct drm_encoder *encoder,
 		switch (crev) {
 		case 1:
 			args.v1.ucMisc = 0;
-			args.v1.ucAction = PANEL_ENCODER_ACTION_ENABLE;
+			args.v1.ucAction = action;
 			/* XXX should probably check based on edid */
 			if ((connector->connector_type == DRM_MODE_CONNECTOR_HDMIA) ||
 			    (connector->connector_type == DRM_MODE_CONNECTOR_HDMIB))
 				args.v1.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;
-			args.v1.usPixelClock = cpu_to_le16(mode->clock / 10);
+			args.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 			if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 				if (dig->lvds_misc & (1 << 0))
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;
@@ -456,7 +453,7 @@ atombios_digital_setup(struct drm_encoder *encoder,
 			} else {
 				if (dig_connector->linkb)
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;
-				if (mode->clock > 165000)
+				if (radeon_encoder->pixel_clock > 165000)
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;
 				/*if (pScrn->rgbBits == 8) */
 				args.v1.ucMisc |= (1 << 1);
@@ -465,7 +462,7 @@ atombios_digital_setup(struct drm_encoder *encoder,
 		case 2:
 		case 3:
 			args.v2.ucMisc = 0;
-			args.v2.ucAction = PANEL_ENCODER_ACTION_ENABLE;
+			args.v2.ucAction = action;
 			if (crev == 3) {
 				if (dig->coherent_mode)
 					args.v2.ucMisc |= PANEL_ENCODER_MISC_COHERENT;
@@ -474,7 +471,7 @@ atombios_digital_setup(struct drm_encoder *encoder,
 			if ((connector->connector_type == DRM_MODE_CONNECTOR_HDMIA) ||
 			    (connector->connector_type == DRM_MODE_CONNECTOR_HDMIB))
 				args.v2.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;
-			args.v2.usPixelClock = cpu_to_le16(mode->clock / 10);
+			args.v2.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 			args.v2.ucTruncate = 0;
 			args.v2.ucSpatial = 0;
 			args.v2.ucTemporal = 0;
@@ -497,7 +494,7 @@ atombios_digital_setup(struct drm_encoder *encoder,
 			} else {
 				if (dig_connector->linkb)
 					args.v2.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;
-				if (mode->clock > 165000)
+				if (radeon_encoder->pixel_clock > 165000)
 					args.v2.ucMisc |= PANEL_ENCODER_MISC_DUAL;
 			}
 			break;
@@ -582,16 +579,15 @@ atombios_get_encoder_mode(struct drm_encoder *encoder)
 }
 
 static void
-atombios_dig_encoder_setup(struct drm_encoder *encoder,
-			   struct drm_display_mode *mode)
+atombios_dig_encoder_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	struct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);
 	DIG_ENCODER_CONTROL_PS_ALLOCATION args;
 	int index = 0, num = 0;
 	uint8_t frev, crev;
+	struct radeon_encoder_atom_dig *dig;
 	struct drm_connector *connector;
 	struct radeon_connector *radeon_connector;
 	struct radeon_connector_atom_dig *dig_connector;
@@ -607,24 +603,25 @@ atombios_dig_encoder_setup(struct drm_encoder *encoder,
 
 	dig_connector = radeon_connector->con_priv;
 
+	if (!radeon_encoder->enc_priv)
+		return;
+
+	dig = radeon_encoder->enc_priv;
+
 	memset(&args, 0, sizeof(args));
 
 	if (radeon_is_dce32(dev_priv)) {
-		if (radeon_crtc->crtc_id)
+		if (dig->dig_block)
 			index = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);
 		else
 			index = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);
-		num = radeon_crtc->crtc_id + 1;
+		num = dig->dig_block + 1;
 	} else {
 		switch (radeon_encoder->encoder_id) {
-		case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 			index = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);
 			num = 1;
 			break;
-		case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 			index = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);
 			num = 2;
@@ -634,8 +631,8 @@ atombios_dig_encoder_setup(struct drm_encoder *encoder,
 
 	atom_parse_cmd_header(dev_priv->mode_info.atom_context, index, &frev, &crev);
 
-	args.ucAction = ATOM_ENABLE;
-	args.usPixelClock = cpu_to_le16(mode->clock / 10);
+	args.ucAction = action;
+	args.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
 
 	if (radeon_is_dce32(dev_priv)) {
 		switch (radeon_encoder->encoder_id) {
@@ -651,20 +648,16 @@ atombios_dig_encoder_setup(struct drm_encoder *encoder,
 		}
 	} else {
 		switch (radeon_encoder->encoder_id) {
-		case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 			args.ucConfig = ATOM_ENCODER_CONFIG_TRANSMITTER1;
 			break;
-		case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 			args.ucConfig = ATOM_ENCODER_CONFIG_TRANSMITTER2;
 			break;
 		}
 	}
 
-	if (mode->clock > 165000) {
+	if (radeon_encoder->pixel_clock > 165000) {
 		args.ucConfig |= ATOM_ENCODER_CONFIG_LINKA_B;
 		args.ucLaneNum = 8;
 	} else {
@@ -687,13 +680,11 @@ union dig_transmitter_control {
 };
 
 static void
-atombios_dig_transmitter_setup(struct drm_encoder *encoder,
-			       struct drm_display_mode *mode)
+atombios_dig_transmitter_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	struct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);
 	union dig_transmitter_control args;
 	int index = 0, num = 0;
 	uint8_t frev, crev;
@@ -724,13 +715,9 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 		index = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);
 	else {
 		switch (radeon_encoder->encoder_id) {
-		case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 			index = GetIndexIntoMasterTable(COMMAND, DIG1TransmitterControl);
 			break;
-		case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 			index = GetIndexIntoMasterTable(COMMAND, DIG2TransmitterControl);
 			break;
@@ -739,16 +726,16 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 
 	atom_parse_cmd_header(dev_priv->mode_info.atom_context, index, &frev, &crev);
 
-	args.v1.ucAction = ATOM_TRANSMITTER_ACTION_ENABLE;
+	args.v1.ucAction = action;
 
 	if (radeon_is_dce32(dev_priv)) {
-		if (mode->clock > 165000) {
-			args.v2.usPixelClock = cpu_to_le16((mode->clock * 10 * 2) / 100);
+		if (radeon_encoder->pixel_clock > 165000) {
+			args.v2.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock * 10 * 2) / 100);
 			args.v2.acConfig.fDualLinkConnector = 1;
 		} else {
-			args.v2.usPixelClock = cpu_to_le16((mode->clock * 10 * 4) / 100);
+			args.v2.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock * 10 * 4) / 100);
 		}
-		if (radeon_crtc->crtc_id)
+		if (dig->dig_block)
 			args.v2.acConfig.ucEncoderSel = 1;
 
 		switch (radeon_encoder->encoder_id) {
@@ -772,24 +759,20 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 		}
 	} else {
 		args.v1.ucConfig = ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;
-		args.v1.usPixelClock = cpu_to_le16((mode->clock) / 10);
+		args.v1.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock) / 10);
 
 		switch (radeon_encoder->encoder_id) {
-		case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 			args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG1_ENCODER;
 			if (dev_priv->flags & RADEON_IS_IGP) {
-				if (mode->clock > 165000) {
+				if (radeon_encoder->pixel_clock > 165000) {
 					args.v1.ucConfig |= (ATOM_TRANSMITTER_CONFIG_8LANE_LINK |
 							     ATOM_TRANSMITTER_CONFIG_LINKA_B);
-					/* fixme!!! lanes are based on connector, not encoder*/
 					if (dig_connector->igp_lane_info & 0x3)
 						args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_7;
 					else if (dig_connector->igp_lane_info & 0xc)
 						args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_8_15;
 				} else {
-					/* fixme!!! lanes are based on connector, not encoder*/
 					args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKA;
 					if (dig_connector->igp_lane_info & 0x1)
 						args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_3;
@@ -801,7 +784,7 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 						args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_12_15;
 				}
 			} else {
-				if (mode->clock > 165000)
+				if (radeon_encoder->pixel_clock > 165000)
 					args.v1.ucConfig |= (ATOM_TRANSMITTER_CONFIG_8LANE_LINK |
 							     ATOM_TRANSMITTER_CONFIG_LINKA_B |
 							     ATOM_TRANSMITTER_CONFIG_LANE_0_7);
@@ -813,11 +796,9 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 				}
 			}
 			break;
-		case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 			args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG2_ENCODER;
-			if (mode->clock > 165000)
+			if (radeon_encoder->pixel_clock > 165000)
 				args.v1.ucConfig |= (ATOM_TRANSMITTER_CONFIG_8LANE_LINK |
 						     ATOM_TRANSMITTER_CONFIG_LINKA_B |
 						     ATOM_TRANSMITTER_CONFIG_LANE_0_7);
@@ -835,7 +816,6 @@ atombios_dig_transmitter_setup(struct drm_encoder *encoder,
 				args.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;
 		}
 	}
-	dig->transmitter_config = args.v1.ucConfig;
 
 	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
 
@@ -1073,19 +1053,37 @@ static void
 atombios_yuv_setup(struct drm_encoder *encoder, bool enable)
 {
 	struct drm_device *dev = encoder->dev;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct drm_radeon_private *dev_priv = dev->dev_private;
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);
 	ENABLE_YUV_PS_ALLOCATION args;
 	int index = GetIndexIntoMasterTable(COMMAND, EnableYUV);
+	uint32_t temp, reg;
 
 	memset(&args, 0, sizeof(args));
 
+	if (dev_priv->chip_family >= CHIP_R600)
+		reg = R600_BIOS_3_SCRATCH;
+	else
+		reg = RADEON_BIOS_3_SCRATCH;
+
+	temp = RADEON_READ(reg);
+	if (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT))
+		RADEON_WRITE(reg, (ATOM_S3_TV1_ACTIVE |
+				(radeon_crtc->crtc_id << 18)));
+	else if (radeon_encoder->devices & (ATOM_DEVICE_CV_SUPPORT))
+		RADEON_WRITE(reg, (ATOM_S3_CV_ACTIVE |
+				(radeon_crtc->crtc_id << 18)));
+	else
+		RADEON_WRITE(reg, 0);
+
 	if (enable)
 		args.ucEnable = ATOM_ENABLE;
 	args.ucCRTC = radeon_crtc->crtc_id;
 
 	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
 
+	RADEON_WRITE(reg, 0);
 }
 
 static void
@@ -1138,8 +1136,7 @@ atombios_overscan_setup(struct drm_encoder *encoder,
 }
 
 static void
-atombios_scaler_setup(struct drm_encoder *encoder,
-		      struct drm_display_mode *mode)
+atombios_scaler_setup(struct drm_encoder *encoder)
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_radeon_private *dev_priv = dev->dev_private;
@@ -1213,57 +1210,6 @@ atombios_scaler_setup(struct drm_encoder *encoder,
 }
 
 static void
-atombios_dig_dpms(struct drm_encoder *encoder, int mode)
-{
-	struct drm_device *dev = encoder->dev;
-	struct drm_radeon_private *dev_priv = dev->dev_private;
-	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	DIG_TRANSMITTER_CONTROL_PS_ALLOCATION args;
-	int index = 0;
-	struct radeon_encoder_atom_dig *dig;
-
-	if (!radeon_encoder->enc_priv)
-		return;
-
-	dig = radeon_encoder->enc_priv;
-
-	memset(&args, 0, sizeof(args));
-
-	switch (mode) {
-	case DRM_MODE_DPMS_ON:
-		args.ucAction = ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT;
-		break;
-	case DRM_MODE_DPMS_STANDBY:
-	case DRM_MODE_DPMS_SUSPEND:
-	case DRM_MODE_DPMS_OFF:
-		args.ucAction = ATOM_TRANSMITTER_ACTION_DISABLE_OUTPUT;
-		break;
-	}
-
-	args.ucConfig = dig->transmitter_config;
-
-	if (radeon_is_dce32(dev_priv))
-		index = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);
-	else {
-		switch (radeon_encoder->encoder_id) {
-		case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
-		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
-			index = GetIndexIntoMasterTable(COMMAND, DIG1TransmitterControl);
-			break;
-		case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
-		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
-			index = GetIndexIntoMasterTable(COMMAND, DIG2TransmitterControl);
-			break;
-		}
-	}
-
-	atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
-
-}
-
-static void
 radeon_atom_encoder_dpms(struct drm_encoder *encoder, int mode)
 {
 	struct drm_device *dev = encoder->dev;
@@ -1320,9 +1266,18 @@ radeon_atom_encoder_dpms(struct drm_encoder *encoder, int mode)
 		break;
 	}
 
-	if (is_dig)
-		atombios_dig_dpms(encoder, mode);
-	else {
+	if (is_dig) {
+		switch (mode) {
+		case DRM_MODE_DPMS_ON:
+			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE);
+			break;
+		case DRM_MODE_DPMS_STANDBY:
+		case DRM_MODE_DPMS_SUSPEND:
+		case DRM_MODE_DPMS_OFF:
+			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_DISABLE);
+			break;
+		}
+	} else {
 		switch (mode) {
 		case DRM_MODE_DPMS_ON:
 			args.ucAction = ATOM_ENABLE;
@@ -1365,8 +1320,12 @@ atombios_set_encoder_crtc_source(struct drm_encoder *encoder)
 		default:
 			if (radeon_is_avivo(dev_priv))
 				args.v1.ucCRTC = radeon_crtc->crtc_id;
-			else
-				args.v1.ucCRTC = radeon_crtc->crtc_id << 2;
+			else {
+				if (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1)
+					args.v1.ucCRTC = radeon_crtc->crtc_id;
+				else
+					args.v1.ucCRTC = radeon_crtc->crtc_id << 2;
+			}
 			switch (radeon_encoder->encoder_id) {
 			case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
 			case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
@@ -1492,9 +1451,17 @@ radeon_atom_encoder_mode_set(struct drm_encoder *encoder,
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);
 
+	if (radeon_encoder->enc_priv) {
+		struct radeon_encoder_atom_dig *dig;
+
+		dig = radeon_encoder->enc_priv;
+		dig->dig_block = radeon_crtc->crtc_id;
+	}
+	radeon_encoder->pixel_clock = adjusted_mode->clock;
+
 	radeon_atombios_encoder_crtc_scratch_regs(encoder, radeon_crtc->crtc_id);
 	atombios_overscan_setup(encoder, mode, adjusted_mode);
-	atombios_scaler_setup(encoder, adjusted_mode);
+	atombios_scaler_setup(encoder);
 	atombios_set_encoder_crtc_source(encoder);
 
 	if (radeon_is_avivo(dev_priv)) {
@@ -1509,29 +1476,31 @@ radeon_atom_encoder_mode_set(struct drm_encoder *encoder,
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
 	case ENCODER_OBJECT_ID_INTERNAL_LVDS:
 	case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
-		atombios_digital_setup(encoder, adjusted_mode);
+		atombios_digital_setup(encoder, PANEL_ENCODER_ACTION_ENABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
-		atombios_dig_encoder_setup(encoder, adjusted_mode);
-		atombios_dig_transmitter_setup(encoder, adjusted_mode);
+		atombios_dig_encoder_setup(encoder, ATOM_ENABLE);
+		atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_INIT);
+		atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_SETUP);
+		atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DDI:
-		atombios_ddia_setup(encoder, adjusted_mode);
+		atombios_ddia_setup(encoder, ATOM_ENABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
-		atombios_external_tmds_setup(encoder, adjusted_mode);
+		atombios_external_tmds_setup(encoder, ATOM_ENABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_DAC2:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
-		atombios_dac_setup(encoder, adjusted_mode);
+		atombios_dac_setup(encoder, ATOM_ENABLE);
 		if (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))
-			atombios_tv_setup(encoder, adjusted_mode);
+			atombios_tv_setup(encoder, ATOM_ENABLE);
 		break;
 	}
 	atombios_apply_encoder_quirks(encoder, adjusted_mode);
@@ -1557,7 +1526,8 @@ atombios_dac_load_detect(struct drm_encoder *encoder)
 
 		args.sDacload.ucMisc = 0;
 
-		if (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1)
+		if (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1 ||
+		    radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1)
 			args.sDacload.ucDacType = ATOM_DAC_A;
 		else
 			args.sDacload.ucDacType = ATOM_DAC_B;
@@ -1570,8 +1540,11 @@ atombios_dac_load_detect(struct drm_encoder *encoder)
 			args.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CV_SUPPORT);
 			if (crev >= 3)
 				args.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;
-		} else if (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT)
+		} else if (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {
 			args.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_TV1_SUPPORT);
+			if (crev >= 3)
+				args.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;
+		}
 
 		atom_execute_table(dev_priv->mode_info.atom_context, index, (uint32_t *)&args);
 
diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c
index 244b066..148ee30 100644
--- a/drivers/gpu/drm/radeon/radeon_fb.c
+++ b/drivers/gpu/drm/radeon/radeon_fb.c
@@ -913,6 +913,7 @@ int radeonfb_remove(struct drm_device *dev, struct drm_framebuffer *fb)
 		drm_bo_kunmap(&radeon_fb->kmap_obj);
 		dev_priv->mm.vram_visible += radeon_fb->obj->size;
 		mutex_lock(&dev->struct_mutex);
+		radeon_gem_object_unpin(radeon_fb->obj);
 		drm_gem_object_unreference(radeon_fb->obj);
 		radeon_fb->obj = NULL;
 		mutex_unlock(&dev->struct_mutex);
diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index 2fd1c5d..15103cb 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
@@ -677,11 +677,15 @@ int radeon_alloc_gart_objects(struct drm_device *dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	int ret;
+	int cached = 0;
+
+	if (!(dev_priv->flags & RADEON_IS_AGP))
+		cached = DRM_BO_FLAG_CACHED;
 
 	ret = drm_buffer_object_create(dev, RADEON_DEFAULT_RING_SIZE,
 				       drm_bo_type_kernel,
 				       DRM_BO_FLAG_READ | DRM_BO_FLAG_MEM_TT |
-				       DRM_BO_FLAG_MAPPABLE | DRM_BO_FLAG_NO_EVICT,
+				       DRM_BO_FLAG_MAPPABLE | DRM_BO_FLAG_NO_EVICT | cached,
 				       0, 1, 0, &dev_priv->mm.ring.bo);
 	if (ret) {
 		if (dev_priv->flags & RADEON_IS_AGP)
@@ -701,7 +705,7 @@ int radeon_alloc_gart_objects(struct drm_device *dev)
 	ret = drm_buffer_object_create(dev, PAGE_SIZE,
 				       drm_bo_type_kernel,
 				       DRM_BO_FLAG_WRITE |DRM_BO_FLAG_READ | DRM_BO_FLAG_MEM_TT |
-				       DRM_BO_FLAG_MAPPABLE | DRM_BO_FLAG_NO_EVICT,
+				       DRM_BO_FLAG_MAPPABLE | DRM_BO_FLAG_NO_EVICT | cached,
 				       0, 1, 0, &dev_priv->mm.ring_read.bo);
 	if (ret) {
 		DRM_ERROR("failed to allocate ring read\n");
@@ -1220,6 +1224,10 @@ int radeon_gem_object_pin(struct drm_gem_object *obj,
 
 	obj_priv = obj->driver_private;
 
+	obj_priv->pin_count++;
+	if (obj_priv->pin_count != 1)
+		return 0;
+
 	if (pin_domain) {
 		mask |= DRM_BO_MASK_MEM;
 		if (pin_domain == RADEON_GEM_DOMAIN_GTT)
@@ -1242,6 +1250,10 @@ int radeon_gem_object_unpin(struct drm_gem_object *obj)
 
 	obj_priv = obj->driver_private;
 
+	obj_priv->pin_count--;
+	if (obj_priv->pin_count != 0)
+		return 0;
+
 	ret = drm_bo_do_validate(obj_priv->bo, 0, DRM_BO_FLAG_NO_EVICT,
 				 DRM_BO_HINT_DONT_FENCE, 0);
 
diff --git a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
index a991fb0..175397c 100644
--- a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
+++ b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
@@ -823,7 +823,8 @@ static void radeon_legacy_tmds_ext_mode_set(struct drm_encoder *encoder,
 		radeon_legacy_rmx_mode_set(encoder, mode, adjusted_mode);
 
 	if (dev_priv->is_atom_bios) {
-		atombios_external_tmds_setup(encoder, adjusted_mode);
+ 		radeon_encoder->pixel_clock = adjusted_mode->clock;
+ 		atombios_external_tmds_setup(encoder, ATOM_ENABLE);
 		fp2_gen_cntl = RADEON_READ(RADEON_FP2_GEN_CNTL);
 	} else {
 		fp2_gen_cntl = RADEON_READ(RADEON_FP2_GEN_CNTL);
diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h
index 43c28f8..963859c 100644
--- a/drivers/gpu/drm/radeon/radeon_mode.h
+++ b/drivers/gpu/drm/radeon/radeon_mode.h
@@ -234,8 +234,8 @@ struct radeon_encoder_int_tmds {
 
 struct radeon_encoder_atom_dig {
 	/* atom dig */
-	uint32_t transmitter_config;
 	bool coherent_mode;
+	int dig_block;
 	/* atom lvds */
 	uint32_t lvds_misc;
 	uint16_t panel_pwr_delay;
@@ -248,6 +248,7 @@ struct radeon_encoder {
 	uint32_t encoder_id;
 	uint32_t devices;
 	uint32_t flags;
+	uint32_t pixel_clock;
 	enum radeon_rmx_type rmx_type;
 	struct radeon_native_mode native_mode;
 	void *enc_priv;
@@ -296,8 +297,7 @@ struct drm_encoder *radeon_encoder_legacy_primary_dac_add(struct drm_device *dev
 struct drm_encoder *radeon_encoder_legacy_tv_dac_add(struct drm_device *dev, int bios_index, int with_tv);
 struct drm_encoder *radeon_encoder_legacy_tmds_int_add(struct drm_device *dev, int bios_index);
 struct drm_encoder *radeon_encoder_legacy_tmds_ext_add(struct drm_device *dev, int bios_index);
-extern void atombios_external_tmds_setup(struct drm_encoder *encoder,
-					 struct drm_display_mode *mode);
+extern void atombios_external_tmds_setup(struct drm_encoder *encoder, int action);
 extern int atombios_get_encoder_mode(struct drm_encoder *encoder);
 
 extern void radeon_crtc_load_lut(struct drm_crtc *crtc);
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index ac7bc0a..0d2f4a5 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -111,8 +111,6 @@ int radeon_resume(struct drm_device *dev)
 	if (pci_enable_device(dev->pdev))
 		return -1;
 
-	/* Turn on bus mastering -todo fix properly */
-	radeon_enable_bm(dev_priv);
 
 	DRM_ERROR("\n");
 	/* on atom cards re init the whole card 
@@ -125,7 +123,6 @@ int radeon_resume(struct drm_device *dev)
 		radeon_combios_asic_init(dev);
 	}
 
-	pci_set_master(dev->pdev);
 
 	for (i = 0; i < 8; i++)
 		RADEON_WRITE(RADEON_BIOS_0_SCRATCH + (i * 4), dev_priv->pmregs.bios_scratch[i]);
@@ -150,6 +147,10 @@ int radeon_resume(struct drm_device *dev)
 	
 	radeon_init_memory_map(dev);
 
+	pci_set_master(dev->pdev);
+	/* Turn on bus mastering -todo fix properly */
+	radeon_enable_bm(dev_priv);
+
 	if (dev_priv->flags & RADEON_IS_PCIE) {
 		memcpy_toio(dev_priv->mm.pcie_table.kmap.virtual, dev_priv->mm.pcie_table_backup, dev_priv->gart_info.table_size);
 	}
