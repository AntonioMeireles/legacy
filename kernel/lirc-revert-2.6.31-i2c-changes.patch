 drivers/input/lirc/lirc_i2c.c   |  216 ++++++++++++++++++++++++++++++---------
 drivers/input/lirc/lirc_zilog.c |   58 +++++----
 2 files changed, 198 insertions(+), 76 deletions(-)

diff --git a/drivers/input/lirc/lirc_i2c.c b/drivers/input/lirc/lirc_i2c.c
index e27d937..dedf415 100644
--- a/drivers/input/lirc/lirc_i2c.c
+++ b/drivers/input/lirc/lirc_i2c.c
@@ -168,18 +168,15 @@ static int add_to_buf_haup_common(void *data, struct lirc_buffer *buf,
 	struct IR *ir = data;
 	__u16 code;
 	unsigned char codes[2];
-	int ret;
 
 	/* poll IR chip */
-	ret = i2c_master_recv(&ir->c, keybuf, size);
-	if (ret == size) {
+	if (size == i2c_master_recv(&ir->c, keybuf, size)) {
 		ir->b[0] = keybuf[offset];
 		ir->b[1] = keybuf[offset+1];
 		ir->b[2] = keybuf[offset+2];
-		if (ir->b[0] != 0x00 && ir->b[1] != 0x00)
-			dprintk("key (0x%02x/0x%02x)\n", ir->b[0], ir->b[1]);
+		dprintk("key (0x%02x/0x%02x)\n", ir->b[0], ir->b[1]);
 	} else {
-		dprintk("read error (ret=%d)\n", ret);
+		dprintk("read error\n");
 		/* keep last successful read buffer */
 	}
 
@@ -194,7 +191,6 @@ static int add_to_buf_haup_common(void *data, struct lirc_buffer *buf,
 	codes[1] = code & 0xff;
 
 	/* return it */
-	dprintk("sending code 0x%02x%02x to lirc\n", codes[0], codes[1]);
 	lirc_buffer_write(buf, codes);
 	return 0;
 }
@@ -327,8 +323,6 @@ static int set_use_inc(void *data)
 {
 	struct IR *ir = data;
 
-	dprintk("%s called\n", __func__);
-
 	/* lock bttv in memory while /dev/lirc is in use  */
 	i2c_use_client(&ir->c);
 
@@ -339,8 +333,6 @@ static void set_use_dec(void *data)
 {
 	struct IR *ir = data;
 
-	dprintk("%s called\n", __func__);
-
 	i2c_release_client(&ir->c);
 }
 
@@ -352,64 +344,45 @@ static struct lirc_driver lirc_template = {
 	.owner		= THIS_MODULE,
 };
 
-static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int ir_remove(struct i2c_client *client);
+static int ir_attach(struct i2c_adapter *adap, int addr,
+		      unsigned short flags, int kind);
+static int ir_detach(struct i2c_client *client);
+static int ir_probe(struct i2c_adapter *adap);
 static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg);
 
-static const struct i2c_device_id ir_receiver_id[] = {
-	/* Generic entry for any IR receiver */
-	{ "ir_video", 0 },
-	/* IR device specific entries could be added here */
-	{ }
-};
-
 static struct i2c_driver driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "i2c ir driver",
 	},
-	.probe		= ir_probe,
-	.remove		= ir_remove,
-	.id_table	= ir_receiver_id,
+	.attach_adapter	= ir_probe,
+	.detach_client	= ir_detach,
 	.command	= ir_command,
 };
 
-static void pcf_probe(struct i2c_client *client, struct IR *ir)
-{
-	int ret1, ret2, ret3, ret4;
-
-	ret1 = i2c_smbus_write_byte(client, 0xff);
-	ret2 = i2c_smbus_read_byte(client);
-	ret3 = i2c_smbus_write_byte(client, 0x00);
-	ret4 = i2c_smbus_read_byte(client);
-
-	/* in the Asus TV-Box: bit 1-0 */
-	if (((ret2 & 0x03) == 0x03) && ((ret4 & 0x03) == 0x00)) {
-		ir->bits = (unsigned char) ~0x07;
-		ir->flag = 0x04;
-	/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
-	} else if (((ret2 & 0xc0) == 0xc0) && ((ret4 & 0xc0) == 0x00)) {
-		ir->bits = (unsigned char) ~0xe0;
-		ir->flag = 0x20;
-	}
-
-	return;
-}
+static struct i2c_client client_template = {
+	.name		= "unset",
+	.driver		= &driver
+};
 
-static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int ir_attach(struct i2c_adapter *adap, int addr,
+		     unsigned short flags, int kind)
 {
 	struct IR *ir;
-	struct i2c_adapter *adap = client->adapter;
-	unsigned short addr = client->addr;
-	int retval;
+	int err, retval;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
 
 	ir = kzalloc(sizeof(struct IR), GFP_KERNEL);
 	if (!ir)
 		return -ENOMEM;
 	memcpy(&ir->l, &lirc_template, sizeof(struct lirc_driver));
-	memcpy(&ir->c, client, sizeof(struct i2c_client));
+	memcpy(&ir->c, &client_template, sizeof(struct i2c_client));
 
-	i2c_set_clientdata(client, ir);
+	ir->c.adapter = adap;
+	ir->c.addr    = addr;
+	i2c_set_clientdata(&ir->c, ir);
 	ir->l.data    = ir;
 	ir->l.minor   = minor;
 	ir->l.sample_rate = 10;
@@ -465,10 +438,11 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		break;
 	case 0x21:
 	case 0x23:
-		pcf_probe(client, ir);
 		strlcpy(ir->c.name, "TV-Box IR", I2C_NAME_SIZE);
 		ir->l.code_length = 8;
 		ir->l.add_to_buf = add_to_buf_pcf8574;
+		ir->bits = flags & 0xff;
+		ir->flag = (flags >> 8) & 0xff;
 		break;
 	default:
 		/* shouldn't happen */
@@ -479,6 +453,13 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	printk(KERN_INFO "lirc_i2c: chip 0x%x found @ 0x%02x (%s)\n",
 	       adap->id, addr, ir->c.name);
 
+	/* register device */
+	err = i2c_attach_client(&ir->c);
+	if (err) {
+		kfree(ir);
+		return err;
+	}
+
 	retval = lirc_register_driver(&ir->l);
 
 	if (retval < 0) {
@@ -492,18 +473,149 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	return 0;
 }
 
-static int ir_remove(struct i2c_client *client)
+static int ir_detach(struct i2c_client *client)
 {
 	struct IR *ir = i2c_get_clientdata(client);
 
 	/* unregister device */
 	lirc_unregister_driver(ir->l.minor);
+	i2c_detach_client(&ir->c);
 
 	/* free memory */
 	kfree(ir);
 	return 0;
 }
 
+static int ir_probe(struct i2c_adapter *adap)
+{
+	/*
+	 * The external IR receiver is at i2c address 0x34 (0x35 for
+	 * reads).  Future Hauppauge cards will have an internal
+	 * receiver at 0x30 (0x31 for reads).  In theory, both can be
+	 * fitted, and Hauppauge suggest an external overrides an
+	 * internal.
+	 *
+	 * That's why we probe 0x1a (~0x34) first. CB
+	 *
+	 * The i2c address for the Hauppauge PVR-150 card is 0xe2,
+	 * so we need to probe 0x71 as well.
+	 */
+
+	static const int probe[] = {
+		0x1a, /* Hauppauge IR external */
+		0x18, /* Hauppauge IR internal */
+		0x71, /* Hauppauge IR (PVR150) */
+		0x4b, /* PV951 IR */
+		0x64, /* Pixelview IR */
+		0x30, /* KNC ONE IR */
+		0x6b, /* Adaptec IR */
+		-1};
+
+	static const int probe_cx88[] = {
+		0x18, /* Leadtek Winfast PVR2000 */
+		0x71, /* Hauppauge HVR-IR */
+		-1};
+
+	struct i2c_client c;
+	char buf;
+	int i, rc;
+	memset(&c, 0, sizeof(c));
+
+	if (adap->id == I2C_HW_B_BT848 ||
+	    adap->id == I2C_HW_B_CX2341X) {
+		c.adapter = adap;
+		for (i = 0; -1 != probe[i]; i++) {
+			c.addr = probe[i];
+			rc = i2c_master_recv(&c, &buf, 1);
+			dprintk("probe 0x%02x @ %s: %s\n",
+				probe[i], adap->name,
+				(1 == rc) ? "yes" : "no");
+			if (1 == rc) {
+				rc = ir_attach(adap, probe[i], 0, 0);
+				if (rc < 0)
+					goto attach_fail;
+			}
+		}
+	}
+
+	/* Leadtek Winfast PVR2000 or Hauppauge HVR-1300 */
+	else if (adap->id == I2C_HW_B_CX2388x) {
+		c.adapter = adap;
+		for (i = 0; -1 != probe_cx88[i]; i++) {
+			c.addr = probe_cx88[i];
+			rc = i2c_master_recv(&c, &buf, 1);
+			dprintk("probe 0x%02x @ %s: %s\n",
+				c.addr, adap->name,
+				(1 == rc) ? "yes" : "no");
+			if (1 == rc) {
+				rc = ir_attach(adap, c.addr, 0, 0);
+				if (rc < 0)
+					goto attach_fail;
+			}
+		}
+	}
+
+	/* Asus TV-Box and Creative/VisionTek BreakOut-Box (PCF8574) */
+	else if (adap->id == I2C_HW_B_RIVA) {
+		/*
+		 * addresses to probe;
+		 * leave 0x24 and 0x25 because SAA7113H possibly uses it
+		 * 0x21 and 0x22 possibly used by SAA7108E
+		 * Asus:      0x21 is a correct address (channel 1 of PCF8574)
+		 * Creative:  0x23 is a correct address (channel 3 of PCF8574)
+		 * VisionTek: 0x23 is a correct address (channel 3 of PCF8574)
+		 */
+		static const int pcf_probe[] = { 0x20, 0x21, 0x22, 0x23,
+						 0x24, 0x25, 0x26, 0x27, -1 };
+		int ret1, ret2, ret3, ret4;
+		unsigned char bits = 0, flag = 0;
+
+		c.adapter = adap;
+		for (i = 0; -1 != pcf_probe[i]; i++) {
+			c.addr = pcf_probe[i];
+			ret1 = i2c_smbus_write_byte(&c, 0xff);
+			ret2 = i2c_smbus_read_byte(&c);
+			ret3 = i2c_smbus_write_byte(&c, 0x00);
+			ret4 = i2c_smbus_read_byte(&c);
+
+			/* ensure that the writable bitmask works correctly */
+			rc = 0;
+			if (ret1 != -1 && ret2 != -1 &&
+			    ret3 != -1 && ret4 != -1) {
+				/* in the Asus TV-Box: bit 1-0 */
+				if (((ret2 & 0x03) == 0x03) &&
+				    ((ret4 & 0x03) == 0x00)) {
+					bits = (unsigned char) ~0x07;
+					flag = 0x04;
+					rc = 1;
+				}
+			/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
+				if (((ret2 & 0xc0) == 0xc0) &&
+				    ((ret4 & 0xc0) == 0x00)) {
+					bits = (unsigned char) ~0xe0;
+					flag = 0x20;
+					rc = 1;
+				}
+			}
+			dprintk("probe 0x%02x @ %s: %s\n",
+				c.addr, adap->name, rc ? "yes" : "no");
+			if (rc) {
+				rc = ir_attach(adap, pcf_probe[i],
+					       bits | (flag << 8), 0);
+				if (rc < 0)
+					goto attach_fail;
+			}
+		}
+	}
+
+	return 0;
+
+attach_fail:
+	printk(KERN_ERR "lirc_i2c: %s: ir_attach failed!\n", __func__);
+	return rc;
+
+}
+
 static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
 	/* nothing */

diff --git b/drivers/input/lirc/lirc_zilog.c a/drivers/input/lirc/lirc_zilog.c
index c532399..049c3da 100644
--- b/drivers/input/lirc/lirc_zilog.c
+++ a/drivers/input/lirc/lirc_zilog.c
@@ -1088,26 +1088,18 @@ static struct lirc_driver lirc_template = {
 };
 
 static int ir_attach(struct i2c_adapter *adap, int have_rx, int have_tx);
-static int ir_remove(struct i2c_client *client);
-static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int ir_detach(struct i2c_client *client);
+static int ir_probe(struct i2c_adapter *adap);
 static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg);
 
-static const struct i2c_device_id ir_transceiver_id[] = {
-	/* Generic entry for any IR transceiver */
-	{ "ir_video", 0 },
-	/* IR device specific entries could be added here */
-	{ }
-};
-
 static struct i2c_driver driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "i2c ir driver",
 	},
-	.probe		= ir_probe,
-	.remove		= ir_remove,
+	.attach_adapter	= ir_probe,
+	.detach_client	= ir_detach,
 	.command	= ir_command,
-	.id_table	= ir_transceiver_id,
 };
 
 static struct i2c_client client_template = {
@@ -1128,8 +1120,20 @@ static struct file_operations lirc_fops = {
 
 static int i2c_attach(struct i2c_client *client, struct IR *ir)
 {
+	int ret;
+
 	i2c_set_clientdata(client, ir);
 
+	ret = i2c_attach_client(client);
+	if (ret != 0) {
+		client->addr = 0;
+		return ret;
+	}
+	if (!i2c_use_client(client)) {
+		i2c_detach_client(client);
+		client->addr = 0;
+		return -EFAULT;
+	}
 	++ir->devs;
 	return 0;
 }
@@ -1230,13 +1234,13 @@ static int ir_attach(struct i2c_adapter *adap, int have_rx, int have_tx)
 err:
 	/* undo everything, hopefully... */
 	if (ir->c_rx.addr)
-		ir_remove(&ir->c_rx);
+		ir_detach(&ir->c_rx);
 	if (ir->c_tx.addr)
-		ir_remove(&ir->c_tx);
+		ir_detach(&ir->c_tx);
 	return ret;
 }
 
-static int ir_remove(struct i2c_client *client)
+static int ir_detach(struct i2c_client *client)
 {
 	struct IR *ir = i2c_get_clientdata(client);
 	mutex_lock(&ir->lock);
@@ -1257,17 +1261,21 @@ static int ir_remove(struct i2c_client *client)
 			ir->t_notify2 = NULL;
 		}
 
+		/* unregister device */
+		i2c_detach_client(&ir->c_rx);
+	} else if (client == &ir->c_tx) {
+		i2c_detach_client(&ir->c_tx);
 	} else {
 		mutex_unlock(&ir->lock);
-		zilog_error("%s: detached from something we didn't "
-			    "attach to\n", __func__);
+		zilog_error("ir_detach: detached from something we didn't "
+			    "attach to\n");
 		return -ENODEV;
 	}
 
 	--ir->devs;
 	if (ir->devs < 0) {
 		mutex_unlock(&ir->lock);
-		zilog_error("%s: invalid device count\n", __func__);
+		zilog_error("ir_detach: invalid device count\n");
 		return -ENODEV;
 	} else if (ir->devs == 0) {
 		/* unregister lirc driver */
@@ -1286,10 +1294,11 @@ static int ir_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int ir_probe(struct i2c_adapter *adap)
 {
-	struct i2c_adapter *adap = client->adapter;
+	struct i2c_client c;
 	char buf;
+	memset(&c, 0, sizeof(c));
 
 	if (adap->id == I2C_HW_B_BT848 ||
 #ifdef I2C_HW_B_HDPVR
@@ -1302,10 +1311,11 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		 * The external IR receiver is at i2c address 0x71.
 		 * The IR transmitter is at 0x70.
 		 */
-		client->addr = 0x70;
+		c.adapter = adap;
+		c.addr = 0x70;
 
 		if (!disable_rx) {
-			if (i2c_master_recv(client, &buf, 1) == 1)
+			if (i2c_master_recv(&c, &buf, 1) == 1)
 				have_rx = 1;
 			dprintk("probe 0x70 @ %s: %s\n",
 				adap->name,
@@ -1313,8 +1323,8 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		}
 
 		if (!disable_tx) {
-			client->addr = 0x71;
-			if (i2c_master_recv(client, &buf, 1) == 1)
+			c.addr = 0x71;
+			if (i2c_master_recv(&c, &buf, 1) == 1)
 				have_tx = 1;
 			dprintk("probe 0x71 @ %s: %s\n",
 				adap->name,
