diff -urN linux/drivers/media/video/gspca/Kconfig linux/drivers/media/video/gspca/Kconfig
--- linux/drivers/media/video/gspca/Kconfig	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/Kconfig	2008-12-09 21:37:33.000000000 +0100
@@ -12,7 +12,7 @@
 	  "Video For Linux" to use this driver.
 
 	  To compile this driver as modules, choose M here: the
-	  modules will be called gspca_main.
+	  module will be called gspca_main.
 
 
 if USB_GSPCA && VIDEO_V4L2
@@ -64,6 +64,16 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called gspca_ov519.
 
+config USB_GSPCA_OV534
+	tristate "OV534 USB Camera Driver"
+	depends on VIDEO_V4L2 && USB_GSPCA
+	help
+	  Say Y here if you want support for cameras based on the OV534 chip.
+	  (e.g. Sony Playstation EYE)
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gspca_ov534.
+
 config USB_GSPCA_PAC207
 	tristate "Pixart PAC207 USB Camera Driver"
 	depends on VIDEO_V4L2 && USB_GSPCA
@@ -83,10 +93,11 @@
 	  module will be called gspca_pac7311.
 
 config USB_GSPCA_SONIXB
-	tristate "SN9C102 USB Camera Driver"
+	tristate "SONIX Bayer USB Camera Driver"
 	depends on VIDEO_V4L2 && USB_GSPCA
 	help
-	  Say Y here if you want support for cameras based on the SONIXB chip.
+	  Say Y here if you want support for cameras based on the Sonix
+	  chips with Bayer format (SN9C101, SN9C102 and SN9C103).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called gspca_sonixb.
@@ -95,7 +106,8 @@
 	tristate "SONIX JPEG USB Camera Driver"
 	depends on VIDEO_V4L2 && USB_GSPCA
 	help
-	  Say Y here if you want support for cameras based on the SONIXJ chip.
+	  Say Y here if you want support for cameras based on the Sonix
+	  chips with JPEG format (SN9C102P, SN9C105 and >= SN9C110).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called gspca_sonixj
@@ -171,7 +183,7 @@
 	  SPCA504(abc) SPCA533 SPCA536 chips.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called gspca_spca5xx.
+	  module will be called gspca_sunplus.
 
 config USB_GSPCA_T613
 	tristate "T613 (JPEG Compliance) USB Camera Driver"
diff -urN linux/drivers/media/video/gspca/Makefile linux/drivers/media/video/gspca/Makefile
--- linux/drivers/media/video/gspca/Makefile	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/Makefile	2008-12-09 21:37:33.000000000 +0100
@@ -4,6 +4,7 @@
 obj-$(CONFIG_USB_GSPCA_FINEPIX)	+= gspca_finepix.o
 obj-$(CONFIG_USB_GSPCA_MARS)	+= gspca_mars.o
 obj-$(CONFIG_USB_GSPCA_OV519)	+= gspca_ov519.o
+obj-$(CONFIG_USB_GSPCA_OV534)	+= gspca_ov534.o
 obj-$(CONFIG_USB_GSPCA_PAC207)	+= gspca_pac207.o
 obj-$(CONFIG_USB_GSPCA_PAC7311) += gspca_pac7311.o
 obj-$(CONFIG_USB_GSPCA_SONIXB)	+= gspca_sonixb.o
@@ -27,6 +28,7 @@
 gspca_finepix-objs		:= finepix.o
 gspca_mars-objs			:= mars.o
 gspca_ov519-objs		:= ov519.o
+gspca_ov534-objs		:= ov534.o
 gspca_pac207-objs		:= pac207.o
 gspca_pac7311-objs		:= pac7311.o
 gspca_sonixb-objs		:= sonixb.o
diff -urN linux/drivers/media/video/gspca/finepix.c linux/drivers/media/video/gspca/finepix.c
--- linux/drivers/media/video/gspca/finepix.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/finepix.c	2008-12-09 21:37:33.000000000 +0100
@@ -314,9 +314,6 @@
 	int ret;
 	int size_ret;
 
-	/* Reset bulk in endpoint */
-	usb_clear_halt(gspca_dev->dev, gspca_dev->cam.epaddr);
-
 	/* Init the device */
 	memset(gspca_dev->usb_buf, 0, 12);
 	gspca_dev->usb_buf[0] = 0xc6;
diff -urN linux/drivers/media/video/gspca/gspca.c linux/drivers/media/video/gspca/gspca.c
--- linux/drivers/media/video/gspca/gspca.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/gspca.c	2008-12-25 15:33:23.000000000 +0100
@@ -45,7 +48,7 @@
 MODULE_DESCRIPTION("GSPCA USB Camera Driver");
 MODULE_LICENSE("GPL");
 
-#define DRIVER_VERSION_NUMBER	KERNEL_VERSION(2, 3, 0)
+#define DRIVER_VERSION_NUMBER	KERNEL_VERSION(2, 4, 0)
 
 static int video_nr = -1;
 
@@ -150,8 +153,11 @@
 
 		/* check the packet status and length */
 		len = urb->iso_frame_desc[i].actual_length;
-		if (len == 0)
+		if (len == 0) {
+			if (gspca_dev->empty_packet == 0)
+				gspca_dev->empty_packet = 1;
 			continue;
+		}
 		st = urb->iso_frame_desc[i].status;
 		if (st) {
 			PDEBUG(D_ERR,
@@ -170,7 +176,6 @@
 	}
 
 	/* resubmit the URB */
-	urb->status = 0;
 	st = usb_submit_urb(urb, GFP_ATOMIC);
 	if (st < 0)
 		PDEBUG(D_ERR|D_PACK, "usb_submit_urb() ret %d", st);
@@ -200,11 +204,18 @@
 {
 	struct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;
 	struct gspca_frame *frame;
+	int st;
 
 	PDEBUG(D_PACK, "bulk irq");
 	if (!gspca_dev->streaming)
 		return;
-	if (urb->status != 0 && urb->status != -ECONNRESET) {
+	switch (urb->status) {
+	case 0:
+		break;
+	case -ECONNRESET:
+		urb->status = 0;
+		break;
+	default:
 #ifdef CONFIG_PM
 		if (!gspca_dev->frozen)
 #endif
@@ -223,6 +241,13 @@
 					urb->transfer_buffer,
 					urb->actual_length);
 	}
+
+	/* resubmit the URB */
+	if (gspca_dev->cam.bulk_nurbs != 0) {
+		st = usb_submit_urb(urb, GFP_ATOMIC);
+		if (st < 0)
+			PDEBUG(D_ERR|D_PACK, "usb_submit_urb() ret %d", st);
+	}
 }
 
 /*
@@ -285,7 +310,6 @@
 		frame->v4l2_buf.bytesused = frame->data_end - frame->data;
 		frame->v4l2_buf.flags &= ~V4L2_BUF_FLAG_QUEUED;
 		frame->v4l2_buf.flags |= V4L2_BUF_FLAG_DONE;
-		atomic_inc(&gspca_dev->nevent);
 		wake_up_interruptible(&gspca_dev->wq);	/* event = new frame */
 		i = (gspca_dev->fr_i + 1) % gspca_dev->nframes;
 		gspca_dev->fr_i = i;
@@ -379,7 +403,6 @@
 	gspca_dev->fr_i = gspca_dev->fr_o = gspca_dev->fr_q = 0;
 	gspca_dev->last_packet_type = DISCARD_PACKET;
 	gspca_dev->sequence = 0;
-	atomic_set(&gspca_dev->nevent, 0);
 	return 0;
 }
 
@@ -520,11 +543,14 @@
 		nurbs = DEF_NURBS;
 	} else {				/* bulk */
 		npkt = 0;
-		bsize = gspca_dev->cam.	bulk_size;
+		bsize = gspca_dev->cam.bulk_size;
 		if (bsize == 0)
 			bsize = psize;
 		PDEBUG(D_STREAM, "bulk bsize:%d", bsize);
-		nurbs = 1;
+		if (gspca_dev->cam.bulk_nurbs != 0)
+			nurbs = gspca_dev->cam.bulk_nurbs;
+		else
+			nurbs = 1;
 	}
 
 	gspca_dev->nurbs = nurbs;
@@ -597,6 +623,12 @@
 		if (ret < 0)
 			goto out;
 
+		/* clear the bulk endpoint */
+		if (gspca_dev->alt == 0)	/* if bulk transfer */
+			usb_clear_halt(gspca_dev->dev,
+					usb_rcvintpipe(gspca_dev->dev,
+						 gspca_dev->cam.epaddr));
+
 		/* start the cam */
 		ret = gspca_dev->sd_desc->start(gspca_dev);
 		if (ret < 0) {
@@ -604,10 +636,9 @@
 			goto out;
 		}
 		gspca_dev->streaming = 1;
-		atomic_set(&gspca_dev->nevent, 0);
 
-		/* bulk transfers are started by the subdriver */
-		if (gspca_dev->alt == 0)
+		/* some bulk transfers are started by the subdriver */
+		if (gspca_dev->alt == 0 && gspca_dev->cam.bulk_nurbs == 0)
 			break;
 
 		/* submit the URBs */
@@ -618,8 +649,11 @@
 					"usb_submit_urb [%d] err %d", n, ret);
 				gspca_dev->streaming = 0;
 				destroy_urbs(gspca_dev);
-				if (ret == -ENOSPC)
+				if (ret == -ENOSPC) {
+					msleep(20);	/* wait for kill
+							 * complete */
 					break;	/* try the previous alt */
+				}
 				goto out;
 			}
 		}
@@ -637,7 +671,7 @@
 
 	ret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 0);
 	if (ret < 0)
-		PDEBUG(D_ERR|D_STREAM, "set interface 0 err %d", ret);
+		PDEBUG(D_ERR|D_STREAM, "set alt 0 err %d", ret);
 	return ret;
 }
 
@@ -645,7 +679,6 @@
 static void gspca_stream_off(struct gspca_dev *gspca_dev)
 {
 	gspca_dev->streaming = 0;
-	atomic_set(&gspca_dev->nevent, 0);
 	if (gspca_dev->present
 	    && gspca_dev->sd_desc->stopN)
 		gspca_dev->sd_desc->stopN(gspca_dev);
@@ -727,7 +760,7 @@
 			if (fmtdesc->index == index)
 				break;		/* new format */
 			index++;
-			if (index >= sizeof fmt_tb / sizeof fmt_tb[0])
+			if (index >= ARRAY_SIZE(fmt_tb))
 				return -EINVAL;
 		}
 	}
@@ -752,8 +785,6 @@
 	struct gspca_dev *gspca_dev = priv;
 	int mode;
 
-	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
 	mode = gspca_dev->curr_mode;
 	memcpy(&fmt->fmt.pix, &gspca_dev->cam.cam_mode[mode],
 		sizeof fmt->fmt.pix);
@@ -765,8 +796,6 @@
 {
 	int w, h, mode, mode2;
 
-	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
 	w = fmt->fmt.pix.width;
 	h = fmt->fmt.pix.height;
 
@@ -846,11 +875,11 @@
 	return ret;
 }
 
-static void gspca_delete(struct kref *kref)
+static void gspca_release(struct video_device *vfd)
 {
-	struct gspca_dev *gspca_dev = container_of(kref, struct gspca_dev, kref);
+	struct gspca_dev *gspca_dev = container_of(vfd, struct gspca_dev, vdev);
 
-	PDEBUG(D_STREAM, "device deleted");
+	PDEBUG(D_STREAM, "device released");
 
 	kfree(gspca_dev->usb_buf);
 	kfree(gspca_dev);
@@ -862,7 +891,7 @@
 	int ret;
 
 	PDEBUG(D_STREAM, "%s open", current->comm);
-	gspca_dev = video_drvdata(file);
+	gspca_dev = (struct gspca_dev *) video_devdata(file);
 	if (mutex_lock_interruptible(&gspca_dev->queue_lock))
 		return -ERESTARTSYS;
 	if (!gspca_dev->present) {
@@ -883,17 +912,14 @@
 
 	gspca_dev->users++;
 
-	/* one more user */
-	kref_get(&gspca_dev->kref);
-
 	file->private_data = gspca_dev;
 #ifdef GSPCA_DEBUG
 	/* activate the v4l2 debug */
 	if (gspca_debug & D_V4L2)
-		gspca_dev->vdev->debug |= V4L2_DEBUG_IOCTL
+		gspca_dev->vdev.debug |= V4L2_DEBUG_IOCTL
 					| V4L2_DEBUG_IOCTL_ARG;
 	else
-		gspca_dev->vdev->debug &= ~(V4L2_DEBUG_IOCTL
+		gspca_dev->vdev.debug &= ~(V4L2_DEBUG_IOCTL
 					| V4L2_DEBUG_IOCTL_ARG);
 #endif
 	ret = 0;
@@ -932,8 +958,6 @@
 
 	PDEBUG(D_STREAM, "close done");
 
-	kref_put(&gspca_dev->kref, gspca_delete);
-
 	return 0;
 }
 
@@ -1053,6 +1077,35 @@
 	return -EINVAL;
 }
 
+/*fixme: have an audio flag in gspca_dev?*/
+static int vidioc_s_audio(struct file *file, void *priv,
+			 struct v4l2_audio *audio)
+{
+	if (audio->index != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int vidioc_g_audio(struct file *file, void *priv,
+			 struct v4l2_audio *audio)
+{
+	memset(audio, 0, sizeof *audio);
+	strcpy(audio->name, "Microphone");
+	return 0;
+}
+
+static int vidioc_enumaudio(struct file *file, void *priv,
+			 struct v4l2_audio *audio)
+{
+	if (audio->index != 0)
+		return -EINVAL;
+
+	strcpy(audio->name, "Microphone");
+	audio->capability = 0;
+	audio->mode = 0;
+	return 0;
+}
+
 static int vidioc_querymenu(struct file *file, void *priv,
 			    struct v4l2_querymenu *qmenu)
 {
@@ -1096,8 +1149,6 @@
 	struct gspca_dev *gspca_dev = priv;
 	int i, ret = 0;
 
-	if (rb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
 	switch (rb->memory) {
 	case GSPCA_MEMORY_READ:			/* (internal call) */
 	case V4L2_MEMORY_MMAP:
@@ -1162,8 +1213,7 @@
 	struct gspca_dev *gspca_dev = priv;
 	struct gspca_frame *frame;
 
-	if (v4l2_buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE
-	    || v4l2_buf->index < 0
+	if (v4l2_buf->index < 0
 	    || v4l2_buf->index >= gspca_dev->nframes)
 		return -EINVAL;
 
@@ -1186,7 +1236,8 @@
 		ret = -ENODEV;
 		goto out;
 	}
-	if (gspca_dev->nframes == 0) {
+	if (gspca_dev->nframes == 0
+	    || !(gspca_dev->frame[0].v4l2_buf.flags & V4L2_BUF_FLAG_QUEUED)) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -1236,7 +1287,6 @@
 	gspca_dev->fr_i = gspca_dev->fr_o = gspca_dev->fr_q = 0;
 	gspca_dev->last_packet_type = DISCARD_PACKET;
 	gspca_dev->sequence = 0;
-	atomic_set(&gspca_dev->nevent, 0);
 	ret = 0;
 out:
 	mutex_unlock(&gspca_dev->queue_lock);
@@ -1281,6 +1331,17 @@
 	memset(parm, 0, sizeof *parm);
 	parm->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	parm->parm.capture.readbuffers = gspca_dev->nbufread;
+
+	if (gspca_dev->sd_desc->get_streamparm) {
+		int ret;
+
+		if (mutex_lock_interruptible(&gspca_dev->usb_lock))
+			return -ERESTARTSYS;
+		ret = gspca_dev->sd_desc->get_streamparm(gspca_dev, parm);
+		mutex_unlock(&gspca_dev->usb_lock);
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -1295,6 +1356,17 @@
 		parm->parm.capture.readbuffers = gspca_dev->nbufread;
 	else
 		gspca_dev->nbufread = n;
+
+	if (gspca_dev->sd_desc->set_streamparm) {
+		int ret;
+
+		if (mutex_lock_interruptible(&gspca_dev->usb_lock))
+			return -ERESTARTSYS;
+		ret = gspca_dev->sd_desc->set_streamparm(gspca_dev, parm);
+		mutex_unlock(&gspca_dev->usb_lock);
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -1440,33 +1512,22 @@
 	i = gspca_dev->fr_o;
 	j = gspca_dev->fr_queue[i];
 	frame = &gspca_dev->frame[j];
-	if (frame->v4l2_buf.flags & V4L2_BUF_FLAG_DONE) {
-		atomic_dec(&gspca_dev->nevent);
-		goto ok;
-	}
-	if (nonblock_ing)			/* no frame yet */
-		return -EAGAIN;
 
-	/* wait till a frame is ready */
-	for (;;) {
+	if (!(frame->v4l2_buf.flags & V4L2_BUF_FLAG_DONE)) {
+		if (nonblock_ing)
+			return -EAGAIN;
+
+		/* wait till a frame is ready */
 		ret = wait_event_interruptible_timeout(gspca_dev->wq,
-					atomic_read(&gspca_dev->nevent) > 0,
-					msecs_to_jiffies(3000));
-		if (ret <= 0) {
-			if (ret < 0)
-				return ret;	/* interrupt */
-			return -EIO;		/* timeout */
-		}
-		atomic_dec(&gspca_dev->nevent);
-		if (!gspca_dev->streaming || !gspca_dev->present)
+			(frame->v4l2_buf.flags & V4L2_BUF_FLAG_DONE) ||
+			!gspca_dev->streaming || !gspca_dev->present,
+			msecs_to_jiffies(3000));
+		if (ret < 0)
+			return ret;
+		if (ret == 0 || !gspca_dev->streaming || !gspca_dev->present)
 			return -EIO;
-		i = gspca_dev->fr_o;
-		j = gspca_dev->fr_queue[i];
-		frame = &gspca_dev->frame[j];
-		if (frame->v4l2_buf.flags & V4L2_BUF_FLAG_DONE)
-			break;
 	}
-ok:
+
 	gspca_dev->fr_o = (i + 1) % gspca_dev->nframes;
 	PDEBUG(D_FRAM, "frame wait q:%d i:%d o:%d",
 		gspca_dev->fr_q,
@@ -1494,8 +1555,6 @@
 	int i, ret;
 
 	PDEBUG(D_FRAM, "dqbuf");
-	if (v4l2_buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
 	if (v4l2_buf->memory != gspca_dev->memory)
 		return -EINVAL;
 
@@ -1550,8 +1609,6 @@
 	int i, index, ret;
 
 	PDEBUG(D_FRAM, "qbuf %d", v4l2_buf->index);
-	if (v4l2_buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
 
 	if (mutex_lock_interruptible(&gspca_dev->queue_lock))
 		return -ERESTARTSYS;
@@ -1781,6 +1838,9 @@
 	.vidioc_queryctrl	= vidioc_queryctrl,
 	.vidioc_g_ctrl		= vidioc_g_ctrl,
 	.vidioc_s_ctrl		= vidioc_s_ctrl,
+	.vidioc_g_audio		= vidioc_g_audio,
+	.vidioc_s_audio		= vidioc_s_audio,
+	.vidioc_enumaudio	= vidioc_enumaudio,
 	.vidioc_querymenu	= vidioc_querymenu,
 	.vidioc_enum_input	= vidioc_enum_input,
 	.vidioc_g_input		= vidioc_g_input,
@@ -1802,7 +1862,7 @@
 	.name = "gspca main driver",
 	.fops = &dev_fops,
 	.ioctl_ops = &dev_ioctl_ops,
-	.release = video_device_release,
+	.release = gspca_release,
 	.minor = -1,
 };
 
@@ -1840,7 +1900,6 @@
 		err("couldn't kzalloc gspca struct");
 		return -ENOMEM;
 	}
-	kref_init(&gspca_dev->kref);
 	gspca_dev->usb_buf = kmalloc(USB_BUF_SZ, GFP_KERNEL);
 	if (!gspca_dev->usb_buf) {
 		err("out of memory");
@@ -1852,12 +1911,13 @@
 	gspca_dev->nbalt = intf->num_altsetting;
 	gspca_dev->sd_desc = sd_desc;
 	gspca_dev->nbufread = 2;
+	gspca_dev->empty_packet = -1;	/* don't check the empty packets */
 
 	/* configure the subdriver and initialize the USB device */
-	ret = gspca_dev->sd_desc->config(gspca_dev, id);
+	ret = sd_desc->config(gspca_dev, id);
 	if (ret < 0)
 		goto out;
-	ret = gspca_dev->sd_desc->init(gspca_dev);
+	ret = sd_desc->init(gspca_dev);
 	if (ret < 0)
 		goto out;
 	ret = gspca_set_alt0(gspca_dev);
@@ -1871,18 +1931,15 @@
 	init_waitqueue_head(&gspca_dev->wq);
 
 	/* init video stuff */
-	gspca_dev->vdev = video_device_alloc();
-	memcpy(gspca_dev->vdev, &gspca_template, sizeof gspca_template);
-	gspca_dev->vdev->parent = &dev->dev;
+	memcpy(&gspca_dev->vdev, &gspca_template, sizeof gspca_template);
+	gspca_dev->vdev.parent = &dev->dev;
 	gspca_dev->module = module;
 	gspca_dev->present = 1;
-	video_set_drvdata(gspca_dev->vdev, gspca_dev);
-	ret = video_register_device(gspca_dev->vdev,
+	ret = video_register_device(&gspca_dev->vdev,
 				  VFL_TYPE_GRABBER,
 				  video_nr);
 	if (ret < 0) {
 		err("video_register_device err %d", ret);
-		video_device_release(gspca_dev->vdev);
 		goto out;
 	}
 
@@ -1906,15 +1963,14 @@
 {
 	struct gspca_dev *gspca_dev = usb_get_intfdata(intf);
 
-	usb_set_intfdata(intf, NULL);
-
-/* We don't want people trying to open up the device */
-	video_unregister_device(gspca_dev->vdev);
-
 	gspca_dev->present = 0;
 	gspca_dev->streaming = 0;
 
-	kref_put(&gspca_dev->kref, gspca_delete);
+	usb_set_intfdata(intf, NULL);
+
+	/* release the device */
+	/* (this will call gspca_release() immediatly or on last close) */
+	video_unregister_device(&gspca_dev->vdev);
 
 	PDEBUG(D_PROBE, "disconnect complete");
 }
@@ -1992,7 +2048,7 @@
 	   desired lumination fast (with the risc of a slight overshoot) */
 	steps = abs(desired_avg_lum - avg_lum) / deadzone;
 
-	PDEBUG(D_FRAM, "autogain: lum: %d, desired: %d, steps: %d\n",
+	PDEBUG(D_FRAM, "autogain: lum: %d, desired: %d, steps: %d",
 		avg_lum, desired_avg_lum, steps);
 
 	for (i = 0; i < steps; i++) {
diff -urN linux/drivers/media/video/gspca/gspca.h linux/drivers/media/video/gspca/gspca.h
--- linux/drivers/media/video/gspca/gspca.h	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/gspca.h	2008-12-10 19:53:43.000000000 +0100
@@ -58,6 +58,10 @@
 	int bulk_size;		/* buffer size when image transfer by bulk */
 	struct v4l2_pix_format *cam_mode;	/* size nmodes */
 	char nmodes;
+	__u8 bulk_nurbs;	/* number of URBs in bulk mode
+				 * - cannot be > MAX_NURBS
+				 * - when 0 and bulk_size != 0 means
+				 *   1 URB and submit done by subdriver */
 	__u8 epaddr;
 };
 
@@ -70,6 +74,8 @@
 typedef int (*cam_cf_op) (struct gspca_dev *, const struct usb_device_id *);
 typedef int (*cam_jpg_op) (struct gspca_dev *,
 				struct v4l2_jpegcompression *);
+typedef int (*cam_streamparm_op) (struct gspca_dev *,
+				  struct v4l2_streamparm *);
 typedef int (*cam_qmnu_op) (struct gspca_dev *,
 			struct v4l2_querymenu *);
 typedef void (*cam_pkt_op) (struct gspca_dev *gspca_dev,
@@ -102,6 +108,8 @@
 	cam_jpg_op get_jcomp;
 	cam_jpg_op set_jcomp;
 	cam_qmnu_op querymenu;
+	cam_streamparm_op get_streamparm;
+	cam_streamparm_op set_streamparm;
 };
 
 /* packet types when moving from iso buf to frame buf */
@@ -120,10 +128,9 @@
 };
 
 struct gspca_dev {
-	struct video_device *vdev;
+	struct video_device vdev;	/* !! must be the first item */
 	struct module *module;		/* subdriver handling the device */
 	struct usb_device *dev;
-	struct kref kref;
 	struct file *capt_file;		/* file doing video capture */
 
 	struct cam cam;				/* device information */
@@ -142,22 +149,20 @@
 	char fr_q;				/* next frame to queue */
 	char fr_o;				/* next frame to dequeue */
 	signed char fr_queue[GSPCA_MAX_FRAMES];	/* frame queue */
-	char last_packet_type;
+	__u8 last_packet_type;
+	__s8 empty_packet;		/* if (-1) don't check empty packets */
+	__u8 streaming;
 
-	__u8 iface;			/* USB interface number */
-	__u8 alt;			/* USB alternate setting */
 	__u8 curr_mode;			/* current camera mode */
 	__u32 pixfmt;			/* current mode parameters */
 	__u16 width;
 	__u16 height;
+	__u32 sequence;			/* frame sequence number */
 
-	atomic_t nevent;		/* number of frames done */
 	wait_queue_head_t wq;		/* wait queue */
 	struct mutex usb_lock;		/* usb exchange protection */
 	struct mutex read_lock;		/* read protection */
 	struct mutex queue_lock;	/* ISOC queue protection */
-	__u32 sequence;			/* frame sequence number */
-	char streaming;
 #ifdef CONFIG_PM
 	char frozen;			/* suspend - resume */
 #endif
@@ -166,6 +171,8 @@
 	char nbufread;			/* number of buffers for read() */
 	char nurbs;			/* number of allocated URBs */
 	char memory;			/* memory type (V4L2_MEMORY_xxx) */
+	__u8 iface;			/* USB interface number */
+	__u8 alt;			/* USB alternate setting */
 	__u8 nbalt;			/* number of USB alternate settings */
 };
 
diff -urN linux/drivers/media/video/gspca/m5602/m5602_bridge.h linux/drivers/media/video/gspca/m5602/m5602_bridge.h
--- linux/drivers/media/video/gspca/m5602/m5602_bridge.h	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_bridge.h	2008-12-09 21:37:33.000000000 +0100
@@ -25,59 +25,59 @@
 
 /*****************************************************************************/
 
-#define M5602_XB_SENSOR_TYPE 0x00
-#define M5602_XB_SENSOR_CTRL 0x01
-#define M5602_XB_LINE_OF_FRAME_H 0x02
-#define M5602_XB_LINE_OF_FRAME_L 0x03
-#define M5602_XB_PIX_OF_LINE_H 0x04
-#define M5602_XB_PIX_OF_LINE_L 0x05
-#define M5602_XB_VSYNC_PARA 0x06
-#define M5602_XB_HSYNC_PARA 0x07
-#define M5602_XB_TEST_MODE_1 0x08
-#define M5602_XB_TEST_MODE_2 0x09
-#define M5602_XB_SIG_INI 0x0a
-#define M5602_XB_DS_PARA 0x0e
-#define M5602_XB_TRIG_PARA 0x0f
-#define M5602_XB_CLK_PD 0x10
-#define M5602_XB_MCU_CLK_CTRL 0x12
-#define M5602_XB_MCU_CLK_DIV 0x13
-#define M5602_XB_SEN_CLK_CTRL 0x14
-#define M5602_XB_SEN_CLK_DIV 0x15
-#define M5602_XB_AUD_CLK_CTRL 0x16
-#define M5602_XB_AUD_CLK_DIV 0x17
-#define M5602_XB_DEVCTR1 0x41
-#define M5602_XB_EPSETR0 0x42
-#define M5602_XB_EPAFCTR 0x47
-#define M5602_XB_EPBFCTR 0x49
-#define M5602_XB_EPEFCTR 0x4f
-#define M5602_XB_TEST_REG 0x53
-#define M5602_XB_ALT2SIZE 0x54
-#define M5602_XB_ALT3SIZE 0x55
-#define M5602_XB_OBSFRAME 0x56
-#define M5602_XB_PWR_CTL 0x59
-#define M5602_XB_ADC_CTRL 0x60
-#define M5602_XB_ADC_DATA 0x61
-#define M5602_XB_MISC_CTRL 0x62
-#define M5602_XB_SNAPSHOT 0x63
-#define M5602_XB_SCRATCH_1 0x64
-#define M5602_XB_SCRATCH_2 0x65
-#define M5602_XB_SCRATCH_3 0x66
-#define M5602_XB_SCRATCH_4 0x67
-#define M5602_XB_I2C_CTRL 0x68
-#define M5602_XB_I2C_CLK_DIV 0x69
-#define M5602_XB_I2C_DEV_ADDR 0x6a
-#define M5602_XB_I2C_REG_ADDR 0x6b
-#define M5602_XB_I2C_DATA 0x6c
-#define M5602_XB_I2C_STATUS 0x6d
-#define M5602_XB_GPIO_DAT_H 0x70
-#define M5602_XB_GPIO_DAT_L 0x71
-#define M5602_XB_GPIO_DIR_H 0x72
-#define M5602_XB_GPIO_DIR_L 0x73
-#define M5602_XB_GPIO_EN_H 0x74
-#define M5602_XB_GPIO_EN_L 0x75
-#define M5602_XB_GPIO_DAT 0x76
-#define M5602_XB_GPIO_DIR 0x77
-#define M5602_XB_MISC_CTL 0x70
+#define M5602_XB_SENSOR_TYPE		0x00
+#define M5602_XB_SENSOR_CTRL		0x01
+#define M5602_XB_LINE_OF_FRAME_H	0x02
+#define M5602_XB_LINE_OF_FRAME_L	0x03
+#define M5602_XB_PIX_OF_LINE_H		0x04
+#define M5602_XB_PIX_OF_LINE_L		0x05
+#define M5602_XB_VSYNC_PARA		0x06
+#define M5602_XB_HSYNC_PARA		0x07
+#define M5602_XB_TEST_MODE_1		0x08
+#define M5602_XB_TEST_MODE_2		0x09
+#define M5602_XB_SIG_INI		0x0a
+#define M5602_XB_DS_PARA		0x0e
+#define M5602_XB_TRIG_PARA		0x0f
+#define M5602_XB_CLK_PD			0x10
+#define M5602_XB_MCU_CLK_CTRL		0x12
+#define M5602_XB_MCU_CLK_DIV		0x13
+#define M5602_XB_SEN_CLK_CTRL		0x14
+#define M5602_XB_SEN_CLK_DIV		0x15
+#define M5602_XB_AUD_CLK_CTRL		0x16
+#define M5602_XB_AUD_CLK_DIV		0x17
+#define M5602_XB_DEVCTR1		0x41
+#define M5602_XB_EPSETR0		0x42
+#define M5602_XB_EPAFCTR		0x47
+#define M5602_XB_EPBFCTR		0x49
+#define M5602_XB_EPEFCTR		0x4f
+#define M5602_XB_TEST_REG		0x53
+#define M5602_XB_ALT2SIZE		0x54
+#define M5602_XB_ALT3SIZE		0x55
+#define M5602_XB_OBSFRAME		0x56
+#define M5602_XB_PWR_CTL		0x59
+#define M5602_XB_ADC_CTRL		0x60
+#define M5602_XB_ADC_DATA		0x61
+#define M5602_XB_MISC_CTRL		0x62
+#define M5602_XB_SNAPSHOT		0x63
+#define M5602_XB_SCRATCH_1		0x64
+#define M5602_XB_SCRATCH_2		0x65
+#define M5602_XB_SCRATCH_3		0x66
+#define M5602_XB_SCRATCH_4		0x67
+#define M5602_XB_I2C_CTRL		0x68
+#define M5602_XB_I2C_CLK_DIV		0x69
+#define M5602_XB_I2C_DEV_ADDR		0x6a
+#define M5602_XB_I2C_REG_ADDR		0x6b
+#define M5602_XB_I2C_DATA		0x6c
+#define M5602_XB_I2C_STATUS		0x6d
+#define M5602_XB_GPIO_DAT_H		0x70
+#define M5602_XB_GPIO_DAT_L		0x71
+#define M5602_XB_GPIO_DIR_H		0x72
+#define M5602_XB_GPIO_DIR_L		0x73
+#define M5602_XB_GPIO_EN_H		0x74
+#define M5602_XB_GPIO_EN_L		0x75
+#define M5602_XB_GPIO_DAT		0x76
+#define M5602_XB_GPIO_DIR		0x77
+#define M5602_XB_MISC_CTL		0x70
 
 #define I2C_BUSY 0x80
 
@@ -90,13 +90,7 @@
 #define M5602_ISOC_ENDPOINT_ADDR 0x81
 #define M5602_INTR_ENDPOINT_ADDR 0x82
 
-#define M5602_MAX_FRAMES	32
-#define M5602_URBS		2
-#define M5602_ISOC_PACKETS	14
-
-#define M5602_URB_TIMEOUT	msecs_to_jiffies(2 * M5602_ISOC_PACKETS)
 #define M5602_URB_MSG_TIMEOUT   5000
-#define M5602_FRAME_TIMEOUT	2
 
 /*****************************************************************************/
 
diff -urN linux/drivers/media/video/gspca/m5602/m5602_core.c linux/drivers/media/video/gspca/m5602/m5602_core.c
--- linux/drivers/media/video/gspca/m5602/m5602_core.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_core.c	2008-12-25 15:33:23.000000000 +0100
@@ -24,7 +24,7 @@
 
 /* Kernel module parameters */
 int force_sensor;
-int dump_bridge;
+static int dump_bridge;
 int dump_sensor;
 
 static const __devinitdata struct usb_device_id m5602_table[] = {
diff -urN linux/drivers/media/video/gspca/m5602/m5602_ov9650.c linux/drivers/media/video/gspca/m5602/m5602_ov9650.c
--- linux/drivers/media/video/gspca/m5602/m5602_ov9650.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_ov9650.c	2008-12-09 21:37:33.000000000 +0100
@@ -18,6 +18,41 @@
 
 #include "m5602_ov9650.h"
 
+/* Vertically and horizontally flips the image if matched, needed for machines
+   where the sensor is mounted upside down */
+static
+	struct dmi_system_id ov9650_flip_dmi_table[] = {
+	{
+		.ident = "ASUS A6VC",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "A6VC")
+		}
+	},
+	{
+		.ident = "ASUS A6VM",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "A6VM")
+		}
+	},
+	{
+		.ident = "ASUS A6JC",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "A6JC")
+		}
+	},
+	{
+		.ident = "ASUS A6Kt",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "A6Kt")
+		}
+	},
+	{ }
+};
+
 int ov9650_read_sensor(struct sd *sd, const u8 address,
 		      u8 *i2c_data, const u8 len)
 {
diff -urN linux/drivers/media/video/gspca/m5602/m5602_ov9650.h linux/drivers/media/video/gspca/m5602/m5602_ov9650.h
--- linux/drivers/media/video/gspca/m5602/m5602_ov9650.h	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_ov9650.h	2008-12-09 21:37:33.000000000 +0100
@@ -432,6 +432,7 @@
 	{BRIDGE, M5602_XB_PIX_OF_LINE_L, 0x00},
 	{BRIDGE, M5602_XB_SIG_INI, 0x01},
 	{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},
+	/* Moves the view window in a vertical orientation */
 	{BRIDGE, M5602_XB_VSYNC_PARA, 0x09},
 	{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},
 	{BRIDGE, M5602_XB_VSYNC_PARA, 0x01},
@@ -463,40 +464,4 @@
 	{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0}
 };
 
-/* Vertically and horizontally flips the image if matched, needed for machines
-   where the sensor is mounted upside down */
-static
-    const
-	struct dmi_system_id ov9650_flip_dmi_table[] = {
-	{
-		.ident = "ASUS A6VC",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "A6VC")
-		}
-	},
-	{
-		.ident = "ASUS A6VM",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "A6VM")
-		}
-	},
-	{
-		.ident = "ASUS A6JC",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "A6JC")
-		}
-	},
-	{
-		.ident = "ASUS A6Kt",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "A6Kt")
-		}
-	},
-	{ }
-};
-
 #endif
diff -urN linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.c linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.c
--- linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.c	2008-12-09 21:37:33.000000000 +0100
@@ -18,6 +18,38 @@
 
 #include "m5602_s5k4aa.h"
 
+static
+	struct dmi_system_id s5k4aa_vflip_dmi_table[] = {
+	{
+		.ident = "Fujitsu-Siemens Amilo Xa 2528",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO Xa 2528")
+		}
+	}, {
+		.ident = "Fujitsu-Siemens Amilo Xi 2550",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO Xi 2550")
+		}
+	}, {
+		.ident = "MSI GX700",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "GX700"),
+			DMI_MATCH(DMI_BIOS_DATE, "07/26/2007")
+		}
+	}, {
+		.ident = "MSI GX700/GX705/EX700",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "GX700/GX705/EX700")
+		}
+	},
+	{ }
+};
+
+
 int s5k4aa_probe(struct sd *sd)
 {
 	u8 prod_id[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -urN linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.h linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.h
--- linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.h	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/m5602/m5602_s5k4aa.h	2008-12-09 21:37:33.000000000 +0100
@@ -338,32 +338,4 @@
 	{SENSOR, S5K4AA_GAIN_2, 0xa0, 0x00}
 };
 
-static
-    const
-	struct dmi_system_id s5k4aa_vflip_dmi_table[] = {
-	{
-		.ident = "Fujitsu-Siemens Amilo Xa 2528",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO Xa 2528")
-		}
-	},
-	{
-		.ident = "Fujitsu-Siemens Amilo Xi 2550",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO Xi 2550")
-		}
-	},
-		{
-		.ident = "MSI GX700",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "GX700"),
-			DMI_MATCH(DMI_BIOS_DATE, "07/26/2007")
-		}
-	},
-	{ }
-};
-
 #endif
diff -urN linux/drivers/media/video/gspca/mars.c linux/drivers/media/video/gspca/mars.c
--- linux/drivers/media/video/gspca/mars.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/mars.c	2008-12-09 21:37:33.000000000 +0100
@@ -123,7 +123,7 @@
 	cam = &gspca_dev->cam;
 	cam->epaddr = 0x01;
 	cam->cam_mode = vga_mode;
-	cam->nmodes = sizeof vga_mode / sizeof vga_mode[0];
+	cam->nmodes = ARRAY_SIZE(vga_mode);
 	sd->qindex = 1;			/* set the quantization table */
 	return 0;
 }
diff -urN linux/drivers/media/video/gspca/ov519.c linux/drivers/media/video/gspca/ov519.c
--- linux/drivers/media/video/gspca/ov519.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/ov519.c	2008-12-09 21:37:33.000000000 +0100
@@ -3,7 +3,18 @@
  *
  * Copyright (C) 2008 Jean-Francois Moine (http://moinejf.free.fr)
  *
- * (This module is adapted from the ov51x-jpeg package)
+ * This module is adapted from the ov51x-jpeg package, which itself
+ * was adapted from the ov511 driver.
+ *
+ * Original copyright for the ov511 driver is:
+ *
+ * Copyright (c) 1999-2004 Mark W. McClelland
+ * Support for OV519, OV8610 Copyright (c) 2003 Joerg Heckenbach
+ *
+ * ov51x-jpeg original copyright is:
+ *
+ * Copyright (c) 2004-2007 Romain Beauxis <toots@rastageeks.org>
+ * Support for OV7670 sensors was contributed by Sam Skipsey <aoanla@yahoo.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -40,22 +51,18 @@
 	struct gspca_dev gspca_dev;		/* !! must be the first item */
 
 	/* Determined by sensor type */
-	char sif;
-
-	unsigned char primary_i2c_slave;	/* I2C write id of sensor */
+	__u8 sif;
 
-	unsigned char brightness;
-	unsigned char contrast;
-	unsigned char colors;
+	__u8 brightness;
+	__u8 contrast;
+	__u8 colors;
 	__u8 hflip;
 	__u8 vflip;
 
-	char compress;		/* Should the next frame be compressed? */
-	char compress_inited;	/* Are compression params uploaded? */
-	char stopped;		/* Streaming is temporarily paused */
+	__u8 stopped;		/* Streaming is temporarily paused */
 
-	char frame_rate;	/* current Framerate (OV519 only) */
-	char clockdiv;		/* clockdiv override for OV519 only */
+	__u8 frame_rate;	/* current Framerate (OV519 only) */
+	__u8 clockdiv;		/* clockdiv override for OV519 only */
 
 	char sensor;		/* Type of image sensor chip (SEN_*) */
 #define SEN_UNKNOWN 0
@@ -67,7 +74,6 @@
 #define SEN_OV7670 6
 #define SEN_OV76BE 7
 #define SEN_OV8610 8
-
 };
 
 /* V4L2 controls supported by the driver */
@@ -184,15 +190,15 @@
 };
 
 /* OV519 Camera interface register numbers */
-#define OV519_CAM_H_SIZE		0x10
-#define OV519_CAM_V_SIZE		0x11
-#define OV519_CAM_X_OFFSETL		0x12
-#define OV519_CAM_X_OFFSETH		0x13
-#define OV519_CAM_Y_OFFSETL		0x14
-#define OV519_CAM_Y_OFFSETH		0x15
-#define OV519_CAM_DIVIDER		0x16
-#define OV519_CAM_DFR			0x20
-#define OV519_CAM_FORMAT		0x25
+#define OV519_R10_H_SIZE		0x10
+#define OV519_R11_V_SIZE		0x11
+#define OV519_R12_X_OFFSETL		0x12
+#define OV519_R13_X_OFFSETH		0x13
+#define OV519_R14_Y_OFFSETL		0x14
+#define OV519_R15_Y_OFFSETH		0x15
+#define OV519_R16_DIVIDER		0x16
+#define OV519_R20_DFR			0x20
+#define OV519_R25_FORMAT		0x25
 
 /* OV519 System Controller register numbers */
 #define OV519_SYS_RESET1 0x51
@@ -562,8 +568,8 @@
 	{ OV7670_REG_VSTOP, 0x7a },
 	{ OV7670_REG_VREF, 0x0a },
 
-	{ OV7670_REG_COM3, 0 },
-	{ OV7670_REG_COM14, 0 },
+	{ OV7670_REG_COM3, 0x00 },
+	{ OV7670_REG_COM14, 0x00 },
 /* Mystery scaling numbers */
 	{ 0x70, 0x3a },
 	{ 0x71, 0x35 },
@@ -595,8 +601,8 @@
 	{ OV7670_REG_COM8, OV7670_COM8_FASTAEC
 			 | OV7670_COM8_AECSTEP
 			 | OV7670_COM8_BFILT },
-	{ OV7670_REG_GAIN, 0 },
-	{ OV7670_REG_AECH, 0 },
+	{ OV7670_REG_GAIN, 0x00 },
+	{ OV7670_REG_AECH, 0x00 },
 	{ OV7670_REG_COM4, 0x40 }, /* magic reserved bit */
 	{ OV7670_REG_COM9, 0x18 }, /* 4x gain + magic rsvd bit */
 	{ OV7670_REG_BD50MAX, 0x05 },
@@ -634,16 +640,16 @@
 	{ OV7670_REG_COM12, 0x78 },
 	{ 0x4d, 0x40 },
 	{ 0x4e, 0x20 },
-	{ OV7670_REG_GFIX, 0 },
+	{ OV7670_REG_GFIX, 0x00 },
 	{ 0x6b, 0x4a },
 	{ 0x74, 0x10 },
 	{ 0x8d, 0x4f },
-	{ 0x8e, 0 },
-	{ 0x8f, 0 },
-	{ 0x90, 0 },
-	{ 0x91, 0 },
-	{ 0x96, 0 },
-	{ 0x9a, 0 },
+	{ 0x8e, 0x00 },
+	{ 0x8f, 0x00 },
+	{ 0x90, 0x00 },
+	{ 0x91, 0x00 },
+	{ 0x96, 0x00 },
+	{ 0x9a, 0x00 },
 	{ 0xb0, 0x84 },
 	{ 0xb1, 0x0c },
 	{ 0xb2, 0x0e },
@@ -681,17 +687,17 @@
 /* Matrix coefficients */
 	{ 0x4f, 0x80 },
 	{ 0x50, 0x80 },
-	{ 0x51, 0 },
+	{ 0x51, 0x00 },
 	{ 0x52, 0x22 },
 	{ 0x53, 0x5e },
 	{ 0x54, 0x80 },
 	{ 0x58, 0x9e },
 
 	{ OV7670_REG_COM16, OV7670_COM16_AWBGAIN },
-	{ OV7670_REG_EDGE, 0 },
+	{ OV7670_REG_EDGE, 0x00 },
 	{ 0x75, 0x05 },
 	{ 0x76, 0xe1 },
-	{ 0x4c, 0 },
+	{ 0x4c, 0x00 },
 	{ 0x77, 0x01 },
 	{ OV7670_REG_COM13, OV7670_COM13_GAMMA
 			  | OV7670_COM13_UVSAT
@@ -704,7 +710,7 @@
 	{ 0x34, 0x11 },
 	{ OV7670_REG_COM11, OV7670_COM11_EXP|OV7670_COM11_HZAUTO },
 	{ 0xa4, 0x88 },
-	{ 0x96, 0 },
+	{ 0x96, 0x00 },
 	{ 0x97, 0x30 },
 	{ 0x98, 0x20 },
 	{ 0x99, 0x30 },
@@ -942,11 +948,11 @@
 
 	/* Initiate 3-byte write cycle */
 	rc = reg_w(sd, R518_I2C_CTL, 0x01);
+	if (rc < 0)
+		return rc;
 
 	/* wait for write complete */
 	msleep(4);
-	if (rc < 0)
-		return rc;
 	return reg_r8(sd, R518_I2C_CTL);
 }
 
@@ -1029,7 +1035,7 @@
  */
 static int init_ov_sensor(struct sd *sd)
 {
-	int i, success;
+	int i;
 
 	/* Reset the sensor */
 	if (i2c_w(sd, 0x12, 0x80) < 0)
@@ -1038,11 +1044,11 @@
 	/* Wait for it to initialize */
 	msleep(150);
 
-	for (i = 0, success = 0; i < i2c_detect_tries && !success; i++) {
+	for (i = 0; i < i2c_detect_tries; i++) {
 		if (i2c_r(sd, OV7610_REG_ID_HIGH) == 0x7f &&
 		    i2c_r(sd, OV7610_REG_ID_LOW) == 0xa2) {
-			success = 1;
-			continue;
+			PDEBUG(D_PROBE, "I2C synced in %d attempt(s)", i);
+			return 0;
 		}
 
 		/* Reset the sensor */
@@ -1054,10 +1060,7 @@
 		if (i2c_r(sd, 0x00) < 0)
 			return -EIO;
 	}
-	if (!success)
-		return -EIO;
-	PDEBUG(D_PROBE, "I2C synced in %d attempt(s)", i);
-	return 0;
+	return -EIO;
 }
 
 /* Set the read and write slave IDs. The "slave" argument is the write slave,
@@ -1073,7 +1076,6 @@
 	rc = reg_w(sd, R51x_I2C_W_SID, slave);
 	if (rc < 0)
 		return rc;
-	sd->primary_i2c_slave = slave;
 	return reg_w(sd, R51x_I2C_R_SID, slave + 1);
 }
 
@@ -1285,7 +1287,6 @@
 /* Turns on or off the LED. Only has an effect with OV511+/OV518(+)/OV519 */
 static void ov51x_led_control(struct sd *sd, int on)
 {
-/*	PDEBUG(D_STREAM, "LED (%s)", on ? "on" : "off"); */
 	reg_w_mask(sd, OV519_GPIO_DATA_OUT0, !on, 1);	/* 0 / 1 */
 }
 
@@ -1352,7 +1353,7 @@
 			}
 			if (ov8xx0_configure(sd) < 0) {
 				PDEBUG(D_ERR,
-				   "Failed to configure OV8xx0 sensor");
+					"Failed to configure OV8xx0 sensor");
 				goto error;
 			}
 		}
@@ -1482,7 +1483,7 @@
 			return -EIO;
 		if (sd->sensor == SEN_OV7640) {
 			/* Select 8-bit input mode */
-			reg_w_mask(sd, OV519_CAM_DFR, 0x10, 0x10);
+			reg_w_mask(sd, OV519_R20_DFR, 0x10, 0x10);
 		}
 	} else {
 		if (write_regvals(sd, mode_init_519_ov7670,
@@ -1490,14 +1491,14 @@
 			return -EIO;
 	}
 
-	reg_w(sd, OV519_CAM_H_SIZE,	sd->gspca_dev.width >> 4);
-	reg_w(sd, OV519_CAM_V_SIZE,	sd->gspca_dev.height >> 3);
-	reg_w(sd, OV519_CAM_X_OFFSETL,	0x00);
-	reg_w(sd, OV519_CAM_X_OFFSETH,	0x00);
-	reg_w(sd, OV519_CAM_Y_OFFSETL,	0x00);
-	reg_w(sd, OV519_CAM_Y_OFFSETH,	0x00);
-	reg_w(sd, OV519_CAM_DIVIDER,	0x00);
-	reg_w(sd, OV519_CAM_FORMAT,	0x03); /* YUV422 */
+	reg_w(sd, OV519_R10_H_SIZE,	sd->gspca_dev.width >> 4);
+	reg_w(sd, OV519_R11_V_SIZE,	sd->gspca_dev.height >> 3);
+	reg_w(sd, OV519_R12_X_OFFSETL,	0x00);
+	reg_w(sd, OV519_R13_X_OFFSETH,	0x00);
+	reg_w(sd, OV519_R14_Y_OFFSETL,	0x00);
+	reg_w(sd, OV519_R15_Y_OFFSETH,	0x00);
+	reg_w(sd, OV519_R16_DIVIDER,	0x00);
+	reg_w(sd, OV519_R25_FORMAT,	0x03); /* YUV422 */
 	reg_w(sd, 0x26,			0x00); /* Undocumented */
 
 	/******** Set the framerate ********/
@@ -1509,8 +1510,8 @@
 	switch (sd->sensor) {
 	case SEN_OV7640:
 		switch (sd->frame_rate) {
-/*fixme: default was 30 fps */
-		case 30:
+		default:
+/*		case 30: */
 			reg_w(sd, 0xa4, 0x0c);
 			reg_w(sd, 0x23, 0xff);
 			break;
@@ -1522,8 +1523,7 @@
 			reg_w(sd, 0xa4, 0x0c);
 			reg_w(sd, 0x23, 0x1b);
 			break;
-		default:
-/*		case 15: */
+		case 15:
 			reg_w(sd, 0xa4, 0x04);
 			reg_w(sd, 0x23, 0xff);
 			sd->clockdiv = 1;
@@ -1576,7 +1576,6 @@
 		}
 		break;
 	}
-
 	return 0;
 }
 
@@ -1667,7 +1691,7 @@
 		 * the gain or the contrast. The "reserved" bits seem
 		 * to have some effect in this case. */
 		i2c_w(sd, 0x2d, 0x85);
-	} else if (sd->clockdiv >= 0) {
+	} else {
 		i2c_w(sd, 0x11, sd->clockdiv);
 	}
 
@@ -1869,7 +1893,6 @@
 	ret = ov51x_restart(sd);
 	if (ret < 0)
 		goto out;
-	PDEBUG(D_STREAM, "camera started alt: 0x%02x", gspca_dev->alt);
 	ov51x_led_control(sd, 1);
 	return 0;
 out:
@@ -1879,8 +1902,10 @@
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
-	ov51x_stop((struct sd *) gspca_dev);
-	ov51x_led_control((struct sd *) gspca_dev, 0);
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	ov51x_stop(sd);
+	ov51x_led_control(sd, 0);
 }
 
 static void sd_pkt_scan(struct gspca_dev *gspca_dev,
@@ -1935,9 +1960,6 @@
 	int val;
 
 	val = sd->brightness;
-	PDEBUG(D_CONF, "brightness:%d", val);
-/*	if (gspca_dev->streaming)
- *		ov51x_stop(sd); */
 	switch (sd->sensor) {
 	case SEN_OV8610:
 	case SEN_OV7610:
@@ -1959,8 +1981,6 @@
 		i2c_w(sd, OV7670_REG_BRIGHT, ov7670_abs_to_sm(val));
 		break;
 	}
-/*	if (gspca_dev->streaming)
- *		ov51x_restart(sd); */
 }
 
 static void setcontrast(struct gspca_dev *gspca_dev)
@@ -1969,9 +1989,6 @@
 	int val;
 
 	val = sd->contrast;
-	PDEBUG(D_CONF, "contrast:%d", val);
-/*	if (gspca_dev->streaming)
-		ov51x_stop(sd); */
 	switch (sd->sensor) {
 	case SEN_OV7610:
 	case SEN_OV6620:
@@ -2007,8 +2024,6 @@
 		i2c_w(sd, OV7670_REG_CONTRAS, val >> 1);
 		break;
 	}
-/*	if (gspca_dev->streaming)
-		ov51x_restart(sd); */
 }
 
 static void setcolors(struct gspca_dev *gspca_dev)
@@ -2017,9 +2032,6 @@
 	int val;
 
 	val = sd->colors;
-	PDEBUG(D_CONF, "saturation:%d", val);
-/*	if (gspca_dev->streaming)
-		ov51x_stop(sd); */
 	switch (sd->sensor) {
 	case SEN_OV8610:
 	case SEN_OV7610:
@@ -2044,8 +2056,6 @@
 		/* set REG_COM13 values for UV sat auto mode */
 		break;
 	}
-/*	if (gspca_dev->streaming)
-		ov51x_restart(sd); */
 }
 
 static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)
@@ -2053,7 +2063,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->brightness = val;
-	setbrightness(gspca_dev);
+	if (gspca_dev->streaming)
+		setbrightness(gspca_dev);
 	return 0;
 }
 
@@ -2070,7 +2081,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->contrast = val;
-	setcontrast(gspca_dev);
+	if (gspca_dev->streaming)
+		setcontrast(gspca_dev);
 	return 0;
 }
 
@@ -2087,7 +2099,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->colors = val;
-	setcolors(gspca_dev);
+	if (gspca_dev->streaming)
+		setcolors(gspca_dev);
 	return 0;
 }
 
@@ -2104,7 +2117,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->hflip = val;
-	sethvflip(sd);
+	if (gspca_dev->streaming)
+		sethvflip(sd);
 	return 0;
 }
 
@@ -2121,7 +2135,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->vflip = val;
-	sethvflip(sd);
+	if (gspca_dev->streaming)
+		sethvflip(sd);
 	return 0;
 }
 
@@ -2162,7 +2177,7 @@
 	{USB_DEVICE(0x05a9, 0x8519)},
 	{}
 };
-#undef DVNAME
+
 MODULE_DEVICE_TABLE(usb, device_table);
 
 /* -- device connect -- */
diff -urN linux/drivers/media/video/gspca/ov534.c linux/drivers/media/video/gspca/ov534.c
--- linux/drivers/media/video/gspca/ov534.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/drivers/media/video/gspca/ov534.c	2008-12-25 15:33:23.000000000 +0100
@@ -0,0 +1,599 @@
+/*
+ * ov534/ov772x gspca driver
+ * Copyright (C) 2008 Antonio Ospite <ospite@studenti.unina.it>
+ * Copyright (C) 2008 Jim Paris <jim@jtan.com>
+ *
+ * Based on a prototype written by Mark Ferrell <majortrips@gmail.com>
+ * USB protocol reverse engineered by Jim Paris <jim@jtan.com>
+ * https://jim.sh/svn/jim/devl/playstation/ps3/eye/test/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#define MODULE_NAME "ov534"
+
+#include "gspca.h"
+
+#define OV534_REG_ADDRESS	0xf1	/* ? */
+#define OV534_REG_SUBADDR	0xf2
+#define OV534_REG_WRITE		0xf3
+#define OV534_REG_READ		0xf4
+#define OV534_REG_OPERATION	0xf5
+#define OV534_REG_STATUS	0xf6
+
+#define OV534_OP_WRITE_3	0x37
+#define OV534_OP_WRITE_2	0x33
+#define OV534_OP_READ_2		0xf9
+
+#define CTRL_TIMEOUT 500
+
+MODULE_AUTHOR("Antonio Ospite <ospite@studenti.unina.it>");
+MODULE_DESCRIPTION("GSPCA/OV534 USB Camera Driver");
+MODULE_LICENSE("GPL");
+
+/* specific webcam descriptor */
+struct sd {
+	struct gspca_dev gspca_dev;	/* !! must be the first item */
+	__u32 last_fid;
+	__u32 last_pts;
+	int frame_rate;
+};
+
+/* V4L2 controls supported by the driver */
+static struct ctrl sd_ctrls[] = {
+};
+
+static struct v4l2_pix_format vga_mode[] = {
+	{640, 480, V4L2_PIX_FMT_YUYV, V4L2_FIELD_NONE,
+	 .bytesperline = 640 * 2,
+	 .sizeimage = 640 * 480 * 2,
+	 .colorspace = V4L2_COLORSPACE_JPEG,
+	 .priv = 0},
+};
+
+static void ov534_reg_write(struct usb_device *udev, u16 reg, u8 val)
+{
+	u8 data = val;
+	int ret;
+
+	PDEBUG(D_USBO, "reg=0x%04x, val=0%02x", reg, val);
+	ret = usb_control_msg(udev,
+			      usb_sndctrlpipe(udev, 0),
+			      0x1,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x0, reg, &data, 1, CTRL_TIMEOUT);
+	if (ret < 0)
+		PDEBUG(D_ERR, "write failed");
+}
+
+static u8 ov534_reg_read(struct usb_device *udev, u16 reg)
+{
+	u8 data;
+	int ret;
+
+	ret = usb_control_msg(udev,
+			      usb_rcvctrlpipe(udev, 0),
+			      0x1,
+			      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x0, reg, &data, 1, CTRL_TIMEOUT);
+	PDEBUG(D_USBI, "reg=0x%04x, data=0x%02x", reg, data);
+	if (ret < 0)
+		PDEBUG(D_ERR, "read failed");
+	return data;
+}
+
+/* Two bits control LED: 0x21 bit 7 and 0x23 bit 7.
+ * (direction and output)? */
+static void ov534_set_led(struct usb_device *udev, int status)
+{
+	u8 data;
+
+	PDEBUG(D_CONF, "led status: %d", status);
+
+	data = ov534_reg_read(udev, 0x21);
+	data |= 0x80;
+	ov534_reg_write(udev, 0x21, data);
+
+	data = ov534_reg_read(udev, 0x23);
+	if (status)
+		data |= 0x80;
+	else
+		data &= ~(0x80);
+
+	ov534_reg_write(udev, 0x23, data);
+}
+
+static int sccb_check_status(struct usb_device *udev)
+{
+	u8 data;
+	int i;
+
+	for (i = 0; i < 5; i++) {
+		data = ov534_reg_read(udev, OV534_REG_STATUS);
+
+		switch (data) {
+		case 0x00:
+			return 1;
+		case 0x04:
+			return 0;
+		case 0x03:
+			break;
+		default:
+			PDEBUG(D_ERR, "sccb status 0x%02x, attempt %d/5\n",
+			       data, i + 1);
+		}
+	}
+	return 0;
+}
+
+static void sccb_reg_write(struct usb_device *udev, u16 reg, u8 val)
+{
+	PDEBUG(D_USBO, "reg: 0x%04x, val: 0x%02x", reg, val);
+	ov534_reg_write(udev, OV534_REG_SUBADDR, reg);
+	ov534_reg_write(udev, OV534_REG_WRITE, val);
+	ov534_reg_write(udev, OV534_REG_OPERATION, OV534_OP_WRITE_3);
+
+	if (!sccb_check_status(udev))
+		PDEBUG(D_ERR, "sccb_reg_write failed");
+}
+
+#ifdef GSPCA_DEBUG
+static u8 sccb_reg_read(struct usb_device *udev, u16 reg)
+{
+	ov534_reg_write(udev, OV534_REG_SUBADDR, reg);
+	ov534_reg_write(udev, OV534_REG_OPERATION, OV534_OP_WRITE_2);
+	if (!sccb_check_status(udev))
+		PDEBUG(D_ERR, "sccb_reg_read failed 1");
+
+	ov534_reg_write(udev, OV534_REG_OPERATION, OV534_OP_READ_2);
+	if (!sccb_check_status(udev))
+		PDEBUG(D_ERR, "sccb_reg_read failed 2");
+
+	return ov534_reg_read(udev, OV534_REG_READ);
+}
+#endif
+
+static const __u8 ov534_reg_initdata[][2] = {
+	{ 0xe7, 0x3a },
+
+	{ OV534_REG_ADDRESS, 0x42 }, /* select OV772x sensor */
+
+	{ 0xc2, 0x0c },
+	{ 0x88, 0xf8 },
+	{ 0xc3, 0x69 },
+	{ 0x89, 0xff },
+	{ 0x76, 0x03 },
+	{ 0x92, 0x01 },
+	{ 0x93, 0x18 },
+	{ 0x94, 0x10 },
+	{ 0x95, 0x10 },
+	{ 0xe2, 0x00 },
+	{ 0xe7, 0x3e },
+
+	{ 0x96, 0x00 },
+
+	{ 0x97, 0x20 },
+	{ 0x97, 0x20 },
+	{ 0x97, 0x20 },
+	{ 0x97, 0x0a },
+	{ 0x97, 0x3f },
+	{ 0x97, 0x4a },
+	{ 0x97, 0x20 },
+	{ 0x97, 0x15 },
+	{ 0x97, 0x0b },
+
+	{ 0x8e, 0x40 },
+	{ 0x1f, 0x81 },
+	{ 0x34, 0x05 },
+	{ 0xe3, 0x04 },
+	{ 0x88, 0x00 },
+	{ 0x89, 0x00 },
+	{ 0x76, 0x00 },
+	{ 0xe7, 0x2e },
+	{ 0x31, 0xf9 },
+	{ 0x25, 0x42 },
+	{ 0x21, 0xf0 },
+
+	{ 0x1c, 0x00 },
+	{ 0x1d, 0x40 },
+	{ 0x1d, 0x02 }, /* payload size 0x0200 * 4 = 2048 bytes */
+	{ 0x1d, 0x00 }, /* payload size */
+	{ 0x1d, 0x02 }, /* frame size 0x025800 * 4 = 614400 */
+	{ 0x1d, 0x58 }, /* frame size */
+	{ 0x1d, 0x00 }, /* frame size */
+
+	{ 0x1c, 0x0a },
+	{ 0x1d, 0x08 }, /* turn on UVC header */
+	{ 0x1d, 0x0e }, /* .. */
+
+	{ 0x8d, 0x1c },
+	{ 0x8e, 0x80 },
+	{ 0xe5, 0x04 },
+
+	{ 0xc0, 0x50 },
+	{ 0xc1, 0x3c },
+	{ 0xc2, 0x0c },
+};
+
+static const __u8 ov772x_reg_initdata[][2] = {
+	{ 0x12, 0x80 },
+	{ 0x11, 0x01 },
+
+	{ 0x3d, 0x03 },
+	{ 0x17, 0x26 },
+	{ 0x18, 0xa0 },
+	{ 0x19, 0x07 },
+	{ 0x1a, 0xf0 },
+	{ 0x32, 0x00 },
+	{ 0x29, 0xa0 },
+	{ 0x2c, 0xf0 },
+	{ 0x65, 0x20 },
+	{ 0x11, 0x01 },
+	{ 0x42, 0x7f },
+	{ 0x63, 0xe0 },
+	{ 0x64, 0xff },
+	{ 0x66, 0x00 },
+	{ 0x13, 0xf0 },
+	{ 0x0d, 0x41 },
+	{ 0x0f, 0xc5 },
+	{ 0x14, 0x11 },
+
+	{ 0x22, 0x7f },
+	{ 0x23, 0x03 },
+	{ 0x24, 0x40 },
+	{ 0x25, 0x30 },
+	{ 0x26, 0xa1 },
+	{ 0x2a, 0x00 },
+	{ 0x2b, 0x00 },
+	{ 0x6b, 0xaa },
+	{ 0x13, 0xff },
+
+	{ 0x90, 0x05 },
+	{ 0x91, 0x01 },
+	{ 0x92, 0x03 },
+	{ 0x93, 0x00 },
+	{ 0x94, 0x60 },
+	{ 0x95, 0x3c },
+	{ 0x96, 0x24 },
+	{ 0x97, 0x1e },
+	{ 0x98, 0x62 },
+	{ 0x99, 0x80 },
+	{ 0x9a, 0x1e },
+	{ 0x9b, 0x08 },
+	{ 0x9c, 0x20 },
+	{ 0x9e, 0x81 },
+
+	{ 0xa6, 0x04 },
+	{ 0x7e, 0x0c },
+	{ 0x7f, 0x16 },
+	{ 0x80, 0x2a },
+	{ 0x81, 0x4e },
+	{ 0x82, 0x61 },
+	{ 0x83, 0x6f },
+	{ 0x84, 0x7b },
+	{ 0x85, 0x86 },
+	{ 0x86, 0x8e },
+	{ 0x87, 0x97 },
+	{ 0x88, 0xa4 },
+	{ 0x89, 0xaf },
+	{ 0x8a, 0xc5 },
+	{ 0x8b, 0xd7 },
+	{ 0x8c, 0xe8 },
+	{ 0x8d, 0x20 },
+
+	{ 0x0c, 0x90 },
+
+	{ 0x2b, 0x00 },
+	{ 0x22, 0x7f },
+	{ 0x23, 0x03 },
+	{ 0x11, 0x01 },
+	{ 0x0c, 0xd0 },
+	{ 0x64, 0xff },
+	{ 0x0d, 0x41 },
+
+	{ 0x14, 0x41 },
+	{ 0x0e, 0xcd },
+	{ 0xac, 0xbf },
+	{ 0x8e, 0x00 },
+	{ 0x0c, 0xd0 }
+};
+
+/* set framerate */
+static void ov534_set_frame_rate(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	int fr = sd->frame_rate;
+
+	switch (fr) {
+	case 50:
+		sccb_reg_write(gspca_dev->dev, 0x11, 0x01);
+		sccb_reg_write(gspca_dev->dev, 0x0d, 0x41);
+		ov534_reg_write(gspca_dev->dev, 0xe5, 0x02);
+		break;
+	case 40:
+		sccb_reg_write(gspca_dev->dev, 0x11, 0x02);
+		sccb_reg_write(gspca_dev->dev, 0x0d, 0xc1);
+		ov534_reg_write(gspca_dev->dev, 0xe5, 0x04);
+		break;
+/*	case 30: */
+	default:
+		fr = 30;
+		sccb_reg_write(gspca_dev->dev, 0x11, 0x04);
+		sccb_reg_write(gspca_dev->dev, 0x0d, 0x81);
+		ov534_reg_write(gspca_dev->dev, 0xe5, 0x02);
+		break;
+	case 15:
+		sccb_reg_write(gspca_dev->dev, 0x11, 0x03);
+		sccb_reg_write(gspca_dev->dev, 0x0d, 0x41);
+		ov534_reg_write(gspca_dev->dev, 0xe5, 0x04);
+		break;
+	}
+
+	sd->frame_rate = fr;
+	PDEBUG(D_PROBE, "frame_rate: %d", fr);
+}
+
+/* setup method */
+static void ov534_setup(struct usb_device *udev)
+{
+	int i;
+
+	/* Initialize bridge chip */
+	for (i = 0; i < ARRAY_SIZE(ov534_reg_initdata); i++)
+		ov534_reg_write(udev, ov534_reg_initdata[i][0],
+				ov534_reg_initdata[i][1]);
+
+	PDEBUG(D_PROBE, "sensor is ov%02x%02x",
+		sccb_reg_read(udev, 0x0a), sccb_reg_read(udev, 0x0b));
+
+	ov534_set_led(udev, 1);
+
+	/* Initialize sensor */
+	for (i = 0; i < ARRAY_SIZE(ov772x_reg_initdata); i++)
+		sccb_reg_write(udev, ov772x_reg_initdata[i][0],
+			       ov772x_reg_initdata[i][1]);
+
+	ov534_reg_write(udev, 0xe0, 0x09);
+	ov534_set_led(udev, 0);
+}
+
+/* this function is called at probe time */
+static int sd_config(struct gspca_dev *gspca_dev,
+		     const struct usb_device_id *id)
+{
+	struct cam *cam;
+
+	cam = &gspca_dev->cam;
+
+	cam->epaddr = 0x01;
+	cam->cam_mode = vga_mode;
+	cam->nmodes = ARRAY_SIZE(vga_mode);
+
+	cam->bulk_size = 16384;
+	cam->bulk_nurbs = 2;
+
+	return 0;
+}
+
+/* this function is called at probe and resume time */
+static int sd_init(struct gspca_dev *gspca_dev)
+{
+	ov534_setup(gspca_dev->dev);
+	ov534_set_frame_rate(gspca_dev);
+
+	return 0;
+}
+
+static int sd_start(struct gspca_dev *gspca_dev)
+{
+	/* start streaming data */
+	ov534_set_led(gspca_dev->dev, 1);
+	ov534_reg_write(gspca_dev->dev, 0xe0, 0x00);
+
+	return 0;
+}
+
+static void sd_stopN(struct gspca_dev *gspca_dev)
+{
+	/* stop streaming data */
+	ov534_reg_write(gspca_dev->dev, 0xe0, 0x09);
+	ov534_set_led(gspca_dev->dev, 0);
+}
+
+/* Values for bmHeaderInfo (Video and Still Image Payload Headers, 2.4.3.3) */
+#define UVC_STREAM_EOH	(1 << 7)
+#define UVC_STREAM_ERR	(1 << 6)
+#define UVC_STREAM_STI	(1 << 5)
+#define UVC_STREAM_RES	(1 << 4)
+#define UVC_STREAM_SCR	(1 << 3)
+#define UVC_STREAM_PTS	(1 << 2)
+#define UVC_STREAM_EOF	(1 << 1)
+#define UVC_STREAM_FID	(1 << 0)
+
+static void sd_pkt_scan(struct gspca_dev *gspca_dev, struct gspca_frame *frame,
+			__u8 *data, int len)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	__u32 this_pts;
+	int this_fid;
+	int remaining_len = len;
+	__u8 *next_data = data;
+
+scan_next:
+	if (remaining_len <= 0)
+		return;
+
+	data = next_data;
+	len = min(remaining_len, 2048);
+	remaining_len -= len;
+	next_data += len;
+
+	/* Payloads are prefixed with a UVC-style header.  We
+	   consider a frame to start when the FID toggles, or the PTS
+	   changes.  A frame ends when EOF is set, and we've received
+	   the correct number of bytes. */
+
+	/* Verify UVC header.  Header length is always 12 */
+	if (data[0] != 12 || len < 12) {
+		PDEBUG(D_PACK, "bad header");
+		goto discard;
+	}
+
+	/* Check errors */
+	if (data[1] & UVC_STREAM_ERR) {
+		PDEBUG(D_PACK, "payload error");
+		goto discard;
+	}
+
+	/* Extract PTS and FID */
+	if (!(data[1] & UVC_STREAM_PTS)) {
+		PDEBUG(D_PACK, "PTS not present");
+		goto discard;
+	}
+	this_pts = (data[5] << 24) | (data[4] << 16) | (data[3] << 8) | data[2];
+	this_fid = (data[1] & UVC_STREAM_FID) ? 1 : 0;
+
+	/* If PTS or FID has changed, start a new frame. */
+	if (this_pts != sd->last_pts || this_fid != sd->last_fid) {
+		gspca_frame_add(gspca_dev, FIRST_PACKET, frame, NULL, 0);
+		sd->last_pts = this_pts;
+		sd->last_fid = this_fid;
+	}
+
+	/* Add the data from this payload */
+	gspca_frame_add(gspca_dev, INTER_PACKET, frame,
+				data + 12, len - 12);
+
+	/* If this packet is marked as EOF, end the frame */
+	if (data[1] & UVC_STREAM_EOF) {
+		sd->last_pts = 0;
+
+		if ((frame->data_end - frame->data) !=
+		    (gspca_dev->width * gspca_dev->height * 2)) {
+			PDEBUG(D_PACK, "short frame");
+			goto discard;
+		}
+
+		gspca_frame_add(gspca_dev, LAST_PACKET, frame, NULL, 0);
+	}
+
+	/* Done this payload */
+	goto scan_next;
+
+discard:
+	/* Discard data until a new frame starts. */
+	gspca_frame_add(gspca_dev, DISCARD_PACKET, frame, NULL, 0);
+	goto scan_next;
+}
+
+/* get stream parameters (framerate) */
+static int sd_get_streamparm(struct gspca_dev *gspca_dev,
+			     struct v4l2_streamparm *parm)
+{
+	struct v4l2_captureparm *cp = &parm->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	cp->capability |= V4L2_CAP_TIMEPERFRAME;
+	tpf->numerator = 1;
+	tpf->denominator = sd->frame_rate;
+
+	return 0;
+}
+
+/* set stream parameters (framerate) */
+static int sd_set_streamparm(struct gspca_dev *gspca_dev,
+			     struct v4l2_streamparm *parm)
+{
+	struct v4l2_captureparm *cp = &parm->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	/* Set requested framerate */
+	sd->frame_rate = tpf->denominator / tpf->numerator;
+	ov534_set_frame_rate(gspca_dev);
+
+	/* Return the actual framerate */
+	tpf->numerator = 1;
+	tpf->denominator = sd->frame_rate;
+
+	return 0;
+}
+
+/* sub-driver description */
+static const struct sd_desc sd_desc = {
+	.name     = MODULE_NAME,
+	.ctrls    = sd_ctrls,
+	.nctrls   = ARRAY_SIZE(sd_ctrls),
+	.config   = sd_config,
+	.init     = sd_init,
+	.start    = sd_start,
+	.stopN    = sd_stopN,
+	.pkt_scan = sd_pkt_scan,
+	.get_streamparm = sd_get_streamparm,
+	.set_streamparm = sd_set_streamparm,
+};
+
+/* -- module initialisation -- */
+static const __devinitdata struct usb_device_id device_table[] = {
+	{USB_DEVICE(0x06f8, 0x3002)},	/* Hercules Blog Webcam */
+	{USB_DEVICE(0x06f8, 0x3003)},	/* Hercules Dualpix HD Weblog */
+	{USB_DEVICE(0x1415, 0x2000)},	/* Sony HD Eye for PS3 (SLEH 00201) */
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, device_table);
+
+/* -- device connect -- */
+static int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
+			       THIS_MODULE);
+}
+
+static struct usb_driver sd_driver = {
+	.name       = MODULE_NAME,
+	.id_table   = device_table,
+	.probe      = sd_probe,
+	.disconnect = gspca_disconnect,
+#ifdef CONFIG_PM
+	.suspend    = gspca_suspend,
+	.resume     = gspca_resume,
+#endif
+};
+
+/* -- module insert / remove -- */
+static int __init sd_mod_init(void)
+{
+	if (usb_register(&sd_driver) < 0)
+		return -1;
+	PDEBUG(D_PROBE, "registered");
+	return 0;
+}
+
+static void __exit sd_mod_exit(void)
+{
+	usb_deregister(&sd_driver);
+	PDEBUG(D_PROBE, "deregistered");
+}
+
+module_init(sd_mod_init);
+module_exit(sd_mod_exit);
diff -urN linux/drivers/media/video/gspca/pac207.c linux/drivers/media/video/gspca/pac207.c
--- linux/drivers/media/video/gspca/pac207.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/pac207.c	2008-12-14 12:08:59.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * Pixart PAC207BCA library
  *
- * Copyright (C) 2008 Hans de Goede <j.w.r.degoede@hhs.nl>
+ * Copyright (C) 2008 Hans de Goede <hdgoede@redhat.com>
  * Copyright (C) 2005 Thomas Kaiser thomas@kaiser-linux.li
  * Copyleft (C) 2005 Michel Xhaard mxhaard@magic.fr
  *
@@ -27,7 +27,7 @@
 
 #include "gspca.h"
 
-MODULE_AUTHOR("Hans de Goede <j.w.r.degoede@hhs.nl>");
+MODULE_AUTHOR("Hans de Goede <hdgoede@redhat.com>");
 MODULE_DESCRIPTION("Pixart PAC207");
 MODULE_LICENSE("GPL");
 
@@ -529,6 +529,7 @@
 static const __devinitdata struct usb_device_id device_table[] = {
 	{USB_DEVICE(0x041e, 0x4028)},
 	{USB_DEVICE(0x093a, 0x2460)},
+	{USB_DEVICE(0x093a, 0x2461)},
 	{USB_DEVICE(0x093a, 0x2463)},
 	{USB_DEVICE(0x093a, 0x2464)},
 	{USB_DEVICE(0x093a, 0x2468)},
@@ -536,6 +537,7 @@
 	{USB_DEVICE(0x093a, 0x2471)},
 	{USB_DEVICE(0x093a, 0x2472)},
 	{USB_DEVICE(0x093a, 0x2476)},
+	{USB_DEVICE(0x145f, 0x013a)},
 	{USB_DEVICE(0x2001, 0xf115)},
 	{}
 };
diff -urN linux/drivers/media/video/gspca/pac7311.c linux/drivers/media/video/gspca/pac7311.c
--- linux/drivers/media/video/gspca/pac7311.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/pac7311.c	2008-12-25 15:33:23.000000000 +0100
@@ -1065,9 +1079,12 @@
 	{USB_DEVICE(0x093a, 0x260e), .driver_info = SENSOR_PAC7311},
 	{USB_DEVICE(0x093a, 0x260f), .driver_info = SENSOR_PAC7311},
 	{USB_DEVICE(0x093a, 0x2621), .driver_info = SENSOR_PAC7302},
+	{USB_DEVICE(0x093a, 0x2620), .driver_info = SENSOR_PAC7302},
+	{USB_DEVICE(0x093a, 0x2622), .driver_info = SENSOR_PAC7302},
 	{USB_DEVICE(0x093a, 0x2624), .driver_info = SENSOR_PAC7302},
 	{USB_DEVICE(0x093a, 0x2626), .driver_info = SENSOR_PAC7302},
 	{USB_DEVICE(0x093a, 0x262a), .driver_info = SENSOR_PAC7302},
+	{USB_DEVICE(0x093a, 0x262c), .driver_info = SENSOR_PAC7302},
 	{}
 };
 MODULE_DEVICE_TABLE(usb, device_table);
diff -urN linux/drivers/media/video/gspca/sonixb.c linux/drivers/media/video/gspca/sonixb.c
--- linux/drivers/media/video/gspca/sonixb.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/sonixb.c	2008-12-09 21:37:33.000000000 +0100
@@ -132,8 +132,6 @@
    ignore atleast the 2 next frames for the new settings to come into effect
    before doing any other adjustments */
 #define AUTOGAIN_IGNORE_FRAMES 3
-#define AUTOGAIN_DEADZONE 1000
-#define DESIRED_AVG_LUM 7000
 
 /* V4L2 controls supported by the driver */
 static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val);
@@ -827,18 +855,29 @@
 
 static void do_autogain(struct gspca_dev *gspca_dev)
 {
+	int deadzone, desired_avg_lum;
 	struct sd *sd = (struct sd *) gspca_dev;
 	int avg_lum = atomic_read(&sd->avg_lum);
 
 	if (avg_lum == -1)
 		return;
 
+	/* SIF / VGA sensors have a different autoexposure area and thus
+	   different avg_lum values for the same picture brightness */
+	if (sensor_data[sd->sensor].flags & F_SIF) {
+		deadzone = 1000;
+		desired_avg_lum = 7000;
+	} else {
+		deadzone = 3000;
+		desired_avg_lum = 23000;
+	}
+
 	if (sd->autogain_ignore_frames > 0)
 		sd->autogain_ignore_frames--;
 	else if (gspca_auto_gain_n_exposure(gspca_dev, avg_lum,
-			sd->brightness * DESIRED_AVG_LUM / 127,
-			AUTOGAIN_DEADZONE, GAIN_KNEE, EXPOSURE_KNEE)) {
-		PDEBUG(D_FRAM, "autogain: gain changed: gain: %d expo: %d\n",
+			sd->brightness * desired_avg_lum / 127,
+			deadzone, GAIN_KNEE, EXPOSURE_KNEE)) {
+		PDEBUG(D_FRAM, "autogain: gain changed: gain: %d expo: %d",
 			(int)sd->gain, (int)sd->exposure);
 		sd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;
 	}
@@ -1226,8 +1265,8 @@
 	{USB_DEVICE(0x0c45, 0x6025), SB(TAS5130CXX, 102)},
 	{USB_DEVICE(0x0c45, 0x6028), SB(PAS202, 102)},
 	{USB_DEVICE(0x0c45, 0x6029), SB(PAS106, 102)},
-	{USB_DEVICE(0x0c45, 0x602c), SB(OV7630, 102)},
 #endif
+	{USB_DEVICE(0x0c45, 0x602c), SB(OV7630, 102)},
 	{USB_DEVICE(0x0c45, 0x602d), SB(HV7131R, 102)},
 #if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
 	{USB_DEVICE(0x0c45, 0x602e), SB(OV7630, 102)},
diff -urN linux/drivers/media/video/gspca/sonixj.c linux/drivers/media/video/gspca/sonixj.c
--- linux/drivers/media/video/gspca/sonixj.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/sonixj.c	2008-12-09 21:37:33.000000000 +0100
@@ -24,6 +24,8 @@
 #include "gspca.h"
 #include "jpeg.h"
 
+#define V4L2_CID_INFRARED (V4L2_CID_PRIVATE_BASE + 0)
+
 MODULE_AUTHOR("Michel Xhaard <mxhaard@users.sourceforge.net>");
 MODULE_DESCRIPTION("GSPCA/SONIX JPEG USB Camera Driver");
 MODULE_LICENSE("GPL");
@@ -35,23 +37,26 @@
 	atomic_t avg_lum;
 	unsigned int exposure;
 
-	unsigned short brightness;
-	unsigned char contrast;
-	unsigned char colors;
-	unsigned char autogain;
+	__u16 brightness;
+	__u8 contrast;
+	__u8 colors;
+	__u8 autogain;
+	__u8 blue;
+	__u8 red;
 	__u8 vflip;			/* ov7630 only */
+	__u8 infrared;			/* mi0360 only */
 
-	signed char ag_cnt;
+	__s8 ag_cnt;
 #define AG_CNT_START 13
 
-	char qindex;
-	unsigned char bridge;
+	__u8 qindex;
+	__u8 bridge;
 #define BRIDGE_SN9C102P 0
 #define BRIDGE_SN9C105 1
 #define BRIDGE_SN9C110 2
 #define BRIDGE_SN9C120 3
 #define BRIDGE_SN9C325 4
-	char sensor;			/* Type of image sensor chip */
+	__u8 sensor;			/* Type of image sensor chip */
 #define SENSOR_HV7131R 0
 #define SENSOR_MI0360 1
 #define SENSOR_MO4000 2
@@ -59,7 +64,7 @@
 #define SENSOR_OV7630 4
 #define SENSOR_OV7648 5
 #define SENSOR_OV7660 6
-	unsigned char i2c_base;
+	__u8 i2c_base;
 };
 
 /* V4L2 controls supported by the driver */
@@ -69,10 +74,16 @@
 static int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setcolors(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getcolors(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setblue_balance(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getblue_balance(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setred_balance(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getred_balance(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getautogain(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setvflip(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getvflip(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setinfrared(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getinfrared(struct gspca_dev *gspca_dev, __s32 *val);
 
 static struct ctrl sd_ctrls[] = {
 	{
@@ -84,7 +95,7 @@
 #define BRIGHTNESS_MAX 0xffff
 		.maximum = BRIGHTNESS_MAX,
 		.step    = 1,
-#define BRIGHTNESS_DEF 0x7fff
+#define BRIGHTNESS_DEF 0x8000
 		.default_value = BRIGHTNESS_DEF,
 	    },
 	    .set = sd_setbrightness,
@@ -111,7 +122,7 @@
 		.type    = V4L2_CTRL_TYPE_INTEGER,
 		.name    = "Color",
 		.minimum = 0,
-		.maximum = 64,
+		.maximum = 40,
 		.step    = 1,
 #define COLOR_DEF 32
 		.default_value = COLOR_DEF,
@@ -119,7 +130,35 @@
 	    .set = sd_setcolors,
 	    .get = sd_getcolors,
 	},
-#define AUTOGAIN_IDX 3
+	{
+	    {
+		.id      = V4L2_CID_BLUE_BALANCE,
+		.type    = V4L2_CTRL_TYPE_INTEGER,
+		.name    = "Blue Balance",
+		.minimum = 24,
+		.maximum = 40,
+		.step    = 1,
+#define BLUE_BALANCE_DEF 32
+		.default_value = BLUE_BALANCE_DEF,
+	    },
+	    .set = sd_setblue_balance,
+	    .get = sd_getblue_balance,
+	},
+	{
+	    {
+		.id      = V4L2_CID_RED_BALANCE,
+		.type    = V4L2_CTRL_TYPE_INTEGER,
+		.name    = "Red Balance",
+		.minimum = 24,
+		.maximum = 40,
+		.step    = 1,
+#define RED_BALANCE_DEF 32
+		.default_value = RED_BALANCE_DEF,
+	    },
+	    .set = sd_setred_balance,
+	    .get = sd_getred_balance,
+	},
+#define AUTOGAIN_IDX 5
 	{
 	    {
 		.id      = V4L2_CID_AUTOGAIN,
@@ -135,7 +174,7 @@
 	    .get = sd_getautogain,
 	},
 /* ov7630 only */
-#define VFLIP_IDX 4
+#define VFLIP_IDX 6
 	{
 	    {
 		.id      = V4L2_CID_VFLIP,
@@ -150,6 +189,40 @@
 	    .set = sd_setvflip,
 	    .get = sd_getvflip,
 	},
+/* mi0360 only */
+#define INFRARED_IDX 7
+	{
+	    {
+		.id      = V4L2_CID_INFRARED,
+		.type    = V4L2_CTRL_TYPE_BOOLEAN,
+		.name    = "Infrared",
+		.minimum = 0,
+		.maximum = 1,
+		.step    = 1,
+#define INFRARED_DEF 0
+		.default_value = INFRARED_DEF,
+	    },
+	    .set = sd_setinfrared,
+	    .get = sd_getinfrared,
+	},
+};
+
+/* table of the disabled controls */
+static __u32 ctrl_dis[] = {
+	(1 << INFRARED_IDX) | (1 << VFLIP_IDX),
+						/* SENSOR_HV7131R 0 */
+	(1 << VFLIP_IDX),
+						/* SENSOR_MI0360 1 */
+	(1 << INFRARED_IDX) | (1 << VFLIP_IDX),
+						/* SENSOR_MO4000 2 */
+	(1 << INFRARED_IDX) | (1 << VFLIP_IDX),
+						/* SENSOR_OM6802 3 */
+	(1 << AUTOGAIN_IDX) | (1 << INFRARED_IDX),
+						/* SENSOR_OV7630 4 */
+	(1 << AUTOGAIN_IDX) | (1 << INFRARED_IDX) | (1 << VFLIP_IDX),
+						/* SENSOR_OV7648 5 */
+	(1 << AUTOGAIN_IDX) | (1 << INFRARED_IDX) | (1 << VFLIP_IDX),
+						/* SENSOR_OV7660 6 */
 };
 
 static struct v4l2_pix_format vga_mode[] = {
@@ -231,13 +304,13 @@
 
 static const __u8 sn_ov7648[] = {
 /*	reg0	reg1	reg2	reg3	reg4	reg5	reg6	reg7 */
-	0x00,	0x21,	0x62,	0x00,	0x1a,	0x20,	0x20,	0x20,
+	0x00,	0x63,	0x40,	0x00,	0x1a,	0x20,	0x20,	0x20,
 /*	reg8	reg9	rega	regb	regc	regd	rege	regf */
-	0xa1,	0x6e,	0x18,	0x65,	0x00,	0x00,	0x00,	0x10,
+	0x81,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x10,
 /*	reg10	reg11	reg12	reg13	reg14	reg15	reg16	reg17 */
-	0x03,	0x00,	0x00,	0x06,	0x06,	0x28,	0x1e,	0x82,
+	0x03,	0x00,	0x00,	0x01,	0x00,	0x28,	0x1e,	0x00,
 /*	reg18	reg19	reg1a	reg1b	reg1c	reg1d	reg1e	reg1f */
-	0x07,	0x00,	0x00,	0x00,	0x00,	0x00
+	0x0b,	0x00,	0x00,	0x00,	0x00,	0x00
 };
 
 static const __u8 sn_ov7660[]	= {
@@ -469,6 +542,53 @@
 /*	{0xb1, 0x21, 0x01, 0x88, 0x70, 0x00, 0x00, 0x10}, */
 	{}
 };
+
+static const __u8 ov7648_sensor_init[][8] = {
+	{0xa1, 0x21, 0x76, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10},	/* reset */
+	{0xa1, 0x21, 0x12, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xd1, 0x21, 0x03, 0xa4, 0x30, 0x88, 0x00, 0x10},
+	{0xb1, 0x21, 0x11, 0x80, 0x08, 0x00, 0x00, 0x10},
+	{0xc1, 0x21, 0x13, 0xa0, 0x04, 0x84, 0x00, 0x10},
+	{0xd1, 0x21, 0x17, 0x1a, 0x02, 0xba, 0xf4, 0x10},
+	{0xa1, 0x21, 0x1b, 0x04, 0x00, 0x00, 0x00, 0x10},
+	{0xd1, 0x21, 0x1f, 0x41, 0xc0, 0x80, 0x80, 0x10},
+	{0xd1, 0x21, 0x23, 0xde, 0xa0, 0x80, 0x32, 0x10},
+	{0xd1, 0x21, 0x27, 0xfe, 0xa0, 0x00, 0x91, 0x10},
+	{0xd1, 0x21, 0x2b, 0x00, 0x88, 0x85, 0x80, 0x10},
+	{0xc1, 0x21, 0x2f, 0x9c, 0x00, 0xc4, 0x00, 0x10},
+	{0xd1, 0x21, 0x60, 0xa6, 0x60, 0x88, 0x12, 0x10},
+	{0xd1, 0x21, 0x64, 0x88, 0x00, 0x00, 0x94, 0x10},
+	{0xd1, 0x21, 0x68, 0x7a, 0x0c, 0x00, 0x00, 0x10},
+	{0xd1, 0x21, 0x6c, 0x11, 0x33, 0x22, 0x00, 0x10},
+	{0xd1, 0x21, 0x70, 0x11, 0x00, 0x10, 0x50, 0x10},
+	{0xd1, 0x21, 0x74, 0x20, 0x06, 0x00, 0xb5, 0x10},
+	{0xd1, 0x21, 0x78, 0x8a, 0x00, 0x00, 0x00, 0x10},
+	{0xb1, 0x21, 0x7c, 0x00, 0x43, 0x00, 0x00, 0x10},
+
+	{0xd1, 0x21, 0x21, 0x86, 0x00, 0xde, 0xa0, 0x10},
+/*	{0xd1, 0x21, 0x25, 0x80, 0x32, 0xfe, 0xa0, 0x10}, jfm done */
+/*	{0xd1, 0x21, 0x29, 0x00, 0x91, 0x00, 0x88, 0x10}, jfm done */
+	{0xb1, 0x21, 0x2d, 0x85, 0x00, 0x00, 0x00, 0x10},
+/*...*/
+/*	{0xa1, 0x21, 0x12, 0x08, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xa1, 0x21, 0x75, 0x06, 0x00, 0x00, 0x00, 0x10}, jfm done */
+	{0xa1, 0x21, 0x19, 0x02, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x10, 0x32, 0x00, 0x00, 0x00, 0x10},
+/*	{0xa1, 0x21, 0x16, 0x00, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xa1, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},  * GAIN - def */
+/*	{0xb1, 0x21, 0x01, 0x6c, 0x6c, 0x00, 0x00, 0x10},  * B R - def: 80 */
+/*...*/
+	{0xa1, 0x21, 0x11, 0x81, 0x00, 0x00, 0x00, 0x10}, /* CLKRC */
+/*	{0xa1, 0x21, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xa1, 0x21, 0x16, 0x00, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xa1, 0x21, 0x2a, 0x91, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xa1, 0x21, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10}, jfm done */
+/*	{0xb1, 0x21, 0x01, 0x64, 0x84, 0x00, 0x00, 0x10},  * B R - def: 80 */
+
+	{}
+};
+
 static const __u8 ov7660_sensor_init[][8] = {
 	{0xa1, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10}, /* reset SCCB */
 /*		(delay 20ms) */
@@ -557,64 +677,6 @@
 	{0xa1, 0x21, 0x2b, 0xc3, 0x00, 0x00, 0x00, 0x10},
 	{}
 };
-/*	  reg 0x04	  reg 0x07		   reg 0x10 */
-/* expo = (COM1 & 0x02) | ((AECHH & 0x2f) << 10) | (AECh << 2) */
-
-static const __u8 ov7648_sensor_init[][8] = {
-	{0xC1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00},
-	{0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
-	{0xC1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00},
-	{0xA1, 0x6E, 0x3F, 0x20, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x04, 0x02, 0xB1, 0x02, 0x39, 0x10},
-	{0xD1, 0x6E, 0x08, 0x00, 0x01, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x0C, 0x02, 0x7F, 0x01, 0xE0, 0x10},
-	{0xD1, 0x6E, 0x12, 0x03, 0x02, 0x00, 0x03, 0x10},
-	{0xD1, 0x6E, 0x16, 0x85, 0x40, 0x4A, 0x40, 0x10},
-	{0xC1, 0x6E, 0x1A, 0x00, 0x80, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x1D, 0x08, 0x03, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x23, 0x00, 0xB0, 0x00, 0x94, 0x10},
-	{0xD1, 0x6E, 0x27, 0x58, 0x00, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x2D, 0x14, 0x35, 0x61, 0x84, 0x10},
-	{0xD1, 0x6E, 0x31, 0xA2, 0xBD, 0xD8, 0xFF, 0x10},
-	{0xD1, 0x6E, 0x35, 0x06, 0x1E, 0x12, 0x02, 0x10},
-	{0xD1, 0x6E, 0x39, 0xAA, 0x53, 0x37, 0xD5, 0x10},
-	{0xA1, 0x6E, 0x3D, 0xF2, 0x00, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x3E, 0x00, 0x00, 0x80, 0x03, 0x10},
-	{0xD1, 0x6E, 0x42, 0x03, 0x00, 0x00, 0x00, 0x10},
-	{0xC1, 0x6E, 0x46, 0x00, 0x80, 0x80, 0x00, 0x10},
-	{0xD1, 0x6E, 0x4B, 0x02, 0xEF, 0x08, 0xCD, 0x10},
-	{0xD1, 0x6E, 0x4F, 0x00, 0xD0, 0x00, 0xA0, 0x10},
-	{0xD1, 0x6E, 0x53, 0x01, 0xAA, 0x01, 0x40, 0x10},
-	{0xD1, 0x6E, 0x5A, 0x50, 0x04, 0x30, 0x03, 0x10},
-	{0xA1, 0x6E, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x5F, 0x10, 0x40, 0xFF, 0x00, 0x10},
-  /*	{0xD1, 0x6E, 0x63, 0x40, 0x40, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x10},
- * This is currently setting a
- * blue tint, and some things more , i leave it here for future test if
- * somene is having problems with color on this sensor
-	{0xD1, 0x6E, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x10},
-	{0xD1, 0x6E, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x10},
-	{0xC1, 0x6E, 0x73, 0x10, 0x80, 0xEB, 0x00, 0x10},
-	{0xA1, 0x6E, 0x1E, 0x03, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x15, 0x01, 0x00, 0x00, 0x00, 0x10},
-	{0xC1, 0x6E, 0x16, 0x40, 0x40, 0x40, 0x00, 0x10},
-	{0xA1, 0x6E, 0x1D, 0x08, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x07, 0xB5, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x18, 0x6B, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x1D, 0x08, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x10},
-	{0xA1, 0x6E, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x10},  */
-	{0xC1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00},
-	{0xA1, 0x6E, 0x06, 0x03, 0x00, 0x00, 0x00, 0x10}, /* Bright... */
-	{0xA1, 0x6E, 0x07, 0x66, 0x00, 0x00, 0x00, 0x10}, /* B.. */
-	{0xC1, 0x6E, 0x1A, 0x03, 0x65, 0x90, 0x00, 0x10}, /* Bright/Witen....*/
-/*	{0xC1, 0x6E, 0x16, 0x45, 0x40, 0x60, 0x00, 0x10},  * Bright/Witene */
-	{}
-};
 
 static const __u8 qtable4[] = {
 	0x06, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x08, 0x06,
@@ -757,8 +819,6 @@
 
 static int probesensor(struct gspca_dev *gspca_dev)
 {
-	struct sd *sd = (struct sd *) gspca_dev;
-
 	i2c_w1(gspca_dev, 0x02, 0);			/* sensor wakeup */
 	msleep(10);
 	reg_w1(gspca_dev, 0x02, 0x66);			/* Gpio on */
@@ -770,8 +830,7 @@
 	    && gspca_dev->usb_buf[3] == 0x00
 	    && gspca_dev->usb_buf[4] == 0x00) {
 		PDEBUG(D_PROBE, "Find Sensor sn9c102P HV7131R");
-		sd->sensor = SENSOR_HV7131R;
-		return SENSOR_HV7131R;
+		return 0;
 	}
 	PDEBUG(D_PROBE, "Find Sensor 0x%02x 0x%02x 0x%02x",
 		gspca_dev->usb_buf[0], gspca_dev->usb_buf[1],
@@ -792,7 +851,11 @@
 	static const __u8 regd4[] = {0x60, 0x00, 0x00};
 
 	reg_w1(gspca_dev, 0xf1, 0x00);
+#if 1
 	reg_w1(gspca_dev, 0x01, sn9c1xx[1]);
+#else
+	reg_w1(gspca_dev, 0x01, 0x00);		/*jfm: in some win traces*/
+#endif
 
 	/* configure gpio */
 	reg_w(gspca_dev, 0x01, &sn9c1xx[1], 2);
@@ -819,6 +882,7 @@
 		reg_w1(gspca_dev, 0x17, 0x64);
 		reg_w1(gspca_dev, 0x01, 0x42);
 		break;
+#if 1
 /*jfm: from win trace */
 	case SENSOR_OV7630:
 		reg_w1(gspca_dev, 0x01, 0x61);
@@ -826,18 +890,24 @@
 		reg_w1(gspca_dev, 0x01, 0x60);
 		reg_w1(gspca_dev, 0x01, 0x40);
 		break;
+#endif
 	case SENSOR_OV7648:
-		reg_w1(gspca_dev, 0x01, 0x43);
-		reg_w1(gspca_dev, 0x17, 0xae);
+		reg_w1(gspca_dev, 0x01, 0x63);
+		reg_w1(gspca_dev, 0x17, 0x20);
 		reg_w1(gspca_dev, 0x01, 0x42);
 		break;
+#if 1
 /*jfm: from win trace */
 	case SENSOR_OV7660:
-		reg_w1(gspca_dev, 0x01, 0x61);
-		reg_w1(gspca_dev, 0x17, 0x20);
-		reg_w1(gspca_dev, 0x01, 0x60);
-		reg_w1(gspca_dev, 0x01, 0x40);
-		break;
+		if (sd->bridge == BRIDGE_SN9C120) {
+			reg_w1(gspca_dev, 0x01, 0x61);
+			reg_w1(gspca_dev, 0x17, 0x20);
+			reg_w1(gspca_dev, 0x01, 0x60);
+			reg_w1(gspca_dev, 0x01, 0x40);
+			break;
+		}
+		/* fall thru */
+#endif
 	default:
 		reg_w1(gspca_dev, 0x01, 0x43);
 		reg_w1(gspca_dev, 0x17, 0x61);
@@ -922,6 +992,13 @@
 {
 	int i = 0;
 
+	i2c_w8(gspca_dev, ov7648_sensor_init[i]);
+	i++;
+/* win: dble reset */
+	i2c_w8(gspca_dev, ov7648_sensor_init[i]);	/* reset */
+	i++;
+	msleep(20);
+/* win: i2c reg read 00..7f */
 	while (ov7648_sensor_init[i][0]) {
 		i2c_w8(gspca_dev, ov7648_sensor_init[i]);
 		i++;
@@ -961,19 +1038,14 @@
 	sd->brightness = BRIGHTNESS_DEF;
 	sd->contrast = CONTRAST_DEF;
 	sd->colors = COLOR_DEF;
+	sd->blue = BLUE_BALANCE_DEF;
+	sd->red = RED_BALANCE_DEF;
 	sd->autogain = AUTOGAIN_DEF;
 	sd->ag_cnt = -1;
+	sd->vflip = VFLIP_DEF;
+	sd->infrared = INFRARED_DEF;
 
-	switch (sd->sensor) {
-	case SENSOR_OV7630:
-	case SENSOR_OV7648:
-	case SENSOR_OV7660:
-		gspca_dev->ctrl_dis = (1 << AUTOGAIN_IDX);
-		break;
-	}
-	if (sd->sensor != SENSOR_OV7630)
-		gspca_dev->ctrl_dis |= (1 << VFLIP_IDX);
-
+	gspca_dev->ctrl_dis = ctrl_dis[sd->sensor];
 	return 0;
 }
 
@@ -981,7 +1053,6 @@
 static int sd_init(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
-/*	const __u8 *sn9c1xx; */
 	__u8 regGpio[] = { 0x29, 0x74 };
 	__u8 regF1;
 
@@ -1100,32 +1171,13 @@
 	return expo;
 }
 
-/* this function is used for sensors o76xx only */
-static void setbrightcont(struct gspca_dev *gspca_dev)
-{
-	struct sd *sd = (struct sd *) gspca_dev;
-	int val;
-	__u8 reg84_full[0x15];
-
-	memcpy(reg84_full, reg84, sizeof reg84_full);
-	val = sd->contrast * 0x30 / CONTRAST_MAX + 0x10;	/* 10..40 */
-	reg84_full[0] = (val + 1) / 2;		/* red */
-	reg84_full[2] = val;			/* green */
-	reg84_full[4] = (val + 1) / 5;		/* blue */
-	val = (sd->brightness - BRIGHTNESS_DEF) * 0x10
-			/ BRIGHTNESS_MAX;
-	reg84_full[0x12] = val & 0x1f;		/* 5:0 signed value */
-	reg_w(gspca_dev, 0x84, reg84_full, sizeof reg84_full);
-}
-
-/* sensor != ov76xx */
 static void setbrightness(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	unsigned int expo;
 	__u8 k2;
 
-	k2 = sd->brightness >> 10;
+	k2 = ((int) sd->brightness - 0x8000) >> 10;
 	switch (sd->sensor) {
 	case SENSOR_HV7131R:
 		expo = sd->brightness << 4;
@@ -1147,38 +1199,49 @@
 		break;
 	}
 
-	reg_w1(gspca_dev, 0x96, k2);
+	reg_w1(gspca_dev, 0x96, k2);		/* color matrix Y offset */
 }
 
-/* sensor != ov76xx */
 static void setcontrast(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	__u8 k2;
-	__u8 contrast[] = { 0x00, 0x00, 0x28, 0x00, 0x07, 0x00 };
+	__u8 contrast[6];
 
-	k2 = sd->contrast;
-	contrast[2] = k2;
-	contrast[0] = (k2 + 1) >> 1;
-	contrast[4] = (k2 + 1) / 5;
-	reg_w(gspca_dev, 0x84, contrast, 6);
+	k2 = sd->contrast * 0x30 / (CONTRAST_MAX + 1) + 0x10;	/* 10..40 */
+	contrast[0] = (k2 + 1) / 2;		/* red */
+	contrast[1] = 0;
+	contrast[2] = k2;			/* green */
+	contrast[3] = 0;
+	contrast[4] = (k2 + 1) / 5;		/* blue */
+	contrast[5] = 0;
+	reg_w(gspca_dev, 0x84, contrast, sizeof contrast);
 }
 
 static void setcolors(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
-	__u8 blue, red;
-
-	if (sd->colors >= 32) {
-		red = 32 + (sd->colors - 32) / 2;
-		blue = 64 - sd->colors;
-	} else {
-		red = sd->colors;
-		blue = 32 + (32 - sd->colors) / 2;
+	int i, v;
+	__u8 reg8a[12];			/* U & V gains */
+	static __s16 uv[6] = {		/* same as reg84 in signed decimal */
+		-24, -38, 64,		/* UR UG UB */
+		 62, -51, -9		/* VR VG VB */
+	};
+	for (i = 0; i < 6; i++) {
+		v = uv[i] * sd->colors / COLOR_DEF;
+		reg8a[i * 2] = v;
+		reg8a[i * 2 + 1] = (v >> 8) & 0x0f;
 	}
-	reg_w1(gspca_dev, 0x05, red);
+	reg_w(gspca_dev, 0x8a, reg8a, sizeof reg8a);
+}
+
+static void setredblue(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	reg_w1(gspca_dev, 0x05, sd->red);
 /*	reg_w1(gspca_dev, 0x07, 32); */
-	reg_w1(gspca_dev, 0x06, blue);
+	reg_w1(gspca_dev, 0x06, sd->blue);
 }
 
 static void setautogain(struct gspca_dev *gspca_dev)
@@ -1195,12 +1258,24 @@
 
 static void setvflip(struct sd *sd)
 {
-	if (sd->sensor != SENSOR_OV7630)
-		return;
 	i2c_w1(&sd->gspca_dev, 0x75,			/* COMN */
 		sd->vflip ? 0x82 : 0x02);
 }
 
+static void setinfrared(struct sd *sd)
+{
+/*fixme: different sequence for StarCam Clip and StarCam 370i */
+#if 1
+/* Clip */
+	i2c_w1(&sd->gspca_dev, 0x02,			/* gpio */
+		sd->infrared ? 0x66 : 0x64);
+#else
+/* 370i */
+	i2c_w1(&sd->gspca_dev, 0x02,			/* gpio */
+		sd->infrared ? 0x55 : 0x54);
+#endif
+}
+
 /* -- start the camera -- */
 static int sd_start(struct gspca_dev *gspca_dev)
 {
@@ -1235,28 +1310,41 @@
 		reg17 = 0xe2;
 		break;
 	case SENSOR_OV7648:
-		reg17 = 0xae;
+		reg17 = 0x20;
 		break;
+#if 1
 /*jfm: from win trace */
 	case SENSOR_OV7660:
-		reg17 = 0xa0;
-		break;
+		if (sd->bridge == BRIDGE_SN9C120) {
+			reg17 = 0xa0;
+			break;
+		}
+		/* fall thru */
+#endif
 	default:
 		reg17 = 0x60;
 		break;
 	}
 	reg_w1(gspca_dev, 0x17, reg17);
-	reg_w1(gspca_dev, 0x05, sn9c1xx[5]);
-	reg_w1(gspca_dev, 0x07, sn9c1xx[7]);
-	reg_w1(gspca_dev, 0x06, sn9c1xx[6]);
+/* set reg1 was here */
+	reg_w1(gspca_dev, 0x05, sn9c1xx[5]);	/* red */
+	reg_w1(gspca_dev, 0x07, sn9c1xx[7]);	/* green */
+	reg_w1(gspca_dev, 0x06, sn9c1xx[6]);	/* blue */
 	reg_w1(gspca_dev, 0x14, sn9c1xx[0x14]);
 	reg_w(gspca_dev, 0x20, gamma_def, sizeof gamma_def);
 	for (i = 0; i < 8; i++)
 		reg_w(gspca_dev, 0x84, reg84, sizeof reg84);
 	switch (sd->sensor) {
-	case SENSOR_OV7660:
-		reg_w1(gspca_dev, 0x9a, 0x05);
+	case SENSOR_OV7648:
+		reg_w1(gspca_dev, 0x9a, 0x0a);
+		reg_w1(gspca_dev, 0x99, 0x60);
 		break;
+	case SENSOR_OV7660:
+		if (sd->bridge == BRIDGE_SN9C120) {
+			reg_w1(gspca_dev, 0x9a, 0x05);
+			break;
+		}
+		/* fall thru */
 	default:
 		reg_w1(gspca_dev, 0x9a, 0x08);
 		reg_w1(gspca_dev, 0x99, 0x59);
@@ -1265,10 +1353,10 @@
 
 	mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;
 	if (mode)
-		reg1 = 0x46;	/* 320 clk 48Mhz */
+		reg1 = 0x46;	/* 320x240: clk 48Mhz, video trf enable */
 	else
-		reg1 = 0x06;	/* 640 clk 24Mz */
-	reg17 = 0x61;
+		reg1 = 0x06;	/* 640x480: clk 24Mhz, video trf enable */
+	reg17 = 0x61;		/* 0x:20: enable sensor clock */
 	switch (sd->sensor) {
 	case SENSOR_HV7131R:
 		hv7131R_InitSensor(gspca_dev);
@@ -1298,23 +1386,21 @@
 		break;
 	case SENSOR_OV7648:
 		ov7648_InitSensor(gspca_dev);
-		reg17 = 0xa2;
-		reg1 = 0x44;
-/*		if (mode)
-			;		 * 320x2...
-		else
-			;		 * 640x... */
+		reg17 = 0x21;
+/*		reg1 = 0x42;		 * 42 - 46? */
 		break;
 	default:
 /*	case SENSOR_OV7660: */
 		ov7660_InitSensor(gspca_dev);
-		if (mode) {
-/*			reg17 = 0x21;	 * 320 */
-/*			reg1 = 0x44; */
-/*			reg1 = 0x46;	(done) */
+		if (sd->bridge == BRIDGE_SN9C120) {
+			if (mode) {		/* 320x240 - 160x120 */
+				reg17 = 0xa2;
+				reg1 = 0x44;	/* 48 Mhz, video trf eneble */
+			}
 		} else {
-			reg17 = 0xa2;	/* 640 */
-			reg1 = 0x44;
+			reg17 = 0x22;
+			reg1 = 0x06;	/* 24 Mhz, video trf eneble
+					 * inverse power down */
 		}
 		break;
 	}
@@ -1342,23 +1428,18 @@
 	reg_w1(gspca_dev, 0x18, reg18);
 
 	reg_w1(gspca_dev, 0x17, reg17);
+	reg_w1(gspca_dev, 0x01, reg1);
 	switch (sd->sensor) {
-	case SENSOR_HV7131R:
 	case SENSOR_MI0360:
-	case SENSOR_MO4000:
-	case SENSOR_OM6802:
-		setbrightness(gspca_dev);
-		setcontrast(gspca_dev);
+		setinfrared(sd);
 		break;
 	case SENSOR_OV7630:
 		setvflip(sd);
-		/* fall thru */
-	default:			/* OV76xx */
-		setbrightcont(gspca_dev);
 		break;
 	}
+	setbrightness(gspca_dev);
+	setcontrast(gspca_dev);
 	setautogain(gspca_dev);
-	reg_w1(gspca_dev, 0x01, reg1);
 	return 0;
 }
 
@@ -1369,6 +1450,8 @@
 		{ 0xa1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10 };
 	static const __u8 stopmi0360[] =
 		{ 0xb1, 0x5d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10 };
+	static const __u8 stopov7648[] =
+		{ 0xa1, 0x21, 0x76, 0x20, 0x00, 0x00, 0x00, 0x10 };
 	__u8 data;
 	const __u8 *sn9c1xx;
 
@@ -1382,8 +1465,10 @@
 		i2c_w8(gspca_dev, stopmi0360);
 		data = 0x29;
 		break;
-	case SENSOR_OV7630:
 	case SENSOR_OV7648:
+		i2c_w8(gspca_dev, stopov7648);
+		/* fall thru */
+	case SENSOR_OV7630:
 		data = 0x29;
 		break;
 	default:
@@ -1437,7 +1522,7 @@
 				expotimes = 0;
 			sd->exposure = setexposure(gspca_dev,
 						   (unsigned int) expotimes);
-			setcolors(gspca_dev);
+			setredblue(gspca_dev);
 			break;
 		}
 	}
@@ -1491,19 +1576,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->brightness = val;
-	if (gspca_dev->streaming) {
-		switch (sd->sensor) {
-		case SENSOR_HV7131R:
-		case SENSOR_MI0360:
-		case SENSOR_MO4000:
-		case SENSOR_OM6802:
-			setbrightness(gspca_dev);
-			break;
-		default:			/* OV76xx */
-			setbrightcont(gspca_dev);
-			break;
-		}
-	}
+	if (gspca_dev->streaming)
+		setbrightness(gspca_dev);
 	return 0;
 }
 
@@ -1520,19 +1594,8 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->contrast = val;
-	if (gspca_dev->streaming) {
-		switch (sd->sensor) {
-		case SENSOR_HV7131R:
-		case SENSOR_MI0360:
-		case SENSOR_MO4000:
-		case SENSOR_OM6802:
-			setcontrast(gspca_dev);
-			break;
-		default:			/* OV76xx */
-			setbrightcont(gspca_dev);
-			break;
-		}
-	}
+	if (gspca_dev->streaming)
+		setcontrast(gspca_dev);
 	return 0;
 }
 
@@ -1562,6 +1625,42 @@
 	return 0;
 }
 
+static int sd_setblue_balance(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->blue = val;
+	if (gspca_dev->streaming)
+		setredblue(gspca_dev);
+	return 0;
+}
+
+static int sd_getblue_balance(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->blue;
+	return 0;
+}
+
+static int sd_setred_balance(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->red = val;
+	if (gspca_dev->streaming)
+		setredblue(gspca_dev);
+	return 0;
+}
+
+static int sd_getred_balance(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->red;
+	return 0;
+}
+
 static int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
@@ -1598,6 +1697,24 @@
 	return 0;
 }
 
+static int sd_setinfrared(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->infrared = val;
+	if (gspca_dev->streaming)
+		setinfrared(sd);
+	return 0;
+}
+
+static int sd_getinfrared(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->infrared;
+	return 0;
+}
+
 /* sub-driver description */
 static const struct sd_desc sd_desc = {
 	.name = MODULE_NAME,
@@ -1620,12 +1737,15 @@
 #if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
 	{USB_DEVICE(0x0458, 0x7025), BSI(SN9C120, MI0360, 0x5d)},
 	{USB_DEVICE(0x0458, 0x702e), BSI(SN9C120, OV7660, 0x21)},
+#endif
 	{USB_DEVICE(0x045e, 0x00f5), BSI(SN9C105, OV7660, 0x21)},
 	{USB_DEVICE(0x045e, 0x00f7), BSI(SN9C105, OV7660, 0x21)},
+#if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
 	{USB_DEVICE(0x0471, 0x0327), BSI(SN9C105, MI0360, 0x5d)},
-	{USB_DEVICE(0x0471, 0x0328), BSI(SN9C105, MI0360, 0x5d)},
 #endif
+	{USB_DEVICE(0x0471, 0x0328), BSI(SN9C105, MI0360, 0x5d)},
 	{USB_DEVICE(0x0471, 0x0330), BSI(SN9C105, MI0360, 0x5d)},
+	{USB_DEVICE(0x06f8, 0x3004), BSI(SN9C105, OV7660, 0x21)},
 	{USB_DEVICE(0x0c45, 0x6040), BSI(SN9C102P, HV7131R, 0x11)},
 /* bw600.inf:
 	{USB_DEVICE(0x0c45, 0x6040), BSI(SN9C102P, MI0360, 0x5d)}, */
@@ -1649,7 +1769,7 @@
 /*	{USB_DEVICE(0x0c45, 0x6123), BSI(SN9C110, SanyoCCD, 0x??)}, */
 	{USB_DEVICE(0x0c45, 0x6128), BSI(SN9C110, OM6802, 0x21)}, /*sn9c325?*/
 /*bw600.inf:*/
-	{USB_DEVICE(0x0c45, 0x612a), BSI(SN9C110, OV7648, 0x21)}, /*sn9c325?*/
+	{USB_DEVICE(0x0c45, 0x612a), BSI(SN9C120, OV7648, 0x21)}, /*sn9c110?*/
 	{USB_DEVICE(0x0c45, 0x612c), BSI(SN9C110, MO4000, 0x21)},
 	{USB_DEVICE(0x0c45, 0x612e), BSI(SN9C110, OV7630, 0x21)},
 /*	{USB_DEVICE(0x0c45, 0x612f), BSI(SN9C110, ICM105C, 0x??)}, */
@@ -1657,8 +1777,8 @@
 	{USB_DEVICE(0x0c45, 0x6130), BSI(SN9C120, MI0360, 0x5d)},
 #endif
 	{USB_DEVICE(0x0c45, 0x6138), BSI(SN9C120, MO4000, 0x21)},
+	{USB_DEVICE(0x0c45, 0x613a), BSI(SN9C120, OV7648, 0x21)},
 #if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
-/*	{USB_DEVICE(0x0c45, 0x613a), BSI(SN9C120, OV7648, 0x??)}, */
 	{USB_DEVICE(0x0c45, 0x613b), BSI(SN9C120, OV7660, 0x21)},
 	{USB_DEVICE(0x0c45, 0x613c), BSI(SN9C120, HV7131R, 0x11)},
 /*	{USB_DEVICE(0x0c45, 0x613e), BSI(SN9C120, OV7630, 0x??)}, */
diff -urN linux/drivers/media/video/gspca/spca500.c linux/drivers/media/video/gspca/spca500.c
--- linux/drivers/media/video/gspca/spca500.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/spca500.c	2008-12-09 21:37:33.000000000 +0100
@@ -633,10 +650,10 @@
 	sd->subtype = id->driver_info;
 	if (sd->subtype != LogitechClickSmart310) {
 		cam->cam_mode = vga_mode;
-		cam->nmodes = sizeof vga_mode / sizeof vga_mode[0];
+		cam->nmodes = ARRAY_SIZE(vga_mode);
 	} else {
 		cam->cam_mode = sif_mode;
-		cam->nmodes = sizeof sif_mode / sizeof sif_mode[0];
+		cam->nmodes = ARRAY_SIZE(sif_mode);
 	}
 	sd->qindex = 5;
 	sd->brightness = BRIGHTNESS_DEF;
diff -urN linux/drivers/media/video/gspca/spca501.c linux/drivers/media/video/gspca/spca501.c
--- linux/drivers/media/video/gspca/spca501.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/spca501.c	2008-12-09 21:37:33.000000000 +0100
@@ -34,6 +34,8 @@
 	unsigned short contrast;
 	__u8 brightness;
 	__u8 colors;
+	__u8 blue_balance;
+	__u8 red_balance;
 
 	char subtype;
 #define Arowana300KCMOSCamera 0
@@ -52,6 +54,10 @@
 static int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setcolors(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getcolors(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setblue_balance(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getblue_balance(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setred_balance(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getred_balance(struct gspca_dev *gspca_dev, __s32 *val);
 
 static struct ctrl sd_ctrls[] = {
 #define MY_BRIGHTNESS 0
@@ -63,7 +69,7 @@
 		.minimum = 0,
 		.maximum = 127,
 		.step    = 1,
-		.default_value = 63,
+		.default_value = 0,
 	    },
 	    .set = sd_setbrightness,
 	    .get = sd_getbrightness,
@@ -75,9 +81,9 @@
 		.type    = V4L2_CTRL_TYPE_INTEGER,
 		.name    = "Contrast",
 		.minimum = 0,
-		.maximum = 0xffff,
+		.maximum = 64725,
 		.step    = 1,
-		.default_value = 0xaa00,
+		.default_value = 64725,
 	    },
 	    .set = sd_setcontrast,
 	    .get = sd_getcontrast,
@@ -91,11 +97,39 @@
 		.minimum = 0,
 		.maximum = 63,
 		.step    = 1,
-		.default_value = 31,
+		.default_value = 20,
 	    },
 	    .set = sd_setcolors,
 	    .get = sd_getcolors,
 	},
+#define MY_BLUE_BALANCE 3
+	{
+	    {
+		.id      = V4L2_CID_BLUE_BALANCE,
+		.type    = V4L2_CTRL_TYPE_INTEGER,
+		.name    = "Blue Balance",
+		.minimum = 0,
+		.maximum = 127,
+		.step    = 1,
+		.default_value = 0,
+	    },
+	    .set = sd_setblue_balance,
+	    .get = sd_getblue_balance,
+	},
+#define MY_RED_BALANCE 4
+	{
+	    {
+		.id      = V4L2_CID_RED_BALANCE,
+		.type    = V4L2_CTRL_TYPE_INTEGER,
+		.name    = "Red Balance",
+		.minimum = 0,
+		.maximum = 127,
+		.step    = 1,
+		.default_value = 0,
+	    },
+	    .set = sd_setred_balance,
+	    .get = sd_getred_balance,
+	},
 };
 
 static struct v4l2_pix_format vga_mode[] = {
@@ -1869,18 +1905,18 @@
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	reg_write(gspca_dev->dev, SPCA501_REG_CCDSP, 0x11, sd->brightness);
 	reg_write(gspca_dev->dev, SPCA501_REG_CCDSP, 0x12, sd->brightness);
-	reg_write(gspca_dev->dev, SPCA501_REG_CCDSP, 0x13, sd->brightness);
 }
 
 static void getbrightness(struct gspca_dev *gspca_dev)
 {
+#if 0
 	struct sd *sd = (struct sd *) gspca_dev;
 	__u16 brightness;
 
-	brightness = reg_read(gspca_dev, SPCA501_REG_CCDSP, 0x11, 2);
-	sd->brightness = brightness << 1;
+	brightness = reg_read(gspca_dev, SPCA501_REG_CCDSP, 0x12, 2);
+	sd->brightness = brightness;
+#endif
 }
 
 static void setcontrast(struct gspca_dev *gspca_dev)
@@ -1895,7 +1931,17 @@
 
 static void getcontrast(struct gspca_dev *gspca_dev)
 {
-/*	spca50x->contrast = 0xaa01; */
+#if 0
+	__u8 byte = 0;
+	byte = (reg_read(gspca_dev,
+				 0x00,
+				 0x00,
+				 1) & 0xff) << 8;
+	ss->contrast = byte | (reg_read(gspca_dev,
+				 0x00,
+				 0x01,
+				 1) & 0xff);
+#endif
 }
 
 static void setcolors(struct gspca_dev *gspca_dev)
@@ -1907,11 +1953,25 @@
 
 static void getcolors(struct gspca_dev *gspca_dev)
 {
+#if 0
 	struct sd *sd = (struct sd *) gspca_dev;
 
 	sd->colors = reg_read(gspca_dev, SPCA501_REG_CCDSP, 0x0c, 2);
-/*	sd->hue = (reg_read(gspca_dev, SPCA501_REG_CCDSP, 0x13, */
-/*			2) & 0xFF) << 8; */
+#endif
+}
+
+static void setblue_balance(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	reg_write(gspca_dev->dev, SPCA501_REG_CCDSP, 0x11, sd->blue_balance);
+}
+
+static void setred_balance(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	reg_write(gspca_dev->dev, SPCA501_REG_CCDSP, 0x13, sd->red_balance);
 }
 
 /* this function is called at probe time */
@@ -1930,6 +1990,14 @@
 	sd->contrast = sd_ctrls[MY_CONTRAST].qctrl.default_value;
 	sd->colors = sd_ctrls[MY_COLOR].qctrl.default_value;
 
+	return 0;
+}
+
+/* this function is called at probe and resume time */
+static int sd_init(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
 	switch (sd->subtype) {
 	case Arowana300KCMOSCamera:
 	case SmileIntlCamera:
@@ -1948,15 +2016,17 @@
 			goto error;
 		break;
 	}
+	PDEBUG(D_STREAM, "Initializing SPCA501 finished");
 	return 0;
 error:
 	return -EINVAL;
 }
 
-/* this function is called at probe and resume time */
-static int sd_init(struct gspca_dev *gspca_dev)
+static int sd_start(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
+	struct usb_device *dev = gspca_dev->dev;
+	int mode;
 
 	switch (sd->subtype) {
 	case ThreeComHomeConnectLite:
@@ -1976,14 +2046,6 @@
 		/* Generic 501 open data */
 		write_vector(gspca_dev, spca501_open_data);
 	}
-	PDEBUG(D_STREAM, "Initializing SPCA501 finished");
-	return 0;
-}
-
-static int sd_start(struct gspca_dev *gspca_dev)
-{
-	struct usb_device *dev = gspca_dev->dev;
-	int mode;
 
 	/* memorize the wanted pixel format */
 	mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;
@@ -2113,6 +2175,42 @@
 	return 0;
 }
 
+static int sd_setblue_balance(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->blue_balance = val;
+	if (gspca_dev->streaming)
+		setblue_balance(gspca_dev);
+	return 0;
+}
+
+static int sd_getblue_balance(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->blue_balance;
+	return 0;
+}
+
+static int sd_setred_balance(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->red_balance = val;
+	if (gspca_dev->streaming)
+		setred_balance(gspca_dev);
+	return 0;
+}
+
+static int sd_getred_balance(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->red_balance;
+	return 0;
+}
+
 /* sub-driver description */
 static const struct sd_desc sd_desc = {
 	.name = MODULE_NAME,
diff -urN linux/drivers/media/video/gspca/spca561.c linux/drivers/media/video/gspca/spca561.c
--- linux/drivers/media/video/gspca/spca561.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/spca561.c	2008-12-25 15:33:23.000000000 +0100
@@ -32,22 +32,22 @@
 struct sd {
 	struct gspca_dev gspca_dev;	/* !! must be the first item */
 
-	__u16 contrast;			/* rev72a only */
-#define CONTRAST_MIN 0x0000
-#define CONTRAST_DEF 0x2000
-#define CONTRAST_MAX 0x3fff
-
 	__u16 exposure;			/* rev12a only */
 #define EXPOSURE_MIN 1
 #define EXPOSURE_DEF 200
 #define EXPOSURE_MAX (4095 - 900) /* see set_exposure */
 
+	__u8 contrast;			/* rev72a only */
+#define CONTRAST_MIN 0x00
+#define CONTRAST_DEF 0x20
+#define CONTRAST_MAX 0x3f
+
 	__u8 brightness;		/* rev72a only */
 #define BRIGHTNESS_MIN 0
-#define BRIGHTNESS_DEF 32
-#define BRIGHTNESS_MAX 63
+#define BRIGHTNESS_DEF 0x20
+#define BRIGHTNESS_MAX 0x3f
 
-	__u8 white;			/* rev12a only */
+	__u8 white;
 #define WHITE_MIN 1
 #define WHITE_DEF 0x40
 #define WHITE_MAX 0x7f
@@ -146,98 +146,7 @@
 #define SPCA561_SNAPBIT 0x20
 #define SPCA561_SNAPCTRL 0x40
 
-static void reg_w_val(struct usb_device *dev, __u16 index, __u8 value)
-{
-	int ret;
-
-	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-			      0,		/* request */
-			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			      value, index, NULL, 0, 500);
-	PDEBUG(D_USBO, "reg write: 0x%02x:0x%02x", index, value);
-	if (ret < 0)
-		PDEBUG(D_ERR, "reg write: error %d", ret);
-}
-
-static void write_vector(struct gspca_dev *gspca_dev,
-			const __u16 data[][2])
-{
-	struct usb_device *dev = gspca_dev->dev;
-	int i;
-
-	i = 0;
-	while (data[i][1] != 0) {
-		reg_w_val(dev, data[i][1], data[i][0]);
-		i++;
-	}
-}
-
-/* read 'len' bytes to gspca_dev->usb_buf */
-static void reg_r(struct gspca_dev *gspca_dev,
-		  __u16 index, __u16 length)
-{
-	usb_control_msg(gspca_dev->dev,
-			usb_rcvctrlpipe(gspca_dev->dev, 0),
-			0,			/* request */
-			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			0,			/* value */
-			index, gspca_dev->usb_buf, length, 500);
-}
-
-static void reg_w_buf(struct gspca_dev *gspca_dev,
-		      __u16 index, const __u8 *buffer, __u16 len)
-{
-	memcpy(gspca_dev->usb_buf, buffer, len);
-	usb_control_msg(gspca_dev->dev,
-			usb_sndctrlpipe(gspca_dev->dev, 0),
-			0,			/* request */
-			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			0,			/* value */
-			index, gspca_dev->usb_buf, len, 500);
-}
-
-static void i2c_write(struct gspca_dev *gspca_dev, __u16 valeur, __u16 reg)
-{
-	int retry = 60;
-	__u8 DataLow;
-	__u8 DataHight;
-
-	DataLow = valeur;
-	DataHight = valeur >> 8;
-	reg_w_val(gspca_dev->dev, 0x8801, reg);
-	reg_w_val(gspca_dev->dev, 0x8805, DataLow);
-	reg_w_val(gspca_dev->dev, 0x8800, DataHight);
-	while (retry--) {
-		reg_r(gspca_dev, 0x8803, 1);
-		if (!gspca_dev->usb_buf[0])
-			break;
-	}
-}
-
-static int i2c_read(struct gspca_dev *gspca_dev, __u16 reg, __u8 mode)
-{
-	int retry = 60;
-	__u8 value;
-	__u8 vallsb;
-
-	reg_w_val(gspca_dev->dev, 0x8804, 0x92);
-	reg_w_val(gspca_dev->dev, 0x8801, reg);
-	reg_w_val(gspca_dev->dev, 0x8802, (mode | 0x01));
-	do {
-		reg_r(gspca_dev, 0x8803, 1);
-		if (!gspca_dev->usb_buf[0])
-			break;
-	} while (--retry);
-	if (retry == 0)
-		return -1;
-	reg_r(gspca_dev, 0x8800, 1);
-	value = gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8805, 1);
-	vallsb = gspca_dev->usb_buf[0];
-	return ((int) value << 8) | vallsb;
-}
-
-static const __u16 spca561_init_data[][2] = {
+static const __u16 rev72a_init_data1[][2] = {
 	{0x0000, 0x8114},	/* Software GPIO output data */
 	{0x0001, 0x8114},	/* Software GPIO output data */
 	{0x0000, 0x8112},	/* Some kind of reset */
@@ -247,44 +156,26 @@
 	{0x0001, 0x8118},	/* Conf sensor */
 	{0x0092, 0x8804},	/* I know nothing about these */
 	{0x0010, 0x8802},	/* 0x88xx registers, so I won't */
-	/***************/
 	{0x000d, 0x8805},	/* sensor default setting */
-	{0x0001, 0x8801},	/* 1 <- 0x0d */
-	{0x0000, 0x8800},
-	{0x0018, 0x8805},
-	{0x0002, 0x8801},	/* 2 <- 0x18 */
-	{0x0000, 0x8800},
-	{0x0065, 0x8805},
-	{0x0004, 0x8801},	/* 4 <- 0x01 0x65 */
-	{0x0001, 0x8800},
-	{0x0021, 0x8805},
-	{0x0005, 0x8801},	/* 5 <- 0x21 */
-	{0x0000, 0x8800},
-	{0x00aa, 0x8805},
-	{0x0007, 0x8801},	/* 7 <- 0xaa */
-	{0x0000, 0x8800},
-	{0x0004, 0x8805},
-	{0x0020, 0x8801},	/* 0x20 <- 0x15 0x04 */
-	{0x0015, 0x8800},
-	{0x0002, 0x8805},
-	{0x0039, 0x8801},	/* 0x39 <- 0x02 */
-	{0x0000, 0x8800},
-	{0x0010, 0x8805},
-	{0x0035, 0x8801},	/* 0x35 <- 0x10 */
-	{0x0000, 0x8800},
-	{0x0049, 0x8805},
-	{0x0009, 0x8801},	/* 0x09 <- 0x10 0x49 */
-	{0x0010, 0x8800},
-	{0x000b, 0x8805},
-	{0x0028, 0x8801},	/* 0x28 <- 0x0b */
-	{0x0000, 0x8800},
-	{0x000f, 0x8805},
-	{0x003b, 0x8801},	/* 0x3b <- 0x0f */
-	{0x0000, 0x8800},
-	{0x0000, 0x8805},
-	{0x003c, 0x8801},	/* 0x3c <- 0x00 */
-	{0x0000, 0x8800},
-	/***************/
+	{}
+};
+static const __u16 rev72a_init_sensor1[][2] = {
+				/* ms-win values */
+	{0x0001, 0x0018},	/* 0x01 <- 0x0d */
+	{0x0002, 0x0065},	/* 0x02 <- 0x18 */
+	{0x0004, 0x0121},	/* 0x04 <- 0x0165 */
+	{0x0005, 0x00aa},	/* 0x05 <- 0x21 */
+	{0x0007, 0x0004},	/* 0x07 <- 0xaa */
+	{0x0020, 0x1502},	/* 0x20 <- 0x1504 */
+	{0x0039, 0x0010},	/* 0x39 <- 0x02 */
+	{0x0035, 0x0049},	/* 0x35 <- 0x10 */
+	{0x0009, 0x100b},	/* 0x09 <- 0x1049 */
+	{0x0028, 0x000f},	/* 0x28 <- 0x0b */
+	{0x003b, 0x003c},	/* 0x3b <- 0x0f */
+	{0x003c, 0x0000},	/* 0x3c <- 0x00 */
+	{}
+};
+static const __u16 rev72a_init_data2[][2] = {
 	{0x0018, 0x8601},	/* Pixel/line selection for color separation */
 	{0x0000, 0x8602},	/* Optical black level for user setting */
 	{0x0060, 0x8604},	/* Optical black horizontal offset */
@@ -309,10 +200,18 @@
 	{0x0004, 0x8612},	/* Gr offset for white balance */
 	{0x0007, 0x8613},	/* B offset for white balance */
 	{0x0000, 0x8614},	/* Gb offset for white balance */
+#if 1
+/* from ms-win */
+	{0x0035, 0x8651},	/* R gain for white balance */
+	{0x0040, 0x8652},	/* Gr gain for white balance */
+	{0x005f, 0x8653},	/* B gain for white balance */
+	{0x0040, 0x8654},	/* Gb gain for white balance */
+#else
 	{0x008c, 0x8651},	/* R gain for white balance */
 	{0x008c, 0x8652},	/* Gr gain for white balance */
 	{0x00b5, 0x8653},	/* B gain for white balance */
 	{0x008c, 0x8654},	/* Gb gain for white balance */
+#endif
 	{0x0002, 0x8502},	/* Maximum average bit rate stuff */
 
 	{0x0011, 0x8802},
@@ -324,29 +223,22 @@
 
 	{0x0002, 0x865b},	/* Horizontal offset for valid pixels */
 	{0x0003, 0x865c},	/* Vertical offset for valid lines */
-	/***************//* sensor active */
-	{0x0003, 0x8801},	/* 0x03 <- 0x01 0x21 //289 */
-	{0x0021, 0x8805},
-	{0x0001, 0x8800},
-	{0x0004, 0x8801},	/* 0x04 <- 0x01 0x65 //357 */
-	{0x0065, 0x8805},
-	{0x0001, 0x8800},
-	{0x0005, 0x8801},	/* 0x05 <- 0x2f */
-	{0x002f, 0x8805},
-	{0x0000, 0x8800},
-	{0x0006, 0x8801},	/* 0x06 <- 0 */
-	{0x0000, 0x8805},
-	{0x0000, 0x8800},
-	{0x000a, 0x8801},	/* 0x0a <- 2 */
-	{0x0002, 0x8805},
-	{0x0000, 0x8800},
-	{0x0009, 0x8801},	/* 0x09 <- 0x1061 */
-	{0x0061, 0x8805},
-	{0x0010, 0x8800},
-	{0x0035, 0x8801},	/* 0x35 <-0x14 */
-	{0x0014, 0x8805},
-	{0x0000, 0x8800},
+	{}
+};
+static const __u16 rev72a_init_sensor2[][2] = {
+				/* ms-win values */
+	{0x0003, 0x0121},	/* 0x03 <- 0x01 0x21 //289 */
+	{0x0004, 0x0165},	/* 0x04 <- 0x01 0x65 //357 */
+	{0x0005, 0x002f},	/* 0x05 <- 0x2f */
+	{0x0006, 0x0000},	/* 0x06 <- 0 */
+	{0x000a, 0x0002},	/* 0x0a <- 2 */
+	{0x0009, 0x1061},	/* 0x09 <- 0x1061 */
+	{0x0035, 0x0014},	/* 0x35 <- 0x14 */
+	{}
+};
+static const __u16 rev72a_init_data3[][2] = {
 	{0x0030, 0x8112},	/* ISO and drop packet enable */
+/*fixme: should stop here*/
 	{0x0000, 0x8112},	/* Some kind of reset ???? */
 	{0x0009, 0x8118},	/* Enable sensor and set standby */
 	{0x0000, 0x8114},	/* Software GPIO output data */
@@ -434,7 +326,6 @@
 	{}
 };
 
-
 /******************** QC Express etch2 stuff ********************/
 static const __u16 Pb100_1map8300[][2] = {
 	/* reg, value */
@@ -515,22 +406,112 @@
 	{}
 };
 
-static void sensor_mapwrite(struct gspca_dev *gspca_dev,
-			    const __u16 sensormap[][2])
+static void reg_w_val(struct usb_device *dev, __u16 index, __u8 value)
 {
-	int i = 0;
-	__u8 usbval[2];
+	int ret;
 
-	while (sensormap[i][0]) {
-		usbval[0] = sensormap[i][1];
-		usbval[1] = sensormap[i][1] >> 8;
-		reg_w_buf(gspca_dev, sensormap[i][0], usbval, 2);
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			      0,		/* request */
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      value, index, NULL, 0, 500);
+	PDEBUG(D_USBO, "reg write: 0x%02x:0x%02x", index, value);
+	if (ret < 0)
+		PDEBUG(D_ERR, "reg write: error %d", ret);
+}
+
+static void write_vector(struct gspca_dev *gspca_dev,
+			const __u16 data[][2])
+{
+	struct usb_device *dev = gspca_dev->dev;
+	int i;
+
+	i = 0;
+	while (data[i][1] != 0) {
+		reg_w_val(dev, data[i][1], data[i][0]);
 		i++;
 	}
 }
+
+/* read 'len' bytes to gspca_dev->usb_buf */
+static void reg_r(struct gspca_dev *gspca_dev,
+		  __u16 index, __u16 length)
+{
+	usb_control_msg(gspca_dev->dev,
+			usb_rcvctrlpipe(gspca_dev->dev, 0),
+			0,			/* request */
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			0,			/* value */
+			index, gspca_dev->usb_buf, length, 500);
+}
+
+/* write 'len' bytes from gspca_dev->usb_buf */
+static void reg_w_buf(struct gspca_dev *gspca_dev,
+		      __u16 index, __u16 len)
+{
+	usb_control_msg(gspca_dev->dev,
+			usb_sndctrlpipe(gspca_dev->dev, 0),
+			0,			/* request */
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			0,			/* value */
+			index, gspca_dev->usb_buf, len, 500);
+}
+
+static void i2c_write(struct gspca_dev *gspca_dev, __u16 value, __u16 reg)
+{
+	int retry = 60;
+
+	reg_w_val(gspca_dev->dev, 0x8801, reg);
+	reg_w_val(gspca_dev->dev, 0x8805, value);
+	reg_w_val(gspca_dev->dev, 0x8800, value >> 8);
+	do {
+		reg_r(gspca_dev, 0x8803, 1);
+		if (!gspca_dev->usb_buf[0])
+			return;
+	} while (--retry);
+}
+
+static int i2c_read(struct gspca_dev *gspca_dev, __u16 reg, __u8 mode)
+{
+	int retry = 60;
+	__u8 value;
+
+	reg_w_val(gspca_dev->dev, 0x8804, 0x92);
+	reg_w_val(gspca_dev->dev, 0x8801, reg);
+	reg_w_val(gspca_dev->dev, 0x8802, mode | 0x01);
+	do {
+		reg_r(gspca_dev, 0x8803, 1);
+		if (!gspca_dev->usb_buf[0]) {
+			reg_r(gspca_dev, 0x8800, 1);
+			value = gspca_dev->usb_buf[0];
+			reg_r(gspca_dev, 0x8805, 1);
+			return ((int) value << 8) | gspca_dev->usb_buf[0];
+		}
+	} while (--retry);
+	return -1;
+}
+
+static void sensor_mapwrite(struct gspca_dev *gspca_dev,
+			    const __u16 (*sensormap)[2])
+{
+	while ((*sensormap)[0]) {
+		gspca_dev->usb_buf[0] = (*sensormap)[1];
+		gspca_dev->usb_buf[1] = (*sensormap)[1] >> 8;
+		reg_w_buf(gspca_dev, (*sensormap)[0], 2);
+		sensormap++;
+	}
+}
+
+static void write_sensor_72a(struct gspca_dev *gspca_dev,
+			    const __u16 (*sensor)[2])
+{
+	while ((*sensor)[0]) {
+		i2c_write(gspca_dev, (*sensor)[1], (*sensor)[0]);
+		sensor++;
+	}
+}
+
 static void init_161rev12A(struct gspca_dev *gspca_dev)
 {
-/*	sensor_reset(gspca_dev);	(not in win) */
 	write_vector(gspca_dev, spca561_161rev12A_data1);
 	sensor_mapwrite(gspca_dev, Pb100_1map8300);
 /*fixme: should be in sd_start*/
@@ -598,49 +579,68 @@
 static int sd_init_72a(struct gspca_dev *gspca_dev)
 {
 	PDEBUG(D_STREAM, "Chip revision: 072a");
-	write_vector(gspca_dev, spca561_init_data);
+	write_vector(gspca_dev, rev72a_init_data1);
+	write_sensor_72a(gspca_dev, rev72a_init_sensor1);
+	write_vector(gspca_dev, rev72a_init_data2);
+	write_sensor_72a(gspca_dev, rev72a_init_sensor2);
+	write_vector(gspca_dev, rev72a_init_data3);
 	return 0;
 }
 
-static void setcontrast(struct gspca_dev *gspca_dev)
+/* rev 72a only */
+static void setbrightness(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	struct usb_device *dev = gspca_dev->dev;
-	__u8 lowb;
+	__u8 value;
 
-	switch (sd->chip_revision) {
-	case Rev072A:
-		lowb = sd->contrast >> 8;
-		reg_w_val(dev, 0x8651, lowb);
-		reg_w_val(dev, 0x8652, lowb);
-		reg_w_val(dev, 0x8653, lowb);
-		reg_w_val(dev, 0x8654, lowb);
-		break;
-	default: {
-/*	case Rev012A: { */
-		static const __u8 Reg8391[] =
-			{ 0x92, 0x30, 0x20, 0x00, 0x0c, 0x00, 0x00, 0x00 };
+	value = sd->brightness;
 
-		reg_w_buf(gspca_dev, 0x8391, Reg8391, 8);
-		reg_w_buf(gspca_dev, 0x8390, Reg8391, 8);
-		break;
-	    }
-	}
+	/* offsets for white balance */
+	reg_w_val(dev, 0x8611, value);		/* R */
+	reg_w_val(dev, 0x8612, value);		/* Gr */
+	reg_w_val(dev, 0x8613, value);		/* B */
+	reg_w_val(dev, 0x8614, value);		/* Gb */
 }
 
-/* rev12a only */
 static void setwhite(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	__u16 white;
-	__u8 reg8614, reg8616;
+	__u8 blue, red;
+	__u16 reg;
 
-	white = sd->white;
 	/* try to emulate MS-win as possible */
-	reg8616 = 0x90 - white * 5 / 8;
-	reg_w_val(gspca_dev->dev, 0x8616, reg8616);
-	reg8614 = 0x20 + white * 3 / 8;
-	reg_w_val(gspca_dev->dev, 0x8614, reg8614);
+	white = sd->white;
+	red = 0x20 + white * 3 / 8;
+	blue = 0x90 - white * 5 / 8;
+	if (sd->chip_revision == Rev012A) {
+		reg = 0x8614;
+	} else {
+		reg = 0x8651;
+		red += sd->contrast - 0x20;
+		blue += sd->contrast - 0x20;
+	}
+	reg_w_val(gspca_dev->dev, reg, red);
+	reg_w_val(gspca_dev->dev, reg + 2, blue);
+}
+
+static void setcontrast(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	struct usb_device *dev = gspca_dev->dev;
+	__u8 value;
+
+	if (sd->chip_revision != Rev072A)
+		return;
+	value = sd->contrast + 0x20;
+
+	/* gains for white balance */
+	setwhite(gspca_dev);
+/*	reg_w_val(dev, 0x8651, value);		 * R - done by setwhite */
+	reg_w_val(dev, 0x8652, value);		/* Gr */
+/*	reg_w_val(dev, 0x8653, value);		 * B - done by setwhite */
+	reg_w_val(dev, 0x8654, value);		/* Gb */
 }
 
 /* rev 12a only */
@@ -649,7 +649,6 @@
 	struct sd *sd = (struct sd *) gspca_dev;
 	int expo;
 	int clock_divider;
-	__u8 data[2];
 
 	/* Register 0x8309 controls exposure for the spca561,
 	   the basic exposure setting goes from 1-2047, where 1 is completely
@@ -673,20 +672,19 @@
 		clock_divider = 3;
 	}
 	expo |= clock_divider << 11;
-	data[0] = expo;
-	data[1] = expo >> 8;
-	reg_w_buf(gspca_dev, 0x8309, data, 2);
+	gspca_dev->usb_buf[0] = expo;
+	gspca_dev->usb_buf[1] = expo >> 8;
+	reg_w_buf(gspca_dev, 0x8309, 2);
 }
 
 /* rev 12a only */
 static void setgain(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
-	__u8 data[2];
 
-	data[0] = sd->gain;
-	data[1] = 0;
-	reg_w_buf(gspca_dev, 0x8335, data, 2);
+	gspca_dev->usb_buf[0] = sd->gain;
+	gspca_dev->usb_buf[1] = 0;
+	reg_w_buf(gspca_dev, 0x8335, 2);
 }
 
 static void setautogain(struct gspca_dev *gspca_dev)
@@ -702,9 +700,9 @@
 static int sd_start_12a(struct gspca_dev *gspca_dev)
 {
 	struct usb_device *dev = gspca_dev->dev;
-	int Clck = 0x8a; /* lower 0x8X values lead to fps > 30 */
-	__u8 Reg8307[] = { 0xaa, 0x00 };
 	int mode;
+	static const __u8 Reg8391[8] =
+		{0x92, 0x30, 0x20, 0x00, 0x0c, 0x00, 0x00, 0x00};
 
 	mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;
 	if (mode <= 1) {
@@ -716,14 +714,21 @@
 		 * is sufficient to push raw frames at ~20fps */
 		reg_w_val(dev, 0x8500, mode);
 	}		/* -- qq@kuku.eu.org */
-	reg_w_buf(gspca_dev, 0x8307, Reg8307, 2);
-	reg_w_val(gspca_dev->dev, 0x8700, Clck);
+
+	gspca_dev->usb_buf[0] = 0xaa;
+	gspca_dev->usb_buf[1] = 0x00;
+	reg_w_buf(gspca_dev, 0x8307, 2);
+	/* clock - lower 0x8X values lead to fps > 30 */
+	reg_w_val(gspca_dev->dev, 0x8700, 0x8a);
 					/* 0x8f 0x85 0x27 clock */
 	reg_w_val(gspca_dev->dev, 0x8112, 0x1e | 0x20);
 	reg_w_val(gspca_dev->dev, 0x850b, 0x03);
-	setcontrast(gspca_dev);
+	memcpy(gspca_dev->usb_buf, Reg8391, 8);
+	reg_w_buf(gspca_dev, 0x8391, 8);
+	reg_w_buf(gspca_dev, 0x8390, 8);
 	setwhite(gspca_dev);
 	setautogain(gspca_dev);
+/*	setgain(gspca_dev);		*/
 	setexposure(gspca_dev);
 	return 0;
 }
@@ -750,6 +755,9 @@
 	reg_w_val(dev, 0x8500, mode);	/* mode */
 	reg_w_val(dev, 0x8700, Clck);	/* 0x27 clock */
 	reg_w_val(dev, 0x8112, 0x10 | 0x20);
+	setcontrast(gspca_dev);
+/*	setbrightness(gspca_dev);	 * fixme: bad values */
+	setwhite(gspca_dev);
 	setautogain(gspca_dev);
 	return 0;
 }
@@ -791,7 +799,6 @@
 	__u8 luma_mean = 110;
 	__u8 luma_delta = 20;
 	__u8 spring = 4;
-	__u8 reg8339[2];
 
 	if (sd->ag_cnt < 0)
 		return;
@@ -834,13 +841,13 @@
 
 			if (gainG > 0x3f)
 				gainG = 0x3f;
-			else if (gainG < 4)
+			else if (gainG < 3)
 				gainG = 3;
 			i2c_write(gspca_dev, gainG, 0x35);
 
-			if (expotimes >= 0x0256)
+			if (expotimes > 0x0256)
 				expotimes = 0x0256;
-			else if (expotimes < 4)
+			else if (expotimes < 3)
 				expotimes = 3;
 			i2c_write(gspca_dev, expotimes | pixelclk, 0x09);
 		}
@@ -848,13 +855,13 @@
 	case Rev012A:
 		reg_r(gspca_dev, 0x8330, 2);
 		if (gspca_dev->usb_buf[1] > 0x08) {
-			reg8339[0] = ++sd->expo12a;
-			reg8339[1] = 0;
-			reg_w_buf(gspca_dev, 0x8339, reg8339, 2);
+			gspca_dev->usb_buf[0] = ++sd->expo12a;
+			gspca_dev->usb_buf[1] = 0;
+			reg_w_buf(gspca_dev, 0x8339, 2);
 		} else if (gspca_dev->usb_buf[1] < 0x02) {
-			reg8339[0] = --sd->expo12a;
-			reg8339[1] = 0;
-			reg_w_buf(gspca_dev, 0x8339, reg8339, 2);
+			gspca_dev->usb_buf[0] = --sd->expo12a;
+			gspca_dev->usb_buf[1] = 0;
+			reg_w_buf(gspca_dev, 0x8339, 2);
 		}
 		break;
 	}
@@ -867,8 +874,8 @@
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	switch (data[0]) {
-	case 0:		/* start of frame */
+	switch (data[0]) {			/* sequence number */
+	case 0:					/* start of frame */
 		frame = gspca_frame_add(gspca_dev, LAST_PACKET, frame,
 					data, 0);
 		data += SPCA561_OFFSET_DATA;
@@ -890,8 +897,7 @@
 						frame, data, len);
 		}
 		return;
-	case 0xff:		/* drop */
-/*		gspca_dev->last_packet_type = DISCARD_PACKET; */
+	case 0xff:			/* drop (empty mpackets) */
 		return;
 	}
 	data++;
@@ -900,55 +906,6 @@
 }
 
 /* rev 72a only */
-static void setbrightness(struct gspca_dev *gspca_dev)
-{
-	struct sd *sd = (struct sd *) gspca_dev;
-	__u8 value;
-
-	value = sd->brightness;
-	reg_w_val(gspca_dev->dev, 0x8611, value);
-	reg_w_val(gspca_dev->dev, 0x8612, value);
-	reg_w_val(gspca_dev->dev, 0x8613, value);
-	reg_w_val(gspca_dev->dev, 0x8614, value);
-}
-
-static void getbrightness(struct gspca_dev *gspca_dev)
-{
-	struct sd *sd = (struct sd *) gspca_dev;
-	__u16 tot;
-
-	tot = 0;
-	reg_r(gspca_dev, 0x8611, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8612, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8613, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8614, 1);
-	tot += gspca_dev->usb_buf[0];
-	sd->brightness = tot >> 2;
-}
-
-/* rev72a only */
-static void getcontrast(struct gspca_dev *gspca_dev)
-{
-	struct sd *sd = (struct sd *) gspca_dev;
-	__u16 tot;
-
-	tot = 0;
-	reg_r(gspca_dev, 0x8651, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8652, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8653, 1);
-	tot += gspca_dev->usb_buf[0];
-	reg_r(gspca_dev, 0x8654, 1);
-	tot += gspca_dev->usb_buf[0];
-	sd->contrast = tot << 6;
-	PDEBUG(D_CONF, "get contrast %d", sd->contrast);
-}
-
-/* rev 72a only */
 static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
@@ -963,7 +920,6 @@
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	getbrightness(gspca_dev);
 	*val = sd->brightness;
 	return 0;
 }
@@ -983,7 +939,6 @@
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	getcontrast(gspca_dev);
 	*val = sd->contrast;
 	return 0;
 }
@@ -1006,7 +961,6 @@
 	return 0;
 }
 
-/* rev12a only */
 static int sd_setwhite(struct gspca_dev *gspca_dev, __s32 val)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
@@ -1121,6 +1075,19 @@
 
 static struct ctrl sd_ctrls_72a[] = {
 	{
+	    {
+		.id = V4L2_CID_DO_WHITE_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "White Balance",
+		.minimum = WHITE_MIN,
+		.maximum = WHITE_MAX,
+		.step = 1,
+		.default_value = WHITE_DEF,
+	    },
+	    .set = sd_setwhite,
+	    .get = sd_getwhite,
+	},
+	{
 	   {
 		.id = V4L2_CID_BRIGHTNESS,
 		.type = V4L2_CTRL_TYPE_INTEGER,
diff -urN linux/drivers/media/video/gspca/stk014.c linux/drivers/media/video/gspca/stk014.c
--- linux/drivers/media/video/gspca/stk014.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/stk014.c	2008-12-09 21:37:33.000000000 +0100
@@ -424,10 +424,8 @@
 
 		/* beginning of the frame */
 #define STKHDRSZ 12
-		gspca_frame_add(gspca_dev, INTER_PACKET, frame,
-				data + STKHDRSZ, len - STKHDRSZ);
-#undef STKHDRSZ
-		return;
+		data += STKHDRSZ;
+		len -= STKHDRSZ;
 	}
 	gspca_frame_add(gspca_dev, INTER_PACKET, frame, data, len);
 }
diff -urN linux/drivers/media/video/gspca/t613.c linux/drivers/media/video/gspca/t613.c
--- linux/drivers/media/video/gspca/t613.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/t613.c	2008-12-25 15:33:23.000000000 +0100
@@ -499,7 +499,7 @@
 	reg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);
 	msleep(5);
 	i = 4;
-	while (--i < 0) {
+	while (--i > 0) {
 		byte = reg_r(gspca_dev, 0x0060);
 		if (!(byte & 0x01))
 			break;
diff -urN linux/drivers/media/video/gspca/tv8532.c linux/drivers/media/video/gspca/tv8532.c
--- linux/drivers/media/video/gspca/tv8532.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/tv8532.c	2008-12-09 21:37:33.000000000 +0100
@@ -30,15 +30,10 @@
 struct sd {
 	struct gspca_dev gspca_dev;	/* !! must be the first item */
 
-	int buflen;			/* current length of tmpbuf */
-	__u8 tmpbuf[352 * 288 + 10 * 288];	/* no protection... */
-	__u8 tmpbuf2[352 * 288];		/* no protection... */
+	__u16 brightness;
+	__u16 contrast;
 
-	unsigned short brightness;
-	unsigned short contrast;
-
-	char packet;
-	char synchro;
+	__u8 packet;
 };
 
 /* V4L2 controls supported by the driver */
@@ -392,6 +387,8 @@
 /* -- start the camera -- */
 static int sd_start(struct gspca_dev *gspca_dev)
 {
+	struct sd *sd = (struct sd *) gspca_dev;
+
 	reg_w_1(gspca_dev, TV8532_AD_SLOPE, 0x32);
 	reg_w_1(gspca_dev, TV8532_AD_BITCTRL, 0x00);
 	tv_8532ReadRegisters(gspca_dev);
@@ -443,6 +440,10 @@
 	/************************************************/
 	tv_8532_PollReg(gspca_dev);
 	reg_w_1(gspca_dev, TV8532_UDP_UPDATE, 0x00);	/* 0x31 */
+
+	gspca_dev->empty_packet = 0;		/* check the empty packets */
+	sd->packet = 0;				/* ignore the first packets */
+
 	return 0;
 }
 
@@ -451,115 +452,49 @@
 	reg_w_1(gspca_dev, TV8532_GPIO_OE, 0x0b);
 }
 
-static void tv8532_preprocess(struct gspca_dev *gspca_dev)
-{
-	struct sd *sd = (struct sd *) gspca_dev;
-/* we should received a whole frame with header and EOL marker
- * in gspca_dev->tmpbuf and return a GBRG pattern in gspca_dev->tmpbuf2
- * sequence 2bytes header the Alternate pixels bayer GB 4 bytes
- * Alternate pixels bayer RG 4 bytes EOL */
-	int width = gspca_dev->width;
-	int height = gspca_dev->height;
-	unsigned char *dst = sd->tmpbuf2;
-	unsigned char *data = sd->tmpbuf;
-	int i;
-
-	/* precompute where is the good bayer line */
-	if (((data[3] + data[width + 7]) >> 1)
-	    + (data[4] >> 2)
-	    + (data[width + 6] >> 1) >= ((data[2] + data[width + 6]) >> 1)
-	    + (data[3] >> 2)
-	    + (data[width + 5] >> 1))
-		data += 3;
-	else
-		data += 2;
-	for (i = 0; i < height / 2; i++) {
-		memcpy(dst, data, width);
-		data += width + 3;
-		dst += width;
-		memcpy(dst, data, width);
-		data += width + 7;
-		dst += width;
-	}
-}
-
 static void sd_pkt_scan(struct gspca_dev *gspca_dev,
 			struct gspca_frame *frame,	/* target */
 			__u8 *data,			/* isoc packet */
 			int len)			/* iso packet length */
 {
 	struct sd *sd = (struct sd *) gspca_dev;
+	int packet_type0, packet_type1;
 
-	if (data[0] != 0x80) {
-		sd->packet++;
-		if (sd->buflen + len > sizeof sd->tmpbuf) {
-			if (gspca_dev->last_packet_type != DISCARD_PACKET) {
-				PDEBUG(D_PACK, "buffer overflow");
-				gspca_dev->last_packet_type = DISCARD_PACKET;
-			}
-			return;
-		}
-		memcpy(&sd->tmpbuf[sd->buflen], data, len);
-		sd->buflen += len;
-		return;
-	}
-
-	/* here we detect 0x80 */
-	/* counter is limited so we need few header for a frame :) */
-
-	/* header 0x80 0x80 0x80 0x80 0x80 */
-	/* packet  00   63  127  145  00   */
-	/* sof     0     1   1    0    0   */
-
-	/* update sequence */
-	if (sd->packet == 63 || sd->packet == 127)
-		sd->synchro = 1;
-
-	/* is there a frame start ? */
-	if (sd->packet >= (gspca_dev->height >> 1) - 1) {
-		PDEBUG(D_PACK, "SOF > %d packet %d", sd->synchro,
-		       sd->packet);
-		if (!sd->synchro) {	/* start of frame */
-			if (gspca_dev->last_packet_type == FIRST_PACKET) {
-				tv8532_preprocess(gspca_dev);
-				frame = gspca_frame_add(gspca_dev,
-							LAST_PACKET,
-							frame, sd->tmpbuf2,
-							gspca_dev->width *
-							    gspca_dev->width);
-			}
-			gspca_frame_add(gspca_dev, FIRST_PACKET,
-					frame, data, 0);
-			memcpy(sd->tmpbuf, data, len);
-			sd->buflen = len;
-			sd->packet = 0;
-			return;
-		}
-		if (gspca_dev->last_packet_type != DISCARD_PACKET) {
-			PDEBUG(D_PACK,
-			       "Warning wrong TV8532 frame detection %d",
-			       sd->packet);
-			gspca_dev->last_packet_type = DISCARD_PACKET;
-		}
-		return;
-	}
-
-	if (!sd->synchro) {
-		/* Drop packet frame corrupt */
-		PDEBUG(D_PACK, "DROP SOF %d packet %d",
-		       sd->synchro, sd->packet);
-		sd->packet = 0;
-		gspca_dev->last_packet_type = DISCARD_PACKET;
-		return;
-	}
-	sd->synchro = 1;
-	sd->packet++;
-	memcpy(&sd->tmpbuf[sd->buflen], data, len);
-	sd->buflen += len;
+	packet_type0 = packet_type1 = INTER_PACKET;
+	if (gspca_dev->empty_packet) {
+		gspca_dev->empty_packet = 0;
+		sd->packet = gspca_dev->height / 2;
+		packet_type0 = FIRST_PACKET;
+	} else if (sd->packet == 0)
+		return;			/* 2 more lines in 352x288 ! */
+	sd->packet--;
+	if (sd->packet == 0)
+		packet_type1 = LAST_PACKET;
+
+	/* each packet contains:
+	 * - header 2 bytes
+	 * - RG line
+	 * - 4 bytes
+	 * - GB line
+	 * - 4 bytes
+	 */
+	gspca_frame_add(gspca_dev, packet_type0,
+			frame, data + 2, gspca_dev->width);
+	gspca_frame_add(gspca_dev, packet_type1,
+			frame, data + gspca_dev->width + 6, gspca_dev->width);
 }
 
 static void setcontrast(struct gspca_dev *gspca_dev)
 {
+#if 0
+	value[0] = (gspca_dev->contrast) & 0xff;
+	value[1] = (gspca_dev->contrast >> 8) & 0xff;
+	reg_w_1(gspca_dev, 0x0020, value[1]);
+	reg_w_1(gspca_dev, 0x0022, value[1]);
+	reg_w_1(gspca_dev, 0x0024, value[1]);
+	reg_w_1(gspca_dev, 0x0026, value[1]);
+	reg_w_1(gspca_dev, TV8532_PART_CTRL, TV8532_CMD_UPDATE);
+#endif
 }
 
 static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)
diff -urN linux/drivers/media/video/gspca/vc032x.c linux/drivers/media/video/gspca/vc032x.c
--- linux/drivers/media/video/gspca/vc032x.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/vc032x.c	2008-12-14 12:07:02.000000000 +0100
@@ -32,44 +32,68 @@
 struct sd {
 	struct gspca_dev gspca_dev;	/* !! must be the first item */
 
-	unsigned char autogain;
-	unsigned char lightfreq;
+	__u8 hflip;
+	__u8 vflip;
+	__u8 lightfreq;
+	__u8 sharpness;
 
-	char qindex;
 	char bridge;
 #define BRIDGE_VC0321 0
 #define BRIDGE_VC0323 1
 	char sensor;
 #define SENSOR_HV7131R 0
-#define SENSOR_MI1320 1
-#define SENSOR_MI1310_SOC 2
-#define SENSOR_OV7660 3
-#define SENSOR_OV7670 4
-#define SENSOR_PO3130NC 5
+#define SENSOR_MI0360 1
+#define SENSOR_MI1320 2
+#define SENSOR_MI1310_SOC 3
+#define SENSOR_OV7660 4
+#define SENSOR_OV7670 5
+#define SENSOR_PO1200 6
+#define SENSOR_PO3130NC 7
 };
 
 /* V4L2 controls supported by the driver */
-static int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val);
-static int sd_getautogain(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_sethflip(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_gethflip(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setvflip(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getvflip(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setfreq(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getfreq(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setsharpness(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getsharpness(struct gspca_dev *gspca_dev, __s32 *val);
 
 static struct ctrl sd_ctrls[] = {
+/* next 2 controls work with ov7660 and ov7670 only */
+#define HFLIP_IDX 0
 	{
 	    {
-		.id      = V4L2_CID_AUTOGAIN,
+		.id      = V4L2_CID_HFLIP,
 		.type    = V4L2_CTRL_TYPE_BOOLEAN,
-		.name    = "Auto Gain",
+		.name    = "Mirror",
 		.minimum = 0,
 		.maximum = 1,
 		.step    = 1,
-#define AUTOGAIN_DEF 1
-		.default_value = AUTOGAIN_DEF,
+#define HFLIP_DEF 0
+		.default_value = HFLIP_DEF,
 	    },
-	    .set = sd_setautogain,
-	    .get = sd_getautogain,
+	    .set = sd_sethflip,
+	    .get = sd_gethflip,
 	},
-#define LIGHTFREQ_IDX 1
+#define VFLIP_IDX 1
+	{
+	    {
+		.id      = V4L2_CID_VFLIP,
+		.type    = V4L2_CTRL_TYPE_BOOLEAN,
+		.name    = "Vflip",
+		.minimum = 0,
+		.maximum = 1,
+		.step    = 1,
+#define VFLIP_DEF 0
+		.default_value = VFLIP_DEF,
+	    },
+	    .set = sd_setvflip,
+	    .get = sd_getvflip,
+	},
+#define LIGHTFREQ_IDX 2
 	{
 	    {
 		.id	 = V4L2_CID_POWER_LINE_FREQUENCY,
@@ -84,6 +108,22 @@
 	    .set = sd_setfreq,
 	    .get = sd_getfreq,
 	},
+/* po1200 only */
+#define SHARPNESS_IDX 3
+	{
+	 {
+	  .id = V4L2_CID_SHARPNESS,
+	  .type = V4L2_CTRL_TYPE_INTEGER,
+	  .name = "Sharpness",
+	  .minimum = 0,
+	  .maximum = 2,
+	  .step = 1,
+#define SHARPNESS_DEF 1
+	  .default_value = SHARPNESS_DEF,
+	  },
+	 .set = sd_setsharpness,
+	 .get = sd_getsharpness,
+	 },
 };
 
 static struct v4l2_pix_format vc0321_mode[] = {
@@ -111,6 +151,252 @@
 		.priv = 0},
 };
 
+static struct v4l2_pix_format svga_mode[] = {
+	{800, 600, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+		.bytesperline = 800,
+		.sizeimage = 800 * 600 * 1 / 4 + 590,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.priv = 0},
+};
+
+/* OV7660/7670 registers */
+#define OV7660_REG_MVFP 0x1e
+#define OV7660_MVFP_MIRROR	0x20
+#define OV7660_MVFP_VFLIP	0x10
+
+static const __u8 mi0360_matrix[9] = {
+	0x50, 0xf8, 0xf8, 0xf5, 0x50, 0xfb, 0xff, 0xf1, 0x50
+};
+
+static const __u8 mi0360_initVGA_JPG[][4] = {
+	{0xb0, 0x03, 0x19, 0xcc},
+	{0xb0, 0x04, 0x02, 0xcc},
+	{0xb3, 0x00, 0x24, 0xcc},
+	{0xb3, 0x00, 0x25, 0xcc},
+	{0xb3, 0x08, 0x01, 0xcc},
+	{0xb3, 0x09, 0x0c, 0xcc},
+	{0xb3, 0x05, 0x01, 0xcc},
+	{0xb3, 0x06, 0x03, 0xcc},
+	{0xb3, 0x03, 0x0a, 0xcc},
+	{0xb3, 0x20, 0x00, 0xcc},
+	{0xb3, 0x21, 0x00, 0xcc},
+	{0xb3, 0x22, 0x01, 0xcc},
+	{0xb3, 0x23, 0xe0, 0xcc},
+	{0xb3, 0x04, 0x05, 0xcc},
+	{0xb3, 0x14, 0x00, 0xcc},
+	{0xb3, 0x15, 0x00, 0xcc},
+	{0xb3, 0x16, 0x02, 0xcc},
+	{0xb3, 0x17, 0x7f, 0xcc},
+	{0xb3, 0x35, 0xdd, 0xcc},
+	{0xb3, 0x34, 0x02, 0xcc},
+	{0xb3, 0x00, 0x25, 0xcc},
+	{0xbc, 0x00, 0x71, 0xcc},
+	{0xb8, 0x00, 0x13, 0xcc},
+	{0xb8, 0x27, 0x20, 0xcc},
+	{0xb8, 0x2c, 0x50, 0xcc},
+	{0xb8, 0x2d, 0xf8, 0xcc},
+	{0xb8, 0x2e, 0xf8, 0xcc},
+	{0xb8, 0x2f, 0xf8, 0xcc},
+	{0xb8, 0x30, 0x50, 0xcc},
+	{0xb8, 0x31, 0xf8, 0xcc},
+	{0xb8, 0x32, 0xf8, 0xcc},
+	{0xb8, 0x33, 0xf8, 0xcc},
+	{0xb8, 0x34, 0x50, 0xcc},
+	{0xb8, 0x35, 0x00, 0xcc},
+	{0xb8, 0x36, 0x00, 0xcc},
+	{0xb8, 0x37, 0x00, 0xcc},
+	{0xb8, 0x01, 0x79, 0xcc},
+	{0xb8, 0x08, 0xe0, 0xcc},
+	{0xb3, 0x01, 0x41, 0xcc},
+	{0xb8, 0x01, 0x79, 0xcc},
+	{0xb8, 0x14, 0x18, 0xcc},
+	{0xb8, 0xb2, 0x0a, 0xcc},
+	{0xb8, 0xb4, 0x0a, 0xcc},
+	{0xb8, 0xb5, 0x0a, 0xcc},
+	{0xb8, 0xfe, 0x00, 0xcc},
+	{0xb8, 0xff, 0x28, 0xcc},
+	{0xb9, 0x00, 0x28, 0xcc},
+	{0xb9, 0x01, 0x28, 0xcc},
+	{0xb9, 0x02, 0x28, 0xcc},
+	{0xb9, 0x03, 0x00, 0xcc},
+	{0xb9, 0x04, 0x00, 0xcc},
+	{0xb9, 0x05, 0x3c, 0xcc},
+	{0xb9, 0x06, 0x3c, 0xcc},
+	{0xb9, 0x07, 0x3c, 0xcc},
+	{0xb9, 0x08, 0x3c, 0xcc},
+	{0xb8, 0x8e, 0x00, 0xcc},
+	{0xb8, 0x8f, 0xff, 0xcc},
+	{0xb8, 0x81, 0x09, 0xcc},
+	{0x31, 0x00, 0x00, 0xbb},
+	{0x09, 0x01, 0xc7, 0xbb},
+	{0x34, 0x01, 0x00, 0xbb},
+	{0x2b, 0x00, 0x28, 0xbb},
+	{0x2c, 0x00, 0x30, 0xbb},
+	{0x2d, 0x00, 0x30, 0xbb},
+	{0x2e, 0x00, 0x28, 0xbb},
+	{0x62, 0x04, 0x11, 0xbb},
+	{0x03, 0x01, 0xe0, 0xbb},
+	{0x2c, 0x00, 0x2c, 0xbb},
+	{0x20, 0xd0, 0x00, 0xbb},
+	{0x01, 0x00, 0x08, 0xbb},
+	{0x06, 0x00, 0x10, 0xbb},
+	{0x05, 0x00, 0x20, 0xbb},
+	{0x20, 0x00, 0x00, 0xbb},
+	{0xb6, 0x00, 0x00, 0xcc},
+	{0xb6, 0x03, 0x02, 0xcc},
+	{0xb6, 0x02, 0x80, 0xcc},
+	{0xb6, 0x05, 0x01, 0xcc},
+	{0xb6, 0x04, 0xe0, 0xcc},
+	{0xb6, 0x12, 0x78, 0xcc},
+	{0xb6, 0x18, 0x02, 0xcc},
+	{0xb6, 0x17, 0x58, 0xcc},
+	{0xb6, 0x16, 0x00, 0xcc},
+	{0xb6, 0x22, 0x12, 0xcc},
+	{0xb6, 0x23, 0x0b, 0xcc},
+	{0xb3, 0x02, 0x02, 0xcc},
+	{0xbf, 0xc0, 0x39, 0xcc},
+	{0xbf, 0xc1, 0x04, 0xcc},
+	{0xbf, 0xcc, 0x10, 0xcc},
+	{0xb9, 0x12, 0x00, 0xcc},
+	{0xb9, 0x13, 0x0a, 0xcc},
+	{0xb9, 0x14, 0x0a, 0xcc},
+	{0xb9, 0x15, 0x0a, 0xcc},
+	{0xb9, 0x16, 0x0a, 0xcc},
+	{0xb9, 0x18, 0x00, 0xcc},
+	{0xb9, 0x19, 0x0f, 0xcc},
+	{0xb9, 0x1a, 0x0f, 0xcc},
+	{0xb9, 0x1b, 0x0f, 0xcc},
+	{0xb9, 0x1c, 0x0f, 0xcc},
+	{0xb8, 0x8e, 0x00, 0xcc},
+	{0xb8, 0x8f, 0xff, 0xcc},
+	{0xb6, 0x12, 0xf8, 0xcc},
+	{0xb8, 0x0c, 0x20, 0xcc},
+	{0xb8, 0x0d, 0x70, 0xcc},
+	{0xb6, 0x13, 0x13, 0xcc},
+	{0x35, 0x00, 0x60, 0xbb},
+	{0xb3, 0x5c, 0x01, 0xcc},
+	{}
+};
+static const __u8 mi0360_initQVGA_JPG[][4] = {
+	{0xb0, 0x03, 0x19, 0xcc},
+	{0xb0, 0x04, 0x02, 0xcc},
+	{0xb3, 0x00, 0x24, 0xcc},
+	{0xb3, 0x00, 0x25, 0xcc},
+	{0xb3, 0x08, 0x01, 0xcc},
+	{0xb3, 0x09, 0x0c, 0xcc},
+	{0xb3, 0x05, 0x01, 0xcc},
+	{0xb3, 0x06, 0x03, 0xcc},
+	{0xb3, 0x03, 0x0a, 0xcc},
+	{0xb3, 0x20, 0x00, 0xcc},
+	{0xb3, 0x21, 0x00, 0xcc},
+	{0xb3, 0x22, 0x01, 0xcc},
+	{0xb3, 0x23, 0xe0, 0xcc},
+	{0xb3, 0x04, 0x05, 0xcc},
+	{0xb3, 0x14, 0x00, 0xcc},
+	{0xb3, 0x15, 0x00, 0xcc},
+	{0xb3, 0x16, 0x02, 0xcc},
+	{0xb3, 0x17, 0x7f, 0xcc},
+	{0xb3, 0x35, 0xdd, 0xcc},
+	{0xb3, 0x34, 0x02, 0xcc},
+	{0xb3, 0x00, 0x25, 0xcc},
+	{0xbc, 0x00, 0xd1, 0xcc},
+	{0xb8, 0x00, 0x13, 0xcc},
+	{0xb8, 0x27, 0x20, 0xcc},
+	{0xb8, 0x2c, 0x50, 0xcc},
+	{0xb8, 0x2d, 0xf8, 0xcc},
+	{0xb8, 0x2e, 0xf8, 0xcc},
+	{0xb8, 0x2f, 0xf8, 0xcc},
+	{0xb8, 0x30, 0x50, 0xcc},
+	{0xb8, 0x31, 0xf8, 0xcc},
+	{0xb8, 0x32, 0xf8, 0xcc},
+	{0xb8, 0x33, 0xf8, 0xcc},
+	{0xb8, 0x34, 0x50, 0xcc},
+	{0xb8, 0x35, 0x00, 0xcc},
+	{0xb8, 0x36, 0x00, 0xcc},
+	{0xb8, 0x37, 0x00, 0xcc},
+	{0xb8, 0x01, 0x79, 0xcc},
+	{0xb8, 0x08, 0xe0, 0xcc},
+	{0xb3, 0x01, 0x41, 0xcc},
+	{0xb8, 0x01, 0x79, 0xcc},
+	{0xb8, 0x14, 0x18, 0xcc},
+	{0xb8, 0xb2, 0x0a, 0xcc},
+	{0xb8, 0xb4, 0x0a, 0xcc},
+	{0xb8, 0xb5, 0x0a, 0xcc},
+	{0xb8, 0xfe, 0x00, 0xcc},
+	{0xb8, 0xff, 0x28, 0xcc},
+	{0xb9, 0x00, 0x28, 0xcc},
+	{0xb9, 0x01, 0x28, 0xcc},
+	{0xb9, 0x02, 0x28, 0xcc},
+	{0xb9, 0x03, 0x00, 0xcc},
+	{0xb9, 0x04, 0x00, 0xcc},
+	{0xb9, 0x05, 0x3c, 0xcc},
+	{0xb9, 0x06, 0x3c, 0xcc},
+	{0xb9, 0x07, 0x3c, 0xcc},
+	{0xb9, 0x08, 0x3c, 0xcc},
+	{0xb8, 0x8e, 0x00, 0xcc},
+	{0xb8, 0x8f, 0xff, 0xcc},
+	{0xb8, 0x81, 0x09, 0xcc},
+	{0x31, 0x00, 0x00, 0xbb},
+	{0x09, 0x01, 0xc7, 0xbb},
+	{0x34, 0x01, 0x00, 0xbb},
+	{0x2b, 0x00, 0x28, 0xbb},
+	{0x2c, 0x00, 0x30, 0xbb},
+	{0x2d, 0x00, 0x30, 0xbb},
+	{0x2e, 0x00, 0x28, 0xbb},
+	{0x62, 0x04, 0x11, 0xbb},
+	{0x03, 0x01, 0xe0, 0xbb},
+	{0x2c, 0x00, 0x2c, 0xbb},
+	{0x20, 0xd0, 0x00, 0xbb},
+	{0x01, 0x00, 0x08, 0xbb},
+	{0x06, 0x00, 0x10, 0xbb},
+	{0x05, 0x00, 0x20, 0xbb},
+	{0x20, 0x00, 0x00, 0xbb},
+	{0xb6, 0x00, 0x00, 0xcc},
+	{0xb6, 0x03, 0x01, 0xcc},
+	{0xb6, 0x02, 0x40, 0xcc},
+	{0xb6, 0x05, 0x00, 0xcc},
+	{0xb6, 0x04, 0xf0, 0xcc},
+	{0xb6, 0x12, 0x78, 0xcc},
+	{0xb6, 0x18, 0x00, 0xcc},
+	{0xb6, 0x17, 0x96, 0xcc},
+	{0xb6, 0x16, 0x00, 0xcc},
+	{0xb6, 0x22, 0x12, 0xcc},
+	{0xb6, 0x23, 0x0b, 0xcc},
+	{0xb3, 0x02, 0x02, 0xcc},
+	{0xbf, 0xc0, 0x39, 0xcc},
+	{0xbf, 0xc1, 0x04, 0xcc},
+	{0xbf, 0xcc, 0x10, 0xcc},
+	{0xb9, 0x12, 0x00, 0xcc},
+	{0xb9, 0x13, 0x0a, 0xcc},
+	{0xb9, 0x14, 0x0a, 0xcc},
+	{0xb9, 0x15, 0x0a, 0xcc},
+	{0xb9, 0x16, 0x0a, 0xcc},
+	{0xb9, 0x18, 0x00, 0xcc},
+	{0xb9, 0x19, 0x0f, 0xcc},
+	{0xb9, 0x1a, 0x0f, 0xcc},
+	{0xb9, 0x1b, 0x0f, 0xcc},
+	{0xb9, 0x1c, 0x0f, 0xcc},
+	{0xb8, 0x8e, 0x00, 0xcc},
+	{0xb8, 0x8f, 0xff, 0xcc},
+	{0xb6, 0x12, 0xf8, 0xcc},
+	{0xb6, 0x13, 0x13, 0xcc},
+	{0xbc, 0x02, 0x18, 0xcc},
+	{0xbc, 0x03, 0x50, 0xcc},
+	{0xbc, 0x04, 0x18, 0xcc},
+	{0xbc, 0x05, 0x00, 0xcc},
+	{0xbc, 0x06, 0x00, 0xcc},
+	{0xbc, 0x08, 0x30, 0xcc},
+	{0xbc, 0x09, 0x40, 0xcc},
+	{0xbc, 0x0a, 0x10, 0xcc},
+	{0xb8, 0x0c, 0x20, 0xcc},
+	{0xb8, 0x0d, 0x70, 0xcc},
+	{0xbc, 0x0b, 0x00, 0xcc},
+	{0xbc, 0x0c, 0x00, 0xcc},
+	{0x35, 0x00, 0xef, 0xbb},
+	{0xb3, 0x5c, 0x01, 0xcc},
+	{}
+};
+
 static const __u8 mi1310_socinitVGA_JPG[][4] = {
 	{0xb0, 0x03, 0x19, 0xcc},
 	{0xb0, 0x04, 0x02, 0xcc},
@@ -823,7 +1109,7 @@
 	{0x00, 0x01, 0x80, 0xaa},	{0x00, 0x02, 0x80, 0xaa},
 	{0x00, 0x12, 0x80, 0xaa},
 	{0x00, 0x12, 0x05, 0xaa},
-	{0x00, 0x1e, 0x01, 0xaa},
+	{0x00, 0x1e, 0x01, 0xaa},	/* MVFP */
 	{0x00, 0x3d, 0x40, 0xaa}, /* 0x3d <-40 gamma 01 */
 	{0x00, 0x41, 0x00, 0xaa}, /* edge 00 */
 	{0x00, 0x0d, 0x48, 0xaa},	{0x00, 0x0e, 0x04, 0xaa},
@@ -877,7 +1163,7 @@
 	{0xb8, 0x27, 0x20, 0xcc},	{0xb8, 0x8f, 0x50, 0xcc},
 	{0x00, 0x01, 0x80, 0xaa},	{0x00, 0x02, 0x80, 0xaa},
 	{0x00, 0x12, 0x80, 0xaa},	{0x00, 0x12, 0x05, 0xaa},
-	{0x00, 0x1e, 0x01, 0xaa},
+	{0x00, 0x1e, 0x01, 0xaa},	/* MVFP */
 	{0x00, 0x3d, 0x40, 0xaa}, /* 0x3d <-40 gamma 01 */
 	{0x00, 0x41, 0x00, 0xaa}, /* edge 00 */
 	{0x00, 0x0d, 0x48, 0xaa},	{0x00, 0x0e, 0x04, 0xaa},
@@ -983,7 +1269,8 @@
 	{0x00, 0xa9, 0x90, 0xaa},	{0x00, 0xaa, 0x14, 0xaa},
 	{0x00, 0x13, 0xe5, 0xaa},	{0x00, 0x0e, 0x61, 0xaa},
 	{0x00, 0x0f, 0x4b, 0xaa},	{0x00, 0x16, 0x02, 0xaa},
-	{0x00, 0x1e, 0x07, 0xaa},	{0x00, 0x21, 0x02, 0xaa},
+	{0x00, 0x1e, 0x07, 0xaa},	/* MVFP */
+	{0x00, 0x21, 0x02, 0xaa},
 	{0x00, 0x22, 0x91, 0xaa},	{0x00, 0x29, 0x07, 0xaa},
 	{0x00, 0x33, 0x0b, 0xaa},	{0x00, 0x35, 0x0b, 0xaa},
 	{0x00, 0x37, 0x1d, 0xaa},	{0x00, 0x38, 0x71, 0xaa},
@@ -1048,7 +1335,8 @@
 	{0x00, 0x71, 0x35, 0xaa},	{0x00, 0x72, 0x11, 0xaa},
 	{0x00, 0x73, 0xf0, 0xaa},	{0x00, 0xa2, 0x02, 0xaa},
 	{0x00, 0xb1, 0x00, 0xaa},	{0x00, 0xb1, 0x0c, 0xaa},
-	{0x00, 0x1e, 0x37, 0xaa},	{0x00, 0xaa, 0x14, 0xaa},
+	{0x00, 0x1e, 0x37, 0xaa},	/* MVFP */
+	{0x00, 0xaa, 0x14, 0xaa},
 	{0x00, 0x24, 0x80, 0xaa},	{0x00, 0x25, 0x74, 0xaa},
 	{0x00, 0x26, 0xd3, 0xaa},	{0x00, 0x0d, 0x00, 0xaa},
 	{0x00, 0x14, 0x18, 0xaa},	{0x00, 0x9d, 0x99, 0xaa},
@@ -1110,7 +1398,8 @@
 	{0x00, 0xa9, 0x90, 0xaa},	{0x00, 0xaa, 0x14, 0xaa},
 	{0x00, 0x13, 0xe5, 0xaa},	{0x00, 0x0e, 0x61, 0xaa},
 	{0x00, 0x0f, 0x4b, 0xaa},	{0x00, 0x16, 0x02, 0xaa},
-	{0x00, 0x1e, 0x07, 0xaa},	{0x00, 0x21, 0x02, 0xaa},
+	{0x00, 0x1e, 0x07, 0xaa},	/* MVFP */
+	{0x00, 0x21, 0x02, 0xaa},
 	{0x00, 0x22, 0x91, 0xaa},	{0x00, 0x29, 0x07, 0xaa},
 	{0x00, 0x33, 0x0b, 0xaa},	{0x00, 0x35, 0x0b, 0xaa},
 	{0x00, 0x37, 0x1d, 0xaa},	{0x00, 0x38, 0x71, 0xaa},
@@ -1175,7 +1464,8 @@
 	{0x00, 0x71, 0x35, 0xaa},	{0x00, 0x72, 0x11, 0xaa},
 	{0x00, 0x73, 0xf0, 0xaa},	{0x00, 0xa2, 0x02, 0xaa},
 	{0x00, 0xb1, 0x00, 0xaa},	{0x00, 0xb1, 0x0c, 0xaa},
-	{0x00, 0x1e, 0x37, 0xaa},	{0x00, 0xaa, 0x14, 0xaa},
+	{0x00, 0x1e, 0x37, 0xaa},	/* MVFP */
+	{0x00, 0xaa, 0x14, 0xaa},
 	{0x00, 0x24, 0x80, 0xaa},	{0x00, 0x25, 0x74, 0xaa},
 	{0x00, 0x26, 0xd3, 0xaa},	{0x00, 0x0d, 0x00, 0xaa},
 	{0x00, 0x14, 0x18, 0xaa},	{0x00, 0x9d, 0x99, 0xaa},
@@ -1204,6 +1494,301 @@
 	{},
 };
 
+/* PO1200 - values from usbvm326.inf and ms-win trace */
+static const __u8 po1200_gamma[17] = {
+#if 1
+	0x00, 0x13, 0x38, 0x59, 0x79, 0x92, 0xa7, 0xb9, 0xc8,
+	0xd4, 0xdf, 0xe7, 0xee, 0xf4, 0xf9, 0xfc, 0xff
+#else
+/*ms-win trace*/
+	0x01, 0x0b, 0x1e, 0x38, 0x51, 0x6b, 0x83, 0x9a, 0xaf,
+	0xc1, 0xd0, 0xdd, 0xe8, 0xf2, 0xf9, 0xff, 0xff
+#endif
+};
+static const __u8 po1200_matrix[9] = {
+	0x60, 0xf9, 0xe5, 0xe7, 0x50, 0x05, 0xf3, 0xe6, 0x5e
+};
+static const __u8 po1200_initVGA_data[][4] = {
+	{0xb0, 0x03, 0x19, 0xcc},	/* reset? */
+#if 0
+	{0x00, 0x00, 0x64, 0xdd},
+	{0xb3, 0x49, 0x11, 0xcc},
+	{0x00, 0x00, 0x33, 0xdd},
+/*read b349*/
+#endif
+	{0xb0, 0x03, 0x19, 0xcc},
+/*	{0x00, 0x00, 0x33, 0xdd}, */
+	{0xb0, 0x04, 0x02, 0xcc},
+	{0xb0, 0x02, 0x02, 0xcc},
+	{0xb3, 0x5d, 0x00, 0xcc},
+	{0xb3, 0x01, 0x01, 0xcc},
+	{0xb3, 0x00, 0x64, 0xcc},
+	{0xb3, 0x00, 0x65, 0xcc},
+	{0xb3, 0x05, 0x01, 0xcc},
+	{0xb3, 0x06, 0x01, 0xcc},
+	{0xb3, 0x5c, 0x01, 0xcc},
+	{0xb3, 0x08, 0x01, 0xcc},
+	{0xb3, 0x09, 0x0c, 0xcc},
+	{0xb3, 0x00, 0x67, 0xcc},
+	{0xb3, 0x02, 0xb2, 0xcc},
+	{0xb3, 0x03, 0x18, 0xcc},
+	{0xb3, 0x04, 0x15, 0xcc},
+	{0xb3, 0x20, 0x00, 0xcc},
+	{0xb3, 0x21, 0x00, 0xcc},
+	{0xb3, 0x22, 0x02, 0xcc},
+	{0xb3, 0x23, 0x58, 0xcc},
+	{0xb3, 0x14, 0x00, 0xcc},
+	{0xb3, 0x15, 0x00, 0xcc},
+	{0xb3, 0x16, 0x03, 0xcc},
+	{0xb3, 0x17, 0x1f, 0xcc},
+	{0xbc, 0x00, 0x71, 0xcc},
+	{0xbc, 0x01, 0x01, 0xcc},
+	{0xb0, 0x54, 0x13, 0xcc},
+	{0xb3, 0x00, 0x67, 0xcc},
+	{0xb3, 0x34, 0x01, 0xcc},
+	{0xb3, 0x35, 0xdc, 0xcc},
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x12, 0x05, 0xaa},
+	{0x00, 0x13, 0x02, 0xaa},
+	{0x00, 0x1e, 0xc6, 0xaa},	/* h/v flip */
+	{0x00, 0x21, 0x00, 0xaa},
+	{0x00, 0x25, 0x02, 0xaa},
+	{0x00, 0x3c, 0x4f, 0xaa},
+	{0x00, 0x3f, 0xe0, 0xaa},
+	{0x00, 0x42, 0xff, 0xaa},
+	{0x00, 0x45, 0x34, 0xaa},
+	{0x00, 0x55, 0xfe, 0xaa},
+	{0x00, 0x59, 0xd3, 0xaa},
+	{0x00, 0x5e, 0x04, 0xaa},
+	{0x00, 0x61, 0xb8, 0xaa},	/* sharpness */
+	{0x00, 0x62, 0x02, 0xaa},
+	{0x00, 0xa7, 0x31, 0xaa},
+	{0x00, 0xa9, 0x66, 0xaa},
+	{0x00, 0xb0, 0x00, 0xaa},
+	{0x00, 0xb1, 0x00, 0xaa},
+	{0x00, 0xb3, 0x11, 0xaa},
+	{0x00, 0xb6, 0x26, 0xaa},
+	{0x00, 0xb7, 0x20, 0xaa},
+	{0x00, 0xba, 0x04, 0xaa},
+	{0x00, 0x88, 0x42, 0xaa},
+	{0x00, 0x89, 0x9a, 0xaa},
+	{0x00, 0x8a, 0x88, 0xaa},
+	{0x00, 0x8b, 0x8e, 0xaa},
+	{0x00, 0x8c, 0x3e, 0xaa},
+	{0x00, 0x8d, 0x90, 0xaa},
+	{0x00, 0x8e, 0x87, 0xaa},
+	{0x00, 0x8f, 0x96, 0xaa},
+	{0x00, 0x90, 0x3d, 0xaa},
+	{0x00, 0x64, 0x00, 0xaa},
+	{0x00, 0x65, 0x10, 0xaa},
+	{0x00, 0x66, 0x20, 0xaa},
+	{0x00, 0x67, 0x2b, 0xaa},
+	{0x00, 0x68, 0x36, 0xaa},
+	{0x00, 0x69, 0x49, 0xaa},
+	{0x00, 0x6a, 0x5a, 0xaa},
+	{0x00, 0x6b, 0x7f, 0xaa},
+	{0x00, 0x6c, 0x9b, 0xaa},
+	{0x00, 0x6d, 0xba, 0xaa},
+	{0x00, 0x6e, 0xd4, 0xaa},
+	{0x00, 0x6f, 0xea, 0xaa},
+	{0x00, 0x70, 0x00, 0xaa},
+	{0x00, 0x71, 0x10, 0xaa},
+	{0x00, 0x72, 0x20, 0xaa},
+	{0x00, 0x73, 0x2b, 0xaa},
+	{0x00, 0x74, 0x36, 0xaa},
+	{0x00, 0x75, 0x49, 0xaa},
+	{0x00, 0x76, 0x5a, 0xaa},
+	{0x00, 0x77, 0x7f, 0xaa},
+	{0x00, 0x78, 0x9b, 0xaa},
+	{0x00, 0x79, 0xba, 0xaa},
+	{0x00, 0x7a, 0xd4, 0xaa},
+	{0x00, 0x7b, 0xea, 0xaa},
+	{0x00, 0x7c, 0x00, 0xaa},
+	{0x00, 0x7d, 0x10, 0xaa},
+	{0x00, 0x7e, 0x20, 0xaa},
+	{0x00, 0x7f, 0x2b, 0xaa},
+	{0x00, 0x80, 0x36, 0xaa},
+	{0x00, 0x81, 0x49, 0xaa},
+	{0x00, 0x82, 0x5a, 0xaa},
+	{0x00, 0x83, 0x7f, 0xaa},
+	{0x00, 0x84, 0x9b, 0xaa},
+	{0x00, 0x85, 0xba, 0xaa},
+	{0x00, 0x86, 0xd4, 0xaa},
+	{0x00, 0x87, 0xea, 0xaa},
+	{0x00, 0x57, 0x2a, 0xaa},
+	{0x00, 0x03, 0x01, 0xaa},
+	{0x00, 0x04, 0x10, 0xaa},
+	{0x00, 0x05, 0x10, 0xaa},
+	{0x00, 0x06, 0x10, 0xaa},
+	{0x00, 0x07, 0x10, 0xaa},
+	{0x00, 0x08, 0x13, 0xaa},
+	{0x00, 0x0a, 0x00, 0xaa},
+	{0x00, 0x0b, 0x10, 0xaa},
+	{0x00, 0x0c, 0x20, 0xaa},
+	{0x00, 0x0d, 0x18, 0xaa},
+	{0x00, 0x22, 0x01, 0xaa},
+	{0x00, 0x23, 0x60, 0xaa},
+	{0x00, 0x25, 0x08, 0xaa},
+	{0x00, 0x26, 0x82, 0xaa},
+	{0x00, 0x2e, 0x0f, 0xaa},
+	{0x00, 0x2f, 0x1e, 0xaa},
+	{0x00, 0x30, 0x2d, 0xaa},
+	{0x00, 0x31, 0x3c, 0xaa},
+	{0x00, 0x32, 0x4b, 0xaa},
+	{0x00, 0x33, 0x5a, 0xaa},
+	{0x00, 0x34, 0x69, 0xaa},
+	{0x00, 0x35, 0x78, 0xaa},
+	{0x00, 0x36, 0x87, 0xaa},
+	{0x00, 0x37, 0x96, 0xaa},
+	{0x00, 0x38, 0xa5, 0xaa},
+	{0x00, 0x39, 0xb4, 0xaa},
+	{0x00, 0x3a, 0xc3, 0xaa},
+	{0x00, 0x3b, 0xd2, 0xaa},
+	{0x00, 0x3c, 0xe1, 0xaa},
+	{0x00, 0x3e, 0xff, 0xaa},
+	{0x00, 0x3f, 0xff, 0xaa},
+	{0x00, 0x40, 0xff, 0xaa},
+	{0x00, 0x41, 0xff, 0xaa},
+	{0x00, 0x42, 0xff, 0xaa},
+	{0x00, 0x43, 0xff, 0xaa},
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x20, 0xc4, 0xaa},
+	{0x00, 0x13, 0x03, 0xaa},
+	{0x00, 0x3c, 0x50, 0xaa},
+	{0x00, 0x61, 0x6a, 0xaa},	/* sharpness? */
+	{0x00, 0x51, 0x5b, 0xaa},
+	{0x00, 0x52, 0x91, 0xaa},
+	{0x00, 0x53, 0x4c, 0xaa},
+	{0x00, 0x54, 0x50, 0xaa},
+	{0x00, 0x56, 0x02, 0xaa},
+	{0xb6, 0x00, 0x00, 0xcc},
+	{0xb6, 0x03, 0x03, 0xcc},
+	{0xb6, 0x02, 0x20, 0xcc},
+	{0xb6, 0x05, 0x02, 0xcc},
+	{0xb6, 0x04, 0x58, 0xcc},
+	{0xb6, 0x12, 0xf8, 0xcc},
+	{0xb6, 0x13, 0x21, 0xcc},
+	{0xb6, 0x18, 0x03, 0xcc},
+	{0xb6, 0x17, 0xa9, 0xcc},
+	{0xb6, 0x16, 0x80, 0xcc},
+	{0xb6, 0x22, 0x12, 0xcc},
+	{0xb6, 0x23, 0x0b, 0xcc},
+	{0xbf, 0xc0, 0x39, 0xcc},
+	{0xbf, 0xc1, 0x04, 0xcc},
+	{0xbf, 0xcc, 0x00, 0xcc},
+	{0xb8, 0x06, 0x20, 0xcc},
+	{0xb8, 0x07, 0x03, 0xcc},
+	{0xb8, 0x08, 0x58, 0xcc},
+	{0xb8, 0x09, 0x02, 0xcc},
+	{0xb3, 0x01, 0x41, 0xcc},
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0xd9, 0x0f, 0xaa},
+	{0x00, 0xda, 0xaa, 0xaa},
+	{0x00, 0xd9, 0x10, 0xaa},
+	{0x00, 0xda, 0xaa, 0xaa},
+	{0x00, 0xd9, 0x11, 0xaa},
+	{0x00, 0xda, 0x00, 0xaa},
+	{0x00, 0xd9, 0x12, 0xaa},
+	{0x00, 0xda, 0xff, 0xaa},
+	{0x00, 0xd9, 0x13, 0xaa},
+	{0x00, 0xda, 0xff, 0xaa},
+	{0x00, 0xe8, 0x11, 0xaa},
+	{0x00, 0xe9, 0x12, 0xaa},
+	{0x00, 0xea, 0x5c, 0xaa},
+	{0x00, 0xeb, 0xff, 0xaa},
+	{0x00, 0xd8, 0x80, 0xaa},
+	{0x00, 0xe6, 0x02, 0xaa},
+	{0x00, 0xd6, 0x40, 0xaa},
+	{0x00, 0xe3, 0x05, 0xaa},
+	{0x00, 0xe0, 0x40, 0xaa},
+	{0x00, 0xde, 0x03, 0xaa},
+	{0x00, 0xdf, 0x03, 0xaa},
+	{0x00, 0xdb, 0x02, 0xaa},
+	{0x00, 0xdc, 0x00, 0xaa},
+	{0x00, 0xdd, 0x03, 0xaa},
+	{0x00, 0xe1, 0x08, 0xaa},
+	{0x00, 0xe2, 0x01, 0xaa},
+	{0x00, 0xd6, 0x40, 0xaa},
+	{0x00, 0xe4, 0x40, 0xaa},
+#if 1
+	{0x00, 0xa8, 0x8f, 0xaa},
+#else
+/*modified later*/
+	{0x00, 0xa8, 0x9f, 0xaa},
+#endif
+	{0x00, 0xb4, 0x16, 0xaa},
+	{0xb0, 0x02, 0x06, 0xcc},
+	{0xb0, 0x18, 0x06, 0xcc},
+	{0xb0, 0x19, 0x06, 0xcc},
+	{0xb3, 0x5d, 0x18, 0xcc},
+	{0xb3, 0x05, 0x00, 0xcc},
+	{0xb3, 0x06, 0x00, 0xcc},
+	{0x00, 0xb4, 0x0e, 0xaa},
+	{0x00, 0xb5, 0x49, 0xaa},
+	{0x00, 0xb6, 0x1c, 0xaa},
+	{0x00, 0xb7, 0x96, 0xaa},
+/* end of usbvm326.inf - start of ms-win trace */
+	{0xb6, 0x12, 0xf8, 0xcc},
+	{0xb6, 0x13, 0x3d, 0xcc},
+/*read b306*/
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x1a, 0x09, 0xaa},
+	{0x00, 0x1b, 0x8a, 0xaa},
+/*read b827*/
+	{0xb8, 0x27, 0x00, 0xcc},
+	{0xb8, 0x26, 0x60, 0xcc},
+	{0xb8, 0x26, 0x60, 0xcc},
+/*gamma - to do?*/
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0xae, 0x84, 0xaa},
+/*gamma again*/
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x96, 0xa0, 0xaa},
+/*matrix*/
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x91, 0x35, 0xaa},
+	{0x00, 0x92, 0x22, 0xaa},
+/*gamma*/
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x95, 0x85, 0xaa},
+/*matrix*/
+#if 0
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x61, 0xb8, 0xaa},	/* sharpness */
+#endif
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x4d, 0x20, 0xaa},
+	{0xb8, 0x22, 0x40, 0xcc},
+	{0xb8, 0x23, 0x40, 0xcc},
+	{0xb8, 0x24, 0x40, 0xcc},
+	{0xb8, 0x81, 0x09, 0xcc},
+	{0x00, 0x00, 0x64, 0xdd},
+	{0x00, 0x03, 0x01, 0xaa},
+/*read 46*/
+	{0x00, 0x46, 0x3c, 0xaa},
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x16, 0x40, 0xaa},
+	{0x00, 0x17, 0x40, 0xaa},
+	{0x00, 0x18, 0x40, 0xaa},
+	{0x00, 0x19, 0x41, 0xaa},
+	{0x00, 0x03, 0x01, 0xaa},
+	{0x00, 0x46, 0x3c, 0xaa},
+	{0x00, 0x00, 0x18, 0xdd},
+/*read bfff*/
+#if 0
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0x1e, 0x46, 0xaa},	/* h/v flip */
+	{0x00, 0xa8, 0x8f, 0xaa},
+#endif
+	{0x00, 0x03, 0x00, 0xaa},
+	{0x00, 0xb4, 0x1c, 0xaa},
+	{0x00, 0xb5, 0x92, 0xaa},
+	{0x00, 0xb6, 0x39, 0xaa},
+	{0x00, 0xb7, 0x24, 0xaa},
+/*write 89 0400 1415*/
+};
+
 struct sensor_info {
 	int sensorId;
 	__u8 I2cAdd;
@@ -1222,6 +1807,9 @@
 	{SENSOR_MI1320,     0x80 | 0xc8, 0x00, 0x148c, 0x64, 0x65, 0x01},
 	{SENSOR_OV7670,     0x80 | 0x21, 0x0a, 0x7673, 0x66, 0x67, 0x05},
 	{SENSOR_MI1310_SOC, 0x80 | 0x5d, 0x00, 0x143a, 0x24, 0x25, 0x01},
+/* (tested in vc032x_probe_sensor) */
+/*	{SENSOR_MI0360,	    0x80 | 0x5d, 0x00, 0x8243, 0x24, 0x25, 0x01}, */
+	{SENSOR_PO1200,     0x80 | 0x5c, 0x00, 0x1200, 0x67, 0x67, 0x01},
 };
 
 /* read 'len' bytes in gspca_dev->usb_buf */
@@ -1278,18 +1866,18 @@
 		msleep(1);
 	}
 	reg_r(gspca_dev, 0xa1, 0xb33e, 1);
-	hdata = gspca_dev->usb_buf[0];
+	ldata = gspca_dev->usb_buf[0];
 	reg_r(gspca_dev, 0xa1, 0xb33d, 1);
 	mdata = gspca_dev->usb_buf[0];
 	reg_r(gspca_dev, 0xa1, 0xb33c, 1);
-	ldata = gspca_dev->usb_buf[0];
-	PDEBUG(D_PROBE, "Read Sensor h (0x%02X) m (0x%02X) l (0x%02X)",
+	hdata = gspca_dev->usb_buf[0];
+	PDEBUG(D_PROBE, "Read Sensor %02x%02x %02x",
 		hdata, mdata, ldata);
 	reg_r(gspca_dev, 0xa1, 0xb334, 1);
 	if (gspca_dev->usb_buf[0] == 0x02)
-		*value = (ldata << 8) + mdata;
+		*value = (hdata << 8) + mdata;
 	else
-		*value = ldata;
+		*value = hdata;
 }
 
 static int vc032x_probe_sensor(struct gspca_dev *gspca_dev)
@@ -1300,7 +1888,7 @@
 	const struct sensor_info *ptsensor_info;
 
 	reg_r(gspca_dev, 0xa1, 0xbfcf, 1);
-	PDEBUG(D_PROBE, "check sensor header %d", gspca_dev->usb_buf[0]);
+	PDEBUG(D_PROBE, "check sensor header %02x", gspca_dev->usb_buf[0]);
 	for (i = 0; i < ARRAY_SIZE(sensor_info_data); i++) {
 		ptsensor_info = &sensor_info_data[i];
 		reg_w(dev, 0xa0, 0x02, 0xb334);
@@ -1309,16 +1897,15 @@
 		reg_w(dev, 0xa0, 0x01, 0xb308);
 		reg_w(dev, 0xa0, 0x0c, 0xb309);
 		reg_w(dev, 0xa0, ptsensor_info->I2cAdd, 0xb335);
-/*		PDEBUG(D_PROBE,
-			"check sensor VC032X -> %d Add -> ox%02X!",
-			i, ptsensor_info->I2cAdd); */
 		reg_w(dev, 0xa0, ptsensor_info->op, 0xb301);
 		read_sensor_register(gspca_dev, ptsensor_info->IdAdd, &value);
-		if (value == ptsensor_info->VpId) {
-/*			PDEBUG(D_PROBE, "find sensor VC032X -> ox%04X!",
-				ptsensor_info->VpId); */
+		if (value == ptsensor_info->VpId)
 			return ptsensor_info->sensorId;
-		}
+
+		/* special case for MI0360 */
+		if (ptsensor_info->sensorId == SENSOR_MI1310_SOC
+		    && value == 0x8243)
+			return SENSOR_MI0360;
 	}
 	return -1;
 }
@@ -1420,13 +2007,6 @@
 	cam = &gspca_dev->cam;
 	cam->epaddr = 0x02;
 	sd->bridge = id->driver_info;
-	if (sd->bridge == BRIDGE_VC0321) {
-		cam->cam_mode = vc0321_mode;
-		cam->nmodes = ARRAY_SIZE(vc0321_mode);
-	} else {
-		cam->cam_mode = vc0323_mode;
-		cam->nmodes = ARRAY_SIZE(vc0323_mode);
-	}
 
 	vc0321_reset(gspca_dev);
 	sensor = vc032x_probe_sensor(gspca_dev);
@@ -1436,35 +2016,66 @@
 		return -EINVAL;
 	case SENSOR_HV7131R:
 		PDEBUG(D_PROBE, "Find Sensor HV7131R");
-		sd->sensor = SENSOR_HV7131R;
+		break;
+	case SENSOR_MI0360:
+		PDEBUG(D_PROBE, "Find Sensor MI0360");
+		sd->bridge = BRIDGE_VC0323;
 		break;
 	case SENSOR_MI1310_SOC:
 		PDEBUG(D_PROBE, "Find Sensor MI1310_SOC");
-		sd->sensor = SENSOR_MI1310_SOC;
 		break;
 	case SENSOR_MI1320:
 		PDEBUG(D_PROBE, "Find Sensor MI1320");
-		sd->sensor = SENSOR_MI1320;
 		break;
 	case SENSOR_OV7660:
 		PDEBUG(D_PROBE, "Find Sensor OV7660");
-		sd->sensor = SENSOR_OV7660;
 		break;
 	case SENSOR_OV7670:
 		PDEBUG(D_PROBE, "Find Sensor OV7670");
-		sd->sensor = SENSOR_OV7670;
+		break;
+	case SENSOR_PO1200:
+		PDEBUG(D_PROBE, "Find Sensor PO1200");
 		break;
 	case SENSOR_PO3130NC:
 		PDEBUG(D_PROBE, "Find Sensor PO3130NC");
-		sd->sensor = SENSOR_PO3130NC;
 		break;
 	}
+	sd->sensor = sensor;
 
-	sd->qindex = 7;
-	sd->autogain = AUTOGAIN_DEF;
+	if (sd->bridge == BRIDGE_VC0321) {
+		cam->cam_mode = vc0321_mode;
+		cam->nmodes = ARRAY_SIZE(vc0321_mode);
+	} else {
+		if (sensor != SENSOR_PO1200) {
+			cam->cam_mode = vc0323_mode;
+			cam->nmodes = ARRAY_SIZE(vc0323_mode);
+		} else {
+			cam->cam_mode = svga_mode;
+			cam->nmodes = ARRAY_SIZE(svga_mode);
+		}
+	}
+
+	sd->hflip = HFLIP_DEF;
+	sd->vflip = VFLIP_DEF;
+	if (sd->sensor == SENSOR_OV7670) {
+		sd->hflip = 1;
+		sd->vflip = 1;
+	}
 	sd->lightfreq = FREQ_DEF;
 	if (sd->sensor != SENSOR_OV7670)
 		gspca_dev->ctrl_dis = (1 << LIGHTFREQ_IDX);
+	switch (sd->sensor) {
+	case SENSOR_OV7660:
+	case SENSOR_OV7670:
+	case SENSOR_PO1200:
+		break;
+	default:
+		gspca_dev->ctrl_dis = (1 << HFLIP_IDX)
+					| (1 << VFLIP_IDX);
+		break;
+	}
+
+	sd->sharpness = SHARPNESS_DEF;
 
 	if (sd->bridge == BRIDGE_VC0321) {
 		reg_r(gspca_dev, 0x8a, 0, 3);
@@ -1482,12 +2093,33 @@
 	return 0;
 }
 
-static void setquality(struct gspca_dev *gspca_dev)
+/* for OV7660 and OV7670 only */
+static void sethvflip(struct gspca_dev *gspca_dev)
 {
-}
+	struct sd *sd = (struct sd *) gspca_dev;
+	__u8 data;
 
-static void setautogain(struct gspca_dev *gspca_dev)
-{
+	switch (sd->sensor) {
+	case SENSOR_OV7660:
+		data = 1;
+		break;
+	case SENSOR_OV7670:
+		data = 7;
+		break;
+	case SENSOR_PO1200:
+		data = 0;
+		i2c_write(gspca_dev, 0x03, &data, 1);
+		data = 0x80 * sd->hflip
+			| 0x40 * sd->vflip
+			| 0x06;
+		i2c_write(gspca_dev, 0x1e, &data, 1);
+		return;
+	default:
+		return;
+	}
+	data |= OV7660_MVFP_MIRROR * sd->hflip
+		| OV7660_MVFP_VFLIP * sd->vflip;
+	i2c_write(gspca_dev, OV7660_REG_MVFP, &data, 1);
 }
 
 static void setlightfreq(struct gspca_dev *gspca_dev)
@@ -1501,6 +2133,20 @@
 	usb_exchange(gspca_dev, ov7660_freq_tb[sd->lightfreq]);
 }
 
+/* po1200 only */
+static void setsharpness(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	__u8 data;
+
+	if (sd->sensor != SENSOR_PO1200)
+		return;
+	data = 0;
+	i2c_write(gspca_dev, 0x03, &data, 1);
+	data = 0xb5 + sd->sharpness * 3;
+	i2c_write(gspca_dev, 0x61, &data, 1);
+}
+
 static int sd_start(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
@@ -1551,6 +2197,17 @@
 			usb_exchange(gspca_dev, ov7670_initVGA_JPG);
 		}
 		break;
+	case SENSOR_MI0360:
+		GammaT = mi1320_gamma;
+		MatrixT = mi0360_matrix;
+		if (mode) {
+			/* 320x240 */
+			usb_exchange(gspca_dev, mi0360_initQVGA_JPG);
+		} else {
+			/* 640x480 */
+			usb_exchange(gspca_dev, mi0360_initVGA_JPG);
+		}
+		break;
 	case SENSOR_MI1310_SOC:
 		if (mode) {
 			/* 320x240 */
@@ -1583,6 +2240,11 @@
 		}
 		usb_exchange(gspca_dev, po3130_rundata);
 		break;
+	case SENSOR_PO1200:
+		GammaT = po1200_gamma;
+		MatrixT = po1200_matrix;
+		usb_exchange(gspca_dev, po1200_initVGA_data);
+		break;
 	default:
 		PDEBUG(D_PROBE, "Damned !! no sensor found Bye");
 		return -EMEDIUMTYPE;
@@ -1615,11 +2277,16 @@
 		reg_w(gspca_dev->dev, 0xa0, 0x23, 0xb800); * ISP CTRL_BAS
 		*/
 		/* set the led on 0x0892 0x0896 */
-		reg_w(gspca_dev->dev, 0x89, 0xffff, 0xfdff);
-		msleep(100);
-		setquality(gspca_dev);
-		setautogain(gspca_dev);
-		setlightfreq(gspca_dev);
+		if (sd->sensor != SENSOR_PO1200) {
+			reg_w(gspca_dev->dev, 0x89, 0xffff, 0xfdff);
+			msleep(100);
+			sethvflip(gspca_dev);
+			setlightfreq(gspca_dev);
+		} else {
+			setsharpness(gspca_dev);
+			sethvflip(gspca_dev);
+			reg_w(gspca_dev->dev, 0x89, 0x0400, 0x1415);
+		}
 	}
 	return 0;
 }
@@ -1665,24 +2332,48 @@
 				data, len);
 		return;
 	}
+
+	/* The vc0321 sends some additional data after sending the complete
+	 * frame, we ignore this. */
+	if (sd->bridge == BRIDGE_VC0321
+	    && len > frame->v4l2_buf.length - (frame->data_end - frame->data))
+		len = frame->v4l2_buf.length - (frame->data_end - frame->data);
 	gspca_frame_add(gspca_dev, INTER_PACKET, frame, data, len);
 }
 
-static int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)
+static int sd_sethflip(struct gspca_dev *gspca_dev, __s32 val)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	sd->autogain = val;
+	sd->hflip = val;
 	if (gspca_dev->streaming)
-		setautogain(gspca_dev);
+		sethvflip(gspca_dev);
+	return 0;
+}
+
+static int sd_gethflip(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->hflip;
 	return 0;
 }
 
-static int sd_getautogain(struct gspca_dev *gspca_dev, __s32 *val)
+static int sd_setvflip(struct gspca_dev *gspca_dev, __s32 val)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	*val = sd->autogain;
+	sd->vflip = val;
+	if (gspca_dev->streaming)
+		sethvflip(gspca_dev);
+	return 0;
+}
+
+static int sd_getvflip(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->vflip;
 	return 0;
 }
 
@@ -1704,6 +2395,24 @@
 	return 0;
 }
 
+static int sd_setsharpness(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd->sharpness = val;
+	if (gspca_dev->streaming)
+		setsharpness(gspca_dev);
+	return 0;
+}
+
+static int sd_getsharpness(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd->sharpness;
+	return 0;
+}
+
 static int sd_querymenu(struct gspca_dev *gspca_dev,
 			struct v4l2_querymenu *menu)
 {
@@ -1748,6 +2457,7 @@
 	{USB_DEVICE(0x0ac8, 0x0328), .driver_info = BRIDGE_VC0321},
 	{USB_DEVICE(0x0ac8, 0xc001), .driver_info = BRIDGE_VC0321},
 	{USB_DEVICE(0x0ac8, 0xc002), .driver_info = BRIDGE_VC0321},
+	{USB_DEVICE(0x15b8, 0x6002), .driver_info = BRIDGE_VC0323},
 	{USB_DEVICE(0x17ef, 0x4802), .driver_info = BRIDGE_VC0323},
 	{}
 };
diff -urN linux/drivers/media/video/gspca/zc3xx-reg.h linux/drivers/media/video/gspca/zc3xx-reg.h
--- linux/drivers/media/video/gspca/zc3xx-reg.h	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/zc3xx-reg.h	2008-12-09 21:37:33.000000000 +0100
@@ -244,14 +244,6 @@
 #define ZC3XX_R1CA_SHARPNESS04         0x01ca
 #define ZC3XX_R1CB_SHARPNESS05         0x01cb
 
-/* Synchronization */
-#define ZC3XX_R190_SYNC00LOW           0x0190
-#define ZC3XX_R191_SYNC00MID           0x0191
-#define ZC3XX_R192_SYNC00HIGH          0x0192
-#define ZC3XX_R195_SYNC01LOW           0x0195
-#define ZC3XX_R196_SYNC01MID           0x0196
-#define ZC3XX_R197_SYNC01HIGH          0x0197
-
 /* Dead pixels */
 #define ZC3XX_R250_DEADPIXELSMODE      0x0250
 
diff -urN linux/drivers/media/video/gspca/zc3xx.c linux/drivers/media/video/gspca/zc3xx.c
--- linux/drivers/media/video/gspca/zc3xx.c	2008-12-25 00:26:37.000000000 +0100
+++ linux/drivers/media/video/gspca/zc3xx.c	2008-12-09 21:37:33.000000000 +0100
@@ -51,16 +51,16 @@
 #define SENSOR_CS2102 0
 #define SENSOR_CS2102K 1
 #define SENSOR_GC0305 2
-#define SENSOR_HDCS2020 3
-#define SENSOR_HDCS2020b 4
-#define SENSOR_HV7131B 5
-#define SENSOR_HV7131C 6
-#define SENSOR_ICM105A 7
-#define SENSOR_MC501CB 8
-#define SENSOR_OV7620 9
-/*#define SENSOR_OV7648 9 - same values */
-#define SENSOR_OV7630C 10
-#define SENSOR_PAS106 11
+#define SENSOR_HDCS2020b 3
+#define SENSOR_HV7131B 4
+#define SENSOR_HV7131C 5
+#define SENSOR_ICM105A 6
+#define SENSOR_MC501CB 7
+#define SENSOR_OV7620 8
+/*#define SENSOR_OV7648 8 - same values */
+#define SENSOR_OV7630C 9
+#define SENSOR_PAS106 10
+#define SENSOR_PAS202B 11
 #define SENSOR_PB0330 12
 #define SENSOR_PO2030 13
 #define SENSOR_TAS5130CK 14
@@ -1653,295 +1653,6 @@
 	{}
 };
 
-/* play poker with registers at your own risk !! */
-static const struct usb_action hdcs2020xx_Initial[] = {
-	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},
-	{0xa0, 0x0e, ZC3XX_R010_CMOSSENSORSELECT},
-	{0xa0, 0x10, ZC3XX_R002_CLOCKSELECT},
-	{0xa0, 0x02, ZC3XX_R003_FRAMEWIDTHHIGH},
-	{0xa0, 0x80, ZC3XX_R004_FRAMEWIDTHLOW},
-	{0xa0, 0x01, ZC3XX_R005_FRAMEHEIGHTHIGH},
-	{0xa0, 0xd0, ZC3XX_R006_FRAMEHEIGHTLOW},
-						/* D0 ?? E0 did not start */
-	{0xa0, 0x01, ZC3XX_R001_SYSTEMOPERATING},
-	{0xa0, 0x03, ZC3XX_R012_VIDEOCONTROLFUNC},
-	{0xa0, 0x01, ZC3XX_R012_VIDEOCONTROLFUNC},
-	{0xa0, 0x08, ZC3XX_R08D_COMPABILITYMODE},
-	{0xa0, 0x08, ZC3XX_R098_WINYSTARTLOW},
-	{0xa0, 0x02, ZC3XX_R09A_WINXSTARTLOW},
-	{0xa0, 0x08, ZC3XX_R11A_FIRSTYLOW},
-	{0xa0, 0x02, ZC3XX_R11C_FIRSTXLOW},
-	{0xa0, 0x01, ZC3XX_R09B_WINHEIGHTHIGH},
-	{0xa0, 0xd8, ZC3XX_R09C_WINHEIGHTLOW},
-	{0xa0, 0x02, ZC3XX_R09D_WINWIDTHHIGH},
-	{0xa0, 0x88, ZC3XX_R09E_WINWIDTHLOW},
-	{0xaa, 0x02, 0x0002},
-	{0xaa, 0x07, 0x0006},
-	{0xaa, 0x08, 0x0002},
-	{0xaa, 0x09, 0x0006},
-	{0xaa, 0x0a, 0x0001},
-	{0xaa, 0x0b, 0x0001},
-	{0xaa, 0x0c, 0x0008},
-	{0xaa, 0x0d, 0x0000},
-	{0xaa, 0x10, 0x0000},
-	{0xaa, 0x12, 0x0005},
-	{0xaa, 0x13, 0x0063},
-	{0xaa, 0x15, 0x0070},
-	{0xa0, 0x37, ZC3XX_R101_SENSORCORRECTION},
-	{0xa0, 0x0d, ZC3XX_R100_OPERATIONMODE},
-	{0xa0, 0x06, ZC3XX_R189_AWBSTATUS},
-	{0xa0, 0x00, 0x01ad},
-	{0xa0, 0x03, ZC3XX_R1C5_SHARPNESSMODE},
-	{0xa0, 0x13, ZC3XX_R1CB_SHARPNESS05},
-	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},
-	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},
-	{0xa0, 0x70, ZC3XX_R18D_YTARGET},
-	{0xa1, 0x01, 0x0002},
-	{0xa1, 0x01, 0x0008},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},	/* clock ? */
-	{0xa0, 0x04, ZC3XX_R1C6_SHARPNESS00},	/* sharpness+ */
-	{0xa1, 0x01, 0x01c8},
-	{0xa1, 0x01, 0x01c9},
-	{0xa1, 0x01, 0x01ca},
-	{0xa0, 0x07, ZC3XX_R1CB_SHARPNESS05},	/* sharpness- */
-	{0xa0, 0x11, ZC3XX_R120_GAMMA00},	/* gamma ~4 */
-	{0xa0, 0x37, ZC3XX_R121_GAMMA01},
-	{0xa0, 0x58, ZC3XX_R122_GAMMA02},
-	{0xa0, 0x79, ZC3XX_R123_GAMMA03},
-	{0xa0, 0x91, ZC3XX_R124_GAMMA04},
-	{0xa0, 0xa6, ZC3XX_R125_GAMMA05},
-	{0xa0, 0xb8, ZC3XX_R126_GAMMA06},
-	{0xa0, 0xc7, ZC3XX_R127_GAMMA07},
-	{0xa0, 0xd3, ZC3XX_R128_GAMMA08},
-	{0xa0, 0xde, ZC3XX_R129_GAMMA09},
-	{0xa0, 0xe6, ZC3XX_R12A_GAMMA0A},
-	{0xa0, 0xed, ZC3XX_R12B_GAMMA0B},
-	{0xa0, 0xf3, ZC3XX_R12C_GAMMA0C},
-	{0xa0, 0xf8, ZC3XX_R12D_GAMMA0D},
-	{0xa0, 0xfb, ZC3XX_R12E_GAMMA0E},
-	{0xa0, 0xff, ZC3XX_R12F_GAMMA0F},
-	{0xa0, 0x26, ZC3XX_R130_GAMMA10},
-	{0xa0, 0x23, ZC3XX_R131_GAMMA11},
-	{0xa0, 0x20, ZC3XX_R132_GAMMA12},
-	{0xa0, 0x1c, ZC3XX_R133_GAMMA13},
-	{0xa0, 0x16, ZC3XX_R134_GAMMA14},
-	{0xa0, 0x13, ZC3XX_R135_GAMMA15},
-	{0xa0, 0x10, ZC3XX_R136_GAMMA16},
-	{0xa0, 0x0d, ZC3XX_R137_GAMMA17},
-	{0xa0, 0x0b, ZC3XX_R138_GAMMA18},
-	{0xa0, 0x09, ZC3XX_R139_GAMMA19},
-	{0xa0, 0x07, ZC3XX_R13A_GAMMA1A},
-	{0xa0, 0x06, ZC3XX_R13B_GAMMA1B},
-	{0xa0, 0x05, ZC3XX_R13C_GAMMA1C},
-	{0xa0, 0x04, ZC3XX_R13D_GAMMA1D},
-	{0xa0, 0x03, ZC3XX_R13E_GAMMA1E},
-	{0xa0, 0x02, ZC3XX_R13F_GAMMA1F},
-
-	{0xa0, 0x4c, ZC3XX_R10A_RGB00},	/* matrix */
-	{0xa0, 0xf5, ZC3XX_R10B_RGB01},
-	{0xa0, 0xff, ZC3XX_R10C_RGB02},
-	{0xa0, 0xf9, ZC3XX_R10D_RGB10},
-	{0xa0, 0x51, ZC3XX_R10E_RGB11},
-	{0xa0, 0xf5, ZC3XX_R10F_RGB12},
-	{0xa0, 0xfb, ZC3XX_R110_RGB20},
-	{0xa0, 0xed, ZC3XX_R111_RGB21},
-	{0xa0, 0x5f, ZC3XX_R112_RGB22},
-
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x00, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},
-	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},
-	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},
-	{0xaa, 0x20, 0x0004},
-	{0xaa, 0x21, 0x003d},
-	{0xaa, 0x03, 0x0041},
-	{0xaa, 0x04, 0x0010},
-	{0xaa, 0x05, 0x003d},
-	{0xaa, 0x0e, 0x0001},
-	{0xaa, 0x0f, 0x0000},
-	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},
-	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},
-	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},
-	{0xa0, 0x04, ZC3XX_R191_EXPOSURELIMITMID},
-	{0xa0, 0x3d, ZC3XX_R192_EXPOSURELIMITLOW},
-	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},
-	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},
-	{0xa0, 0x9b, ZC3XX_R197_ANTIFLICKERLOW},
-	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},
-	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},
-	{0xa0, 0x41, ZC3XX_R01D_HSYNC_0},
-	{0xa0, 0x6f, ZC3XX_R01E_HSYNC_1},
-	{0xa0, 0xad, ZC3XX_R01F_HSYNC_2},
-	{0xa0, 0xff, ZC3XX_R020_HSYNC_3},
-	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},
-	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},
-	{0xa0, 0x40, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa1, 0x01, 0x0195},
-	{0xa1, 0x01, 0x0196},
-	{0xa1, 0x01, 0x0197},
-	{0xa0, 0x3d, ZC3XX_R192_EXPOSURELIMITLOW},
-	{0xa0, 0x04, ZC3XX_R191_EXPOSURELIMITMID},
-	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},
-	{0xa0, 0x1d, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x85, ZC3XX_R118_BGAIN},
-	{0xa1, 0x01, 0x0116},
-	{0xa1, 0x01, 0x0118},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x42, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x1d, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x85, ZC3XX_R118_BGAIN},
-	{0xa1, 0x01, 0x0116},
-	{0xa1, 0x01, 0x0118},
-/*	{0xa0, 0x02, ZC3XX_R008_CLOCKSETTING}, */
-	{0xa0, 0x00, 0x0007},
-	{}
-};
-
-static const struct usb_action hdcs2020xx_InitialScale[] = {
-	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},
-	{0xa0, 0x0e, ZC3XX_R010_CMOSSENSORSELECT},
-	{0xa0, 0x00, ZC3XX_R002_CLOCKSELECT},
-	{0xa0, 0x02, ZC3XX_R003_FRAMEWIDTHHIGH},
-	{0xa0, 0x80, ZC3XX_R004_FRAMEWIDTHLOW},
-	{0xa0, 0x01, ZC3XX_R005_FRAMEHEIGHTHIGH},
-	{0xa0, 0xe0, ZC3XX_R006_FRAMEHEIGHTLOW},
-	{0xa0, 0x01, ZC3XX_R001_SYSTEMOPERATING},
-	{0xa0, 0x03, ZC3XX_R012_VIDEOCONTROLFUNC},
-	{0xa0, 0x01, ZC3XX_R012_VIDEOCONTROLFUNC},
-	{0xa0, 0x08, ZC3XX_R08D_COMPABILITYMODE},
-	{0xa0, 0x00, ZC3XX_R098_WINYSTARTLOW},
-	{0xa0, 0x03, ZC3XX_R09A_WINXSTARTLOW},
-	{0xa0, 0x00, ZC3XX_R11A_FIRSTYLOW},
-	{0xa0, 0x03, ZC3XX_R11C_FIRSTXLOW},
-	{0xa0, 0x01, ZC3XX_R09B_WINHEIGHTHIGH},
-	{0xa0, 0xe6, ZC3XX_R09C_WINHEIGHTLOW},
-	{0xa0, 0x02, ZC3XX_R09D_WINWIDTHHIGH},
-	{0xa0, 0x86, ZC3XX_R09E_WINWIDTHLOW},
-	{0xaa, 0x02, 0x0002},
-	{0xaa, 0x07, 0x0006},
-	{0xaa, 0x08, 0x0002},
-	{0xaa, 0x09, 0x0006},
-	{0xaa, 0x0a, 0x0001},
-	{0xaa, 0x0b, 0x0001},
-	{0xaa, 0x0c, 0x0008},
-	{0xaa, 0x0d, 0x0000},
-	{0xaa, 0x10, 0x0000},
-	{0xaa, 0x12, 0x0005},
-	{0xaa, 0x13, 0x0063},
-	{0xaa, 0x15, 0x0070},
-	{0xa0, 0xb7, ZC3XX_R101_SENSORCORRECTION},
-	{0xa0, 0x0d, ZC3XX_R100_OPERATIONMODE},
-	{0xa0, 0x06, ZC3XX_R189_AWBSTATUS},
-	{0xa0, 0x00, 0x01ad},
-	{0xa0, 0x03, ZC3XX_R1C5_SHARPNESSMODE},
-	{0xa0, 0x13, ZC3XX_R1CB_SHARPNESS05},
-	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},
-	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},
-	{0xa0, 0x70, ZC3XX_R18D_YTARGET},
-	{0xa1, 0x01, 0x0002},
-	{0xa1, 0x01, 0x0008},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},	/* clock ? */
-	{0xa0, 0x04, ZC3XX_R1C6_SHARPNESS00},	/* sharpness+ */
-	{0xa1, 0x01, 0x01c8},
-	{0xa1, 0x01, 0x01c9},
-	{0xa1, 0x01, 0x01ca},
-	{0xa0, 0x07, ZC3XX_R1CB_SHARPNESS05},	/* sharpness- */
-	{0xa0, 0x11, ZC3XX_R120_GAMMA00},	/* gamma ~4*/
-	{0xa0, 0x37, ZC3XX_R121_GAMMA01},
-	{0xa0, 0x58, ZC3XX_R122_GAMMA02},
-	{0xa0, 0x79, ZC3XX_R123_GAMMA03},
-	{0xa0, 0x91, ZC3XX_R124_GAMMA04},
-	{0xa0, 0xa6, ZC3XX_R125_GAMMA05},
-	{0xa0, 0xb8, ZC3XX_R126_GAMMA06},
-	{0xa0, 0xc7, ZC3XX_R127_GAMMA07},
-	{0xa0, 0xd3, ZC3XX_R128_GAMMA08},
-	{0xa0, 0xde, ZC3XX_R129_GAMMA09},
-	{0xa0, 0xe6, ZC3XX_R12A_GAMMA0A},
-	{0xa0, 0xed, ZC3XX_R12B_GAMMA0B},
-	{0xa0, 0xf3, ZC3XX_R12C_GAMMA0C},
-	{0xa0, 0xf8, ZC3XX_R12D_GAMMA0D},
-	{0xa0, 0xfb, ZC3XX_R12E_GAMMA0E},
-	{0xa0, 0xff, ZC3XX_R12F_GAMMA0F},
-	{0xa0, 0x26, ZC3XX_R130_GAMMA10},
-	{0xa0, 0x23, ZC3XX_R131_GAMMA11},
-	{0xa0, 0x20, ZC3XX_R132_GAMMA12},
-	{0xa0, 0x1c, ZC3XX_R133_GAMMA13},
-	{0xa0, 0x16, ZC3XX_R134_GAMMA14},
-	{0xa0, 0x13, ZC3XX_R135_GAMMA15},
-	{0xa0, 0x10, ZC3XX_R136_GAMMA16},
-	{0xa0, 0x0d, ZC3XX_R137_GAMMA17},
-	{0xa0, 0x0b, ZC3XX_R138_GAMMA18},
-	{0xa0, 0x09, ZC3XX_R139_GAMMA19},
-	{0xa0, 0x07, ZC3XX_R13A_GAMMA1A},
-	{0xa0, 0x06, ZC3XX_R13B_GAMMA1B},
-	{0xa0, 0x05, ZC3XX_R13C_GAMMA1C},
-	{0xa0, 0x04, ZC3XX_R13D_GAMMA1D},
-	{0xa0, 0x03, ZC3XX_R13E_GAMMA1E},
-	{0xa0, 0x02, ZC3XX_R13F_GAMMA1F},
-	{0xa0, 0x60, ZC3XX_R10A_RGB00},	/* matrix */
-	{0xa0, 0xff, ZC3XX_R10B_RGB01},
-	{0xa0, 0xff, ZC3XX_R10C_RGB02},
-	{0xa0, 0xff, ZC3XX_R10D_RGB10},
-	{0xa0, 0x60, ZC3XX_R10E_RGB11},
-	{0xa0, 0xff, ZC3XX_R10F_RGB12},
-	{0xa0, 0xff, ZC3XX_R110_RGB20},
-	{0xa0, 0xff, ZC3XX_R111_RGB21},
-	{0xa0, 0x60, ZC3XX_R112_RGB22},
-
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x00, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},
-	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},
-	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},
-	{0xaa, 0x20, 0x0002},
-	{0xaa, 0x21, 0x001b},
-	{0xaa, 0x03, 0x0044},
-	{0xaa, 0x04, 0x0008},
-	{0xaa, 0x05, 0x001b},
-	{0xaa, 0x0e, 0x0001},
-	{0xaa, 0x0f, 0x0000},
-	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},
-	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},
-	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},
-	{0xa0, 0x02, ZC3XX_R191_EXPOSURELIMITMID},
-	{0xa0, 0x1b, ZC3XX_R192_EXPOSURELIMITLOW},
-	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},
-	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},
-	{0xa0, 0x4d, ZC3XX_R197_ANTIFLICKERLOW},
-	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},
-	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},
-	{0xa0, 0x44, ZC3XX_R01D_HSYNC_0},
-	{0xa0, 0x6f, ZC3XX_R01E_HSYNC_1},
-	{0xa0, 0xad, ZC3XX_R01F_HSYNC_2},
-	{0xa0, 0xeb, ZC3XX_R020_HSYNC_3},
-	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},
-	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},
-	{0xa0, 0x40, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa1, 0x01, 0x0195},
-	{0xa1, 0x01, 0x0196},
-	{0xa1, 0x01, 0x0197},
-	{0xa0, 0x1b, ZC3XX_R192_EXPOSURELIMITLOW},
-	{0xa0, 0x02, ZC3XX_R191_EXPOSURELIMITMID},
-	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},
-	{0xa0, 0x1d, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x99, ZC3XX_R118_BGAIN},
-	{0xa1, 0x01, 0x0116},
-	{0xa1, 0x01, 0x0118},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x42, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x1d, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x99, ZC3XX_R118_BGAIN},
-/*	{0xa0, 0x02, ZC3XX_R008_CLOCKSETTING}, */
-	{0xa0, 0x00, 0x0007},
-/*	{0xa0, 0x18, 0x00fe}, */
-	{}
-};
 static const struct usb_action hdcs2020xb_Initial[] = {
 	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
 	{0xa0, 0x11, ZC3XX_R002_CLOCKSELECT},
@@ -2310,67 +2021,6 @@
 	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},
 	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},
 	{0xaa, 0x02, 0x0090},			/* 00,02,80,aa */
-	{0xa1, 0x01, 0x0002},
-	{0xa0, 0x00, ZC3XX_R092_I2CADDRESSSELECT},
-	{0xa0, 0x02, ZC3XX_R090_I2CCOMMAND},
-	{0xa1, 0x01, 0x0091},
-	{0xa1, 0x01, 0x0095},
-	{0xa1, 0x01, 0x0096},
-
-	{0xa1, 0x01, 0x0008},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},	/* clock ? */
-	{0xa0, 0x08, ZC3XX_R1C6_SHARPNESS00},	/* sharpness+ */
-	{0xa1, 0x01, 0x01c8},
-	{0xa1, 0x01, 0x01c9},
-	{0xa1, 0x01, 0x01ca},
-	{0xa0, 0x0f, ZC3XX_R1CB_SHARPNESS05},	/* sharpness- */
-
-	{0xa0, 0x50, ZC3XX_R10A_RGB00},	/* matrix */
-	{0xa0, 0xf8, ZC3XX_R10B_RGB01},
-	{0xa0, 0xf8, ZC3XX_R10C_RGB02},
-	{0xa0, 0xf8, ZC3XX_R10D_RGB10},
-	{0xa0, 0x50, ZC3XX_R10E_RGB11},
-	{0xa0, 0xf8, ZC3XX_R10F_RGB12},
-	{0xa0, 0xf8, ZC3XX_R110_RGB20},
-	{0xa0, 0xf8, ZC3XX_R111_RGB21},
-	{0xa0, 0x50, ZC3XX_R112_RGB22},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x10, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},
-	{0xaa, 0x25, 0x0007},
-	{0xaa, 0x26, 0x00a1},
-	{0xaa, 0x27, 0x0020},
-	{0xaa, 0x20, 0x0000},
-	{0xaa, 0x21, 0x00a0},
-	{0xaa, 0x22, 0x0016},
-	{0xaa, 0x23, 0x0040},
-
-	{0xa0, 0x10, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 2F */
-	{0xa0, 0x04, ZC3XX_R191_EXPOSURELIMITMID},	/* 4d */
-	{0xa0, 0x60, ZC3XX_R192_EXPOSURELIMITLOW},
-	{0xa0, 0x01, ZC3XX_R195_ANTIFLICKERHIGH},
-	{0xa0, 0x86, ZC3XX_R196_ANTIFLICKERMID},
-	{0xa0, 0xa0, ZC3XX_R197_ANTIFLICKERLOW},
-	{0xa0, 0x07, ZC3XX_R18C_AEFREEZE},
-	{0xa0, 0x0f, ZC3XX_R18F_AEUNFREEZE},
-	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},
-	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},
-	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},
-	{0xa0, 0xa0, ZC3XX_R01E_HSYNC_1},
-	{0xa0, 0x16, ZC3XX_R01F_HSYNC_2},
-	{0xa0, 0x40, ZC3XX_R020_HSYNC_3},
-	{0xa0, 0x60, ZC3XX_R11D_GLOBALGAIN},
-	{0xa1, 0x01, 0x001d},
-	{0xa1, 0x01, 0x001e},
-	{0xa1, 0x01, 0x001f},
-	{0xa1, 0x01, 0x0020},
-	{0xa0, 0x40, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x42, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x40, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x40, ZC3XX_R118_BGAIN},
-/*	{0xa0, 0x02, ZC3XX_R008_CLOCKSETTING}, */
 	{}
 };
 
@@ -2418,65 +2068,156 @@
 	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},
 	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},
 	{0xaa, 0x02, 0x0090},	/* {0xaa, 0x02, 0x0080}, */
-	{0xa1, 0x01, 0x0002},
-	{0xa0, 0x00, ZC3XX_R092_I2CADDRESSSELECT},
-	{0xa0, 0x02, ZC3XX_R090_I2CCOMMAND},
-	{0xa1, 0x01, 0x0091},
-	{0xa1, 0x01, 0x0095},
-	{0xa1, 0x01, 0x0096},
-	{0xa1, 0x01, 0x0008},
-	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},	/* clock ? */
-	{0xa0, 0x08, ZC3XX_R1C6_SHARPNESS00},	/* sharpness+ */
-	{0xa1, 0x01, 0x01c8},
-	{0xa1, 0x01, 0x01c9},
-	{0xa1, 0x01, 0x01ca},
-	{0xa0, 0x0f, ZC3XX_R1CB_SHARPNESS05},	/* sharpness- */
-
-	{0xa0, 0x50, ZC3XX_R10A_RGB00},	/* matrix */
-	{0xa0, 0xf8, ZC3XX_R10B_RGB01},
-	{0xa0, 0xf8, ZC3XX_R10C_RGB02},
-	{0xa0, 0xf8, ZC3XX_R10D_RGB10},
-	{0xa0, 0x50, ZC3XX_R10E_RGB11},
-	{0xa0, 0xf8, ZC3XX_R10F_RGB12},
-	{0xa0, 0xf8, ZC3XX_R110_RGB20},
-	{0xa0, 0xf8, ZC3XX_R111_RGB21},
-	{0xa0, 0x50, ZC3XX_R112_RGB22},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x10, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},
-	{0xaa, 0x25, 0x0007},
-	{0xaa, 0x26, 0x00a1},
-	{0xaa, 0x27, 0x0020},
-	{0xaa, 0x20, 0x0000},
-	{0xaa, 0x21, 0x0040},
-	{0xaa, 0x22, 0x0013},
-	{0xaa, 0x23, 0x004c},
-	{0xa0, 0x10, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 2f */
-	{0xa0, 0x04, ZC3XX_R191_EXPOSURELIMITMID},	/* 4d */
-	{0xa0, 0x60, ZC3XX_R192_EXPOSURELIMITLOW},	/* 60 */
-	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},
-	{0xa0, 0xc3, ZC3XX_R196_ANTIFLICKERMID},
-	{0xa0, 0x50, ZC3XX_R197_ANTIFLICKERLOW},
-	{0xa0, 0x0c, ZC3XX_R18C_AEFREEZE},
-	{0xa0, 0x18, ZC3XX_R18F_AEUNFREEZE},
-	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},
-	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},
-	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},
-	{0xa0, 0x40, ZC3XX_R01E_HSYNC_1},
-	{0xa0, 0x13, ZC3XX_R01F_HSYNC_2},
-	{0xa0, 0x4c, ZC3XX_R020_HSYNC_3},
-	{0xa0, 0x60, ZC3XX_R11D_GLOBALGAIN},
-	{0xa1, 0x01, 0x001d},
-	{0xa1, 0x01, 0x001e},
-	{0xa1, 0x01, 0x001f},
-	{0xa1, 0x01, 0x0020},
-	{0xa0, 0x40, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa1, 0x01, 0x0180},
-	{0xa0, 0x42, ZC3XX_R180_AUTOCORRECTENABLE},
-	{0xa0, 0x40, ZC3XX_R116_RGAIN},
-	{0xa0, 0x40, ZC3XX_R117_GGAIN},
-	{0xa0, 0x40, ZC3XX_R118_BGAIN},
-/*	{0xa0, 0x02, ZC3XX_R008_CLOCKSETTING}, */
+	{}
+};
+static const struct usb_action hv7131b_50HZ[] = {	/* 640x480*/
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0007},			/* 00,25,07,aa */
+	{0xaa, 0x26, 0x0053},			/* 00,26,53,aa */
+	{0xaa, 0x27, 0x0000},			/* 00,27,00,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x0050},			/* 00,21,50,aa */
+	{0xaa, 0x22, 0x001b},			/* 00,22,1b,aa */
+	{0xaa, 0x23, 0x00fc},			/* 00,23,fc,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0x9b, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,9b,cc */
+	{0xa0, 0x80, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,80,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0xea, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,ea,cc */
+	{0xa0, 0x60, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,60,cc */
+	{0xa0, 0x0c, ZC3XX_R18C_AEFREEZE},	/* 01,8c,0c,cc */
+	{0xa0, 0x18, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,18,cc */
+	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,18,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0x50, ZC3XX_R01E_HSYNC_1},	/* 00,1e,50,cc */
+	{0xa0, 0x1b, ZC3XX_R01F_HSYNC_2},	/* 00,1f,1b,cc */
+	{0xa0, 0xfc, ZC3XX_R020_HSYNC_3},	/* 00,20,fc,cc */
+	{}
+};
+static const struct usb_action hv7131b_50HZScale[] = {	/* 320x240 */
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0007},			/* 00,25,07,aa */
+	{0xaa, 0x26, 0x0053},			/* 00,26,53,aa */
+	{0xaa, 0x27, 0x0000},			/* 00,27,00,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x0050},			/* 00,21,50,aa */
+	{0xaa, 0x22, 0x0012},			/* 00,22,12,aa */
+	{0xaa, 0x23, 0x0080},			/* 00,23,80,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0x9b, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,9b,cc */
+	{0xa0, 0x80, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,80,cc */
+	{0xa0, 0x01, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,01,cc */
+	{0xa0, 0xd4, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,d4,cc */
+	{0xa0, 0xc0, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,c0,cc */
+	{0xa0, 0x07, ZC3XX_R18C_AEFREEZE},	/* 01,8c,07,cc */
+	{0xa0, 0x0f, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,0f,cc */
+	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,18,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0x50, ZC3XX_R01E_HSYNC_1},	/* 00,1e,50,cc */
+	{0xa0, 0x12, ZC3XX_R01F_HSYNC_2},	/* 00,1f,12,cc */
+	{0xa0, 0x80, ZC3XX_R020_HSYNC_3},	/* 00,20,80,cc */
+	{}
+};
+static const struct usb_action hv7131b_60HZ[] = {	/* 640x480*/
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0007},			/* 00,25,07,aa */
+	{0xaa, 0x26, 0x00a1},			/* 00,26,a1,aa */
+	{0xaa, 0x27, 0x0020},			/* 00,27,20,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x0040},			/* 00,21,40,aa */
+	{0xaa, 0x22, 0x0013},			/* 00,22,13,aa */
+	{0xaa, 0x23, 0x004c},			/* 00,23,4c,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0x4d, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,4d,cc */
+	{0xa0, 0x60, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,60,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0xc3, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,c3,cc */
+	{0xa0, 0x50, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,50,cc */
+	{0xa0, 0x0c, ZC3XX_R18C_AEFREEZE},	/* 01,8c,0c,cc */
+	{0xa0, 0x18, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,18,cc */
+	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,18,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0x40, ZC3XX_R01E_HSYNC_1},	/* 00,1e,40,cc */
+	{0xa0, 0x13, ZC3XX_R01F_HSYNC_2},	/* 00,1f,13,cc */
+	{0xa0, 0x4c, ZC3XX_R020_HSYNC_3},	/* 00,20,4c,cc */
+	{}
+};
+static const struct usb_action hv7131b_60HZScale[] = {	/* 320x240 */
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0007},			/* 00,25,07,aa */
+	{0xaa, 0x26, 0x00a1},			/* 00,26,a1,aa */
+	{0xaa, 0x27, 0x0020},			/* 00,27,20,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x00a0},			/* 00,21,a0,aa */
+	{0xaa, 0x22, 0x0016},			/* 00,22,16,aa */
+	{0xaa, 0x23, 0x0040},			/* 00,23,40,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0x4d, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,4d,cc */
+	{0xa0, 0x60, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,60,cc */
+	{0xa0, 0x01, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,01,cc */
+	{0xa0, 0x86, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,86,cc */
+	{0xa0, 0xa0, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,a0,cc */
+	{0xa0, 0x07, ZC3XX_R18C_AEFREEZE},	/* 01,8c,07,cc */
+	{0xa0, 0x0f, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,0f,cc */
+	{0xa0, 0x18, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,18,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0xa0, ZC3XX_R01E_HSYNC_1},	/* 00,1e,a0,cc */
+	{0xa0, 0x16, ZC3XX_R01F_HSYNC_2},	/* 00,1f,16,cc */
+	{0xa0, 0x40, ZC3XX_R020_HSYNC_3},	/* 00,20,40,cc */
+	{}
+};
+static const struct usb_action hv7131b_NoFliker[] = {	/* 640x480*/
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0003},			/* 00,25,03,aa */
+	{0xaa, 0x26, 0x0000},			/* 00,26,00,aa */
+	{0xaa, 0x27, 0x0000},			/* 00,27,00,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x0010},			/* 00,21,10,aa */
+	{0xaa, 0x22, 0x0000},			/* 00,22,00,aa */
+	{0xaa, 0x23, 0x0003},			/* 00,23,03,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0xf8, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,f8,cc */
+	{0xa0, 0x00, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,00,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x02, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,02,cc */
+	{0xa0, 0x00, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,00,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},	/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,20,cc */
+	{0xa0, 0x00, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,00,cc */
+	{0xa0, 0x00, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,00,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0x10, ZC3XX_R01E_HSYNC_1},	/* 00,1e,10,cc */
+	{0xa0, 0x00, ZC3XX_R01F_HSYNC_2},	/* 00,1f,00,cc */
+	{0xa0, 0x03, ZC3XX_R020_HSYNC_3},	/* 00,20,03,cc */
+	{}
+};
+static const struct usb_action hv7131b_NoFlikerScale[] = { /* 320x240 */
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},	/* 00,19,00,cc */
+	{0xaa, 0x25, 0x0003},			/* 00,25,03,aa */
+	{0xaa, 0x26, 0x0000},			/* 00,26,00,aa */
+	{0xaa, 0x27, 0x0000},			/* 00,27,00,aa */
+	{0xaa, 0x20, 0x0000},			/* 00,20,00,aa */
+	{0xaa, 0x21, 0x00a0},			/* 00,21,a0,aa */
+	{0xaa, 0x22, 0x0016},			/* 00,22,16,aa */
+	{0xaa, 0x23, 0x0040},			/* 00,23,40,aa */
+	{0xa0, 0x2f, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,2f,cc */
+	{0xa0, 0xf8, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,f8,cc */
+	{0xa0, 0x00, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,00,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x02, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,02,cc */
+	{0xa0, 0x00, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,00,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},	/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},	/* 01,8f,20,cc */
+	{0xa0, 0x00, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,00,cc */
+	{0xa0, 0x00, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,00,cc */
+	{0xa0, 0x00, ZC3XX_R01D_HSYNC_0},	/* 00,1d,00,cc */
+	{0xa0, 0xa0, ZC3XX_R01E_HSYNC_1},	/* 00,1e,a0,cc */
+	{0xa0, 0x16, ZC3XX_R01F_HSYNC_2},	/* 00,1f,16,cc */
+	{0xa0, 0x40, ZC3XX_R020_HSYNC_3},	/* 00,20,40,cc */
 	{}
 };
 
@@ -3565,7 +3306,12 @@
 static const struct usb_action OV7620_mode0[] = {
 	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL}, /* 00,00,01,cc */
 	{0xa0, 0x40, ZC3XX_R002_CLOCKSELECT}, /* 00,02,40,cc */
+#if 1 /*jfm*/
 	{0xa0, 0x00, ZC3XX_R008_CLOCKSETTING}, /* 00,08,00,cc */
+#else
+	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING}, /* 00,08,00,cc */
+						/* mx change? */
+#endif
 	{0xa0, 0x01, ZC3XX_R001_SYSTEMOPERATING}, /* 00,01,01,cc */
 	{0xa0, 0x06, ZC3XX_R010_CMOSSENSORSELECT}, /* 00,10,06,cc */
 	{0xa0, 0x02, ZC3XX_R083_RGAINADDR}, /* 00,83,02,cc */
@@ -4389,6 +4135,270 @@
 	{}
 };
 
+/* from usbvm31b.inf */
+static const struct usb_action pas202b_Initial[] = {	/* 640x480 */
+	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},		/* 00,00,01,cc */
+	{0xa0, 0x00, ZC3XX_R008_CLOCKSETTING},		/* 00,08,00,cc */
+	{0xa0, 0x0e, ZC3XX_R010_CMOSSENSORSELECT},	/* 00,10,0e,cc */
+	{0xa0, 0x00, ZC3XX_R002_CLOCKSELECT},		/* 00,02,00,cc */
+	{0xa0, 0x02, ZC3XX_R003_FRAMEWIDTHHIGH},	/* 00,03,02,cc */
+	{0xa0, 0x80, ZC3XX_R004_FRAMEWIDTHLOW},		/* 00,04,80,cc */
+	{0xa0, 0x01, ZC3XX_R005_FRAMEHEIGHTHIGH},	/* 00,05,01,cc */
+	{0xa0, 0xe0, ZC3XX_R006_FRAMEHEIGHTLOW},	/* 00,06,e0,cc */
+	{0xa0, 0x01, ZC3XX_R001_SYSTEMOPERATING},	/* 00,01,01,cc */
+	{0xa0, 0x03, ZC3XX_R012_VIDEOCONTROLFUNC},	/* 00,12,03,cc */
+	{0xa0, 0x01, ZC3XX_R012_VIDEOCONTROLFUNC},	/* 00,12,01,cc */
+	{0xa0, 0x08, ZC3XX_R08D_COMPABILITYMODE},	/* 00,8d,08,cc */
+	{0xa0, 0x00, ZC3XX_R098_WINYSTARTLOW},		/* 00,98,00,cc */
+	{0xa0, 0x03, ZC3XX_R09A_WINXSTARTLOW},		/* 00,9a,03,cc */
+	{0xa0, 0x00, ZC3XX_R11A_FIRSTYLOW},		/* 01,1a,00,cc */
+	{0xa0, 0x03, ZC3XX_R11C_FIRSTXLOW},		/* 01,1c,03,cc */
+	{0xa0, 0x01, ZC3XX_R09B_WINHEIGHTHIGH},		/* 00,9b,01,cc */
+	{0xa0, 0xe6, ZC3XX_R09C_WINHEIGHTLOW},		/* 00,9c,e6,cc */
+	{0xa0, 0x02, ZC3XX_R09D_WINWIDTHHIGH},		/* 00,9d,02,cc */
+	{0xa0, 0x86, ZC3XX_R09E_WINWIDTHLOW},		/* 00,9e,86,cc */
+	{0xaa, 0x02, 0x0002},			/* 00,02,04,aa --> 02 */
+	{0xaa, 0x07, 0x0006},				/* 00,07,06,aa */
+	{0xaa, 0x08, 0x0002},				/* 00,08,02,aa */
+	{0xaa, 0x09, 0x0006},				/* 00,09,06,aa */
+	{0xaa, 0x0a, 0x0001},				/* 00,0a,01,aa */
+	{0xaa, 0x0b, 0x0001},				/* 00,0b,01,aa */
+	{0xaa, 0x0c, 0x0008},				/* 00,0c,08,aa */
+	{0xaa, 0x0d, 0x0000},				/* 00,0d,00,aa */
+	{0xaa, 0x10, 0x0000},				/* 00,10,00,aa */
+	{0xaa, 0x12, 0x0005},				/* 00,12,05,aa */
+	{0xaa, 0x13, 0x0063},				/* 00,13,63,aa */
+	{0xaa, 0x15, 0x0070},				/* 00,15,70,aa */
+	{0xa0, 0xb7, ZC3XX_R101_SENSORCORRECTION},	/* 01,01,b7,cc */
+	{0xa0, 0x0d, ZC3XX_R100_OPERATIONMODE},		/* 01,00,0d,cc */
+	{0xa0, 0x06, ZC3XX_R189_AWBSTATUS},		/* 01,89,06,cc */
+	{0xa0, 0x00, 0x01ad},				/* 01,ad,00,cc */
+	{0xa0, 0x03, ZC3XX_R1C5_SHARPNESSMODE},		/* 01,c5,03,cc */
+	{0xa0, 0x13, ZC3XX_R1CB_SHARPNESS05},		/* 01,cb,13,cc */
+	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},	/* 02,50,08,cc */
+	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},		/* 03,01,08,cc */
+	{0xa0, 0x70, ZC3XX_R18D_YTARGET},		/* 01,8d,70,cc */
+	{}
+};
+static const struct usb_action pas202b_InitialScale[] = {	/* 320x240 */
+	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},		/* 00,00,01,cc */
+	{0xa0, 0x00, ZC3XX_R008_CLOCKSETTING},		/* 00,08,00,cc */
+	{0xa0, 0x0e, ZC3XX_R010_CMOSSENSORSELECT},	/* 00,10,0e,cc */
+	{0xa0, 0x10, ZC3XX_R002_CLOCKSELECT},		/* 00,02,10,cc */
+	{0xa0, 0x02, ZC3XX_R003_FRAMEWIDTHHIGH},	/* 00,03,02,cc */
+	{0xa0, 0x80, ZC3XX_R004_FRAMEWIDTHLOW},		/* 00,04,80,cc */
+	{0xa0, 0x01, ZC3XX_R005_FRAMEHEIGHTHIGH},	/* 00,05,01,cc */
+	{0xa0, 0xd0, ZC3XX_R006_FRAMEHEIGHTLOW},	/* 00,06,d0,cc */
+	{0xa0, 0x01, ZC3XX_R001_SYSTEMOPERATING},	/* 00,01,01,cc */
+	{0xa0, 0x03, ZC3XX_R012_VIDEOCONTROLFUNC},	/* 00,12,03,cc */
+	{0xa0, 0x01, ZC3XX_R012_VIDEOCONTROLFUNC},	/* 00,12,01,cc */
+	{0xa0, 0x08, ZC3XX_R08D_COMPABILITYMODE},	/* 00,8d,08,cc */
+	{0xa0, 0x08, ZC3XX_R098_WINYSTARTLOW},		/* 00,98,08,cc */
+	{0xa0, 0x02, ZC3XX_R09A_WINXSTARTLOW},		/* 00,9a,02,cc */
+	{0xa0, 0x08, ZC3XX_R11A_FIRSTYLOW},		/* 01,1a,08,cc */
+	{0xa0, 0x02, ZC3XX_R11C_FIRSTXLOW},		/* 01,1c,02,cc */
+	{0xa0, 0x01, ZC3XX_R09B_WINHEIGHTHIGH},		/* 00,9b,01,cc */
+	{0xa0, 0xd8, ZC3XX_R09C_WINHEIGHTLOW},		/* 00,9c,d8,cc */
+	{0xa0, 0x02, ZC3XX_R09D_WINWIDTHHIGH},		/* 00,9d,02,cc */
+	{0xa0, 0x88, ZC3XX_R09E_WINWIDTHLOW},		/* 00,9e,88,cc */
+	{0xaa, 0x02, 0x0002},				/* 00,02,02,aa */
+	{0xaa, 0x07, 0x0006},				/* 00,07,06,aa */
+	{0xaa, 0x08, 0x0002},				/* 00,08,02,aa */
+	{0xaa, 0x09, 0x0006},				/* 00,09,06,aa */
+	{0xaa, 0x0a, 0x0001},				/* 00,0a,01,aa */
+	{0xaa, 0x0b, 0x0001},				/* 00,0b,01,aa */
+	{0xaa, 0x0c, 0x0008},				/* 00,0c,08,aa */
+	{0xaa, 0x0d, 0x0000},				/* 00,0d,00,aa */
+	{0xaa, 0x10, 0x0000},				/* 00,10,00,aa */
+	{0xaa, 0x12, 0x0005},				/* 00,12,05,aa */
+	{0xaa, 0x13, 0x0063},				/* 00,13,63,aa */
+	{0xaa, 0x15, 0x0070},				/* 00,15,70,aa */
+	{0xa0, 0x37, ZC3XX_R101_SENSORCORRECTION},	/* 01,01,37,cc */
+	{0xa0, 0x0d, ZC3XX_R100_OPERATIONMODE},		/* 01,00,0d,cc */
+	{0xa0, 0x06, ZC3XX_R189_AWBSTATUS},		/* 01,89,06,cc */
+	{0xa0, 0x00, 0x01ad},				/* 01,ad,00,cc */
+	{0xa0, 0x03, ZC3XX_R1C5_SHARPNESSMODE},		/* 01,c5,03,cc */
+	{0xa0, 0x13, ZC3XX_R1CB_SHARPNESS05},		/* 01,cb,13,cc */
+	{0xa0, 0x08, ZC3XX_R250_DEADPIXELSMODE},	/* 02,50,08,cc */
+	{0xa0, 0x08, ZC3XX_R301_EEPROMACCESS},		/* 03,01,08,cc */
+	{0xa0, 0x70, ZC3XX_R18D_YTARGET},		/* 01,8d,70,cc */
+	{}
+};
+static const struct usb_action pas202b_50HZ[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x0068},				/* 00,21,68,aa */
+	{0xaa, 0x03, 0x0044},				/* 00,03,44,aa */
+	{0xaa, 0x04, 0x0009},				/* 00,04,09,aa */
+	{0xaa, 0x05, 0x0028},				/* 00,05,28,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,14,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x07, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,07,cc */
+	{0xa0, 0xd2, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,d2,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x4d, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,4d,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x44, ZC3XX_R01D_HSYNC_0},		/* 00,1d,44,cc */
+	{0xa0, 0x6f, ZC3XX_R01E_HSYNC_1},		/* 00,1e,6f,cc */
+	{0xa0, 0xad, ZC3XX_R01F_HSYNC_2},		/* 00,1f,ad,cc */
+	{0xa0, 0xeb, ZC3XX_R020_HSYNC_3},		/* 00,20,eb,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+static const struct usb_action pas202b_50HZScale[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x006c},				/* 00,21,6c,aa */
+	{0xaa, 0x03, 0x0041},				/* 00,03,41,aa */
+	{0xaa, 0x04, 0x0009},				/* 00,04,09,aa */
+	{0xaa, 0x05, 0x002c},				/* 00,05,2c,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,14,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x0f, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,0f,cc */
+	{0xa0, 0xbe, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,be,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x9b, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,9b,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x41, ZC3XX_R01D_HSYNC_0},		/* 00,1d,41,cc */
+	{0xa0, 0x6f, ZC3XX_R01E_HSYNC_1},		/* 00,1e,6f,cc */
+	{0xa0, 0xad, ZC3XX_R01F_HSYNC_2},		/* 00,1f,ad,cc */
+	{0xa0, 0xff, ZC3XX_R020_HSYNC_3},		/* 00,20,ff,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+static const struct usb_action pas202b_60HZ[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x0000},				/* 00,21,00,aa */
+	{0xaa, 0x03, 0x0045},				/* 00,03,45,aa */
+	{0xaa, 0x04, 0x0008},				/* 00,04,08,aa */
+	{0xaa, 0x05, 0x0000},				/* 00,05,00,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,14,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x07, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,07,cc */
+	{0xa0, 0xc0, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,c0,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x40, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,40,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x45, ZC3XX_R01D_HSYNC_0},		/* 00,1d,45,cc */
+	{0xa0, 0x8e, ZC3XX_R01E_HSYNC_1},		/* 00,1e,8e,cc */
+	{0xa0, 0xc1, ZC3XX_R01F_HSYNC_2},		/* 00,1f,c1,cc */
+	{0xa0, 0xf5, ZC3XX_R020_HSYNC_3},		/* 00,20,f5,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+static const struct usb_action pas202b_60HZScale[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x0004},				/* 00,21,04,aa */
+	{0xaa, 0x03, 0x0042},				/* 00,03,42,aa */
+	{0xaa, 0x04, 0x0008},				/* 00,04,08,aa */
+	{0xaa, 0x05, 0x0004},				/* 00,05,04,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x14, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,14,cc */
+	{0xa0, 0x24, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,24,cc */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x0f, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,0f,cc */
+	{0xa0, 0x9f, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,9f,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x81, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,81,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x42, ZC3XX_R01D_HSYNC_0},		/* 00,1d,42,cc */
+	{0xa0, 0x6f, ZC3XX_R01E_HSYNC_1},		/* 00,1e,6f,cc */
+	{0xa0, 0xaf, ZC3XX_R01F_HSYNC_2},		/* 00,1f,af,cc */
+	{0xa0, 0xff, ZC3XX_R020_HSYNC_3},		/* 00,20,ff,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+static const struct usb_action pas202b_NoFliker[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x0020},				/* 00,21,20,aa */
+	{0xaa, 0x03, 0x0040},				/* 00,03,40,aa */
+	{0xaa, 0x04, 0x0008},				/* 00,04,08,aa */
+	{0xaa, 0x05, 0x0020},				/* 00,05,20,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x07, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,07,cc */
+	{0xa0, 0xf0, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,f0,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x02, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,02,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x00, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,00,cc */
+	{0xa0, 0x00, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,00,cc */
+	{0xa0, 0x40, ZC3XX_R01D_HSYNC_0},		/* 00,1d,40,cc */
+	{0xa0, 0x60, ZC3XX_R01E_HSYNC_1},		/* 00,1e,60,cc */
+	{0xa0, 0x90, ZC3XX_R01F_HSYNC_2},		/* 00,1f,90,cc */
+	{0xa0, 0xff, ZC3XX_R020_HSYNC_3},		/* 00,20,ff,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+static const struct usb_action pas202b_NoFlikerScale[] = {
+	{0xa0, 0x00, ZC3XX_R019_AUTOADJUSTFPS},		/* 00,19,00,cc */
+	{0xa0, 0x20, ZC3XX_R087_EXPTIMEMID},		/* 00,87,20,cc */
+	{0xa0, 0x21, ZC3XX_R088_EXPTIMELOW},		/* 00,88,21,cc */
+	{0xaa, 0x20, 0x0002},				/* 00,20,02,aa */
+	{0xaa, 0x21, 0x0010},				/* 00,21,10,aa */
+	{0xaa, 0x03, 0x0040},				/* 00,03,40,aa */
+	{0xaa, 0x04, 0x0008},				/* 00,04,08,aa */
+	{0xaa, 0x05, 0x0010},				/* 00,05,10,aa */
+	{0xaa, 0x0e, 0x0001},				/* 00,0e,01,aa */
+	{0xaa, 0x0f, 0x0000},				/* 00,0f,00,aa */
+	{0xa0, 0x00, ZC3XX_R190_EXPOSURELIMITHIGH},	/* 01,90,00,cc */
+	{0xa0, 0x0f, ZC3XX_R191_EXPOSURELIMITMID},	/* 01,91,0f,cc */
+	{0xa0, 0xf0, ZC3XX_R192_EXPOSURELIMITLOW},	/* 01,92,f0,cc */
+	{0xa0, 0x00, ZC3XX_R195_ANTIFLICKERHIGH},	/* 01,95,00,cc */
+	{0xa0, 0x00, ZC3XX_R196_ANTIFLICKERMID},	/* 01,96,00,cc */
+	{0xa0, 0x02, ZC3XX_R197_ANTIFLICKERLOW},	/* 01,97,02,cc */
+	{0xa0, 0x10, ZC3XX_R18C_AEFREEZE},		/* 01,8c,10,cc */
+	{0xa0, 0x20, ZC3XX_R18F_AEUNFREEZE},		/* 01,8f,20,cc */
+	{0xa0, 0x00, ZC3XX_R1A9_DIGITALLIMITDIFF},	/* 01,a9,00,cc */
+	{0xa0, 0x00, ZC3XX_R1AA_DIGITALGAINSTEP},	/* 01,aa,00,cc */
+	{0xa0, 0x40, ZC3XX_R01D_HSYNC_0},		/* 00,1d,40,cc */
+	{0xa0, 0x60, ZC3XX_R01E_HSYNC_1},		/* 00,1e,60,cc */
+	{0xa0, 0x90, ZC3XX_R01F_HSYNC_2},		/* 00,1f,90,cc */
+	{0xa0, 0xff, ZC3XX_R020_HSYNC_3},		/* 00,20,ff,cc */
+	{0xa0, 0x0f, ZC3XX_R087_EXPTIMEMID},		/* 00,87,0f,cc */
+	{0xa0, 0x0e, ZC3XX_R088_EXPTIMELOW},		/* 00,88,0e,cc */
+	{}
+};
+
 static const struct usb_action pb03303x_Initial[] = {
 	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
 	{0xa0, 0x03, ZC3XX_R008_CLOCKSETTING},
@@ -5725,7 +5735,7 @@
 	{}
 };
 static const struct usb_action tas5130cxx_InitialScale[] = {
-	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
+/*??	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL}, */
 	{0xa0, 0x01, ZC3XX_R000_SYSTEMCONTROL},
 	{0xa0, 0x40, ZC3XX_R002_CLOCKSELECT},
 
@@ -6049,7 +6059,7 @@
 	{0xaa, 0x1b, 0x0000},		/* 00,1b,00,aa, */
 	{0xaa, 0x13, 0x0002},		/* 00,13,02,aa, */
 	{0xaa, 0x15, 0x0004},		/* 00,15,04,aa */
-	{0xaa, 0x01, 0x0000},
+/*??	{0xaa, 0x01, 0x0000}, */
 	{0xaa, 0x01, 0x0000},
 	{0xaa, 0x1a, 0x0000},		/* 00,1a,00,aa, */
 	{0xaa, 0x1c, 0x0017},		/* 00,1c,17,aa, */
@@ -6065,8 +6075,8 @@
 	{0xaa, 0x0f, 0x00a0},		/* 00,0f,a0,aa, */
 	{0xaa, 0x10, 0x0000},		/* 00,10,00,aa, */
 	{0xaa, 0x11, 0x00a0},		/* 00,11,a0,aa, */
-	{0xa0, 0x00, 0x0039},
-	{0xa1, 0x01, 0x0037},
+/*??	{0xa0, 0x00, 0x0039},
+	{0xa1, 0x01, 0x0037}, */
 	{0xaa, 0x16, 0x0001},		/* 00,16,01,aa, */
 	{0xaa, 0x17, 0x00e8},		/* 00,17,e6,aa (e6 -> e8) */
 	{0xaa, 0x18, 0x0002},		/* 00,18,02,aa, */
@@ -6303,7 +6313,7 @@
 	reg_w_i(gspca_dev->dev, valL, 0x93);
 	reg_w_i(gspca_dev->dev, valH, 0x94);
 	reg_w_i(gspca_dev->dev, 0x01, 0x90);		/* <- write command */
-	msleep(5);
+	msleep(15);
 	retbyte = reg_r_i(gspca_dev, 0x0091);		/* read status */
 	PDEBUG(D_USBO, "i2c w [%02x] = %02x%02x (%02x)",
 			reg, valH, valL, retbyte);
@@ -6346,30 +6356,35 @@
 		{0x50, 0xf8, 0xf8, 0xf8, 0x50, 0xf8, 0xf8, 0xf8, 0x50};
 	static const __u8 ov7620_matrix[9] =
 		{0x58, 0xf4, 0xf4, 0xf4, 0x58, 0xf4, 0xf4, 0xf4, 0x58};
+	static const __u8 pas202b_matrix[9] =
+		{0x4c, 0xf5, 0xff, 0xf9, 0x51, 0xf5, 0xfb, 0xed, 0x5f};
 	static const __u8 po2030_matrix[9] =
 		{0x60, 0xf0, 0xf0, 0xf0, 0x60, 0xf0, 0xf0, 0xf0, 0x60};
 	static const __u8 vf0250_matrix[9] =
 		{0x7b, 0xea, 0xea, 0xea, 0x7b, 0xea, 0xea, 0xea, 0x7b};
+	static const __u8 *matrix_tb[SENSOR_MAX] = {
+		NULL,		/* SENSOR_CS2102 0 */
+		NULL,		/* SENSOR_CS2102K 1 */
+		gc0305_matrix,	/* SENSOR_GC0305 2 */
+		NULL,		/* SENSOR_HDCS2020b 3 */
+		NULL,		/* SENSOR_HV7131B 4 */
+		NULL,		/* SENSOR_HV7131C 5 */
+		NULL,		/* SENSOR_ICM105A 6 */
+		NULL,		/* SENSOR_MC501CB 7 */
+		ov7620_matrix,	/* SENSOR_OV7620 8 */
+		NULL,		/* SENSOR_OV7630C 9 */
+		NULL,		/* SENSOR_PAS106 10 */
+		pas202b_matrix,	/* SENSOR_PAS202B 11 */
+		NULL,		/* SENSOR_PB0330 12 */
+		po2030_matrix,	/* SENSOR_PO2030 13 */
+		NULL,		/* SENSOR_TAS5130CK 14 */
+		NULL,		/* SENSOR_TAS5130CXX 15 */
+		vf0250_matrix,	/* SENSOR_TAS5130C_VF0250 16 */
+	};
 
-	switch (sd->sensor) {
-	case SENSOR_GC0305:
-		matrix = gc0305_matrix;
-		break;
-	case SENSOR_MC501CB:
-		return;		/* no matrix? */
-	case SENSOR_OV7620:
-/*	case SENSOR_OV7648: */
-		matrix = ov7620_matrix;
-		break;
-	case SENSOR_PO2030:
-		matrix = po2030_matrix;
-		break;
-	case SENSOR_TAS5130C_VF0250:
-		matrix = vf0250_matrix;
-		break;
-	default:		/* matrix already loaded */
-		return;
-	}
+	matrix = matrix_tb[sd->sensor];
+	if (matrix == NULL)
+		return;		/* matrix already loaded */
 	for (i = 0; i < ARRAY_SIZE(ov7620_matrix); i++)
 		reg_w(gspca_dev->dev, matrix[i], 0x010a + i);
 }
@@ -6585,42 +6600,42 @@
 		{gc0305_NoFliker, gc0305_NoFliker,
 		 gc0305_50HZ, gc0305_50HZ,
 		 gc0305_60HZ, gc0305_60HZ},
-/* SENSOR_HDCS2020 3 */
-		{NULL, NULL,
-		 NULL, NULL,
-		 NULL, NULL},
-/* SENSOR_HDCS2020b 4 */
+/* SENSOR_HDCS2020b 3 */
 		{hdcs2020b_NoFliker, hdcs2020b_NoFliker,
 		 hdcs2020b_50HZ, hdcs2020b_50HZ,
 		 hdcs2020b_60HZ, hdcs2020b_60HZ},
-/* SENSOR_HV7131B 5 */
+/* SENSOR_HV7131B 4 */
+		{hv7131b_NoFlikerScale, hv7131b_NoFliker,
+		 hv7131b_50HZScale, hv7131b_50HZ,
+		 hv7131b_60HZScale, hv7131b_60HZ},
+/* SENSOR_HV7131C 5 */
 		{NULL, NULL,
 		 NULL, NULL,
 		 NULL, NULL},
-/* SENSOR_HV7131C 6 */
-		{NULL, NULL,
-		 NULL, NULL,
-		 NULL, NULL},
-/* SENSOR_ICM105A 7 */
+/* SENSOR_ICM105A 6 */
 		{icm105a_NoFliker, icm105a_NoFlikerScale,
 		 icm105a_50HZ, icm105a_50HZScale,
 		 icm105a_60HZ, icm105a_60HZScale},
-/* SENSOR_MC501CB 8 */
+/* SENSOR_MC501CB 7 */
 		{MC501CB_NoFliker, MC501CB_NoFlikerScale,
 		 MC501CB_50HZ, MC501CB_50HZScale,
 		 MC501CB_60HZ, MC501CB_60HZScale},
-/* SENSOR_OV7620 9 */
+/* SENSOR_OV7620 8 */
 		{OV7620_NoFliker, OV7620_NoFliker,
 		 OV7620_50HZ, OV7620_50HZ,
 		 OV7620_60HZ, OV7620_60HZ},
-/* SENSOR_OV7630C 10 */
+/* SENSOR_OV7630C 9 */
 		{NULL, NULL,
 		 NULL, NULL,
 		 NULL, NULL},
-/* SENSOR_PAS106 11 */
+/* SENSOR_PAS106 10 */
 		{pas106b_NoFliker, pas106b_NoFliker,
 		 pas106b_50HZ, pas106b_50HZ,
 		 pas106b_60HZ, pas106b_60HZ},
+/* SENSOR_PAS202B 11 */
+		{pas202b_NoFlikerScale, pas202b_NoFliker,
+		 pas202b_50HZScale, pas202b_50HZ,
+		 pas202b_60HZScale, pas202b_60HZ},
 /* SENSOR_PB0330 12 */
 		{pb0330_NoFliker, pb0330_NoFlikerScale,
 		 pb0330_50HZ, pb0330_50HZScale,
@@ -7002,15 +7017,15 @@
 		5,	/* SENSOR_CS2102 0 */
 		5,	/* SENSOR_CS2102K 1 */
 		4,	/* SENSOR_GC0305 2 */
-		4,	/* SENSOR_HDCS2020 3 */
-		4,	/* SENSOR_HDCS2020b 4 */
-		4,	/* SENSOR_HV7131B 5 */
-		4,	/* SENSOR_HV7131C 6 */
-		4,	/* SENSOR_ICM105A 7 */
-		4,	/* SENSOR_MC501CB 8 */
-		3,	/* SENSOR_OV7620 9 */
-		4,	/* SENSOR_OV7630C 10 */
-		4,	/* SENSOR_PAS106 11 */
+		4,	/* SENSOR_HDCS2020b 3 */
+		4,	/* SENSOR_HV7131B 4 */
+		4,	/* SENSOR_HV7131C 5 */
+		4,	/* SENSOR_ICM105A 6 */
+		4,	/* SENSOR_MC501CB 7 */
+		3,	/* SENSOR_OV7620 8 */
+		4,	/* SENSOR_OV7630C 9 */
+		4,	/* SENSOR_PAS106 10 */
+		4,	/* SENSOR_PAS202B 11 */
 		4,	/* SENSOR_PB0330 12 */
 		4,	/* SENSOR_PO2030 13 */
 		4,	/* SENSOR_TAS5130CK 14 */
@@ -7066,8 +7081,8 @@
 			sd->sensor = SENSOR_ICM105A;
 			break;
 		case 0x0e:
-			PDEBUG(D_PROBE, "Find Sensor HDCS2020");
-			sd->sensor = SENSOR_HDCS2020;
+			PDEBUG(D_PROBE, "Find Sensor PAS202B");
+			sd->sensor = SENSOR_PAS202B;
 			sd->sharpness = 1;
 			break;
 		case 0x0f:
@@ -7153,7 +7168,6 @@
 	sd->gamma = gamma[(int) sd->sensor];
 	sd->autogain = sd_ctrls[SD_AUTOGAIN].qctrl.default_value;
 	sd->lightfreq = sd_ctrls[SD_FREQ].qctrl.default_value;
-	sd->sharpness = sd_ctrls[SD_SHARPNESS].qctrl.default_value;
 
 	switch (sd->sensor) {
 	case SENSOR_GC0305:
@@ -7161,7 +7175,6 @@
 	case SENSOR_PO2030:
 		gspca_dev->ctrl_dis = (1 << BRIGHTNESS_IDX);
 		break;
-	case SENSOR_HDCS2020:
 	case SENSOR_HV7131B:
 	case SENSOR_HV7131C:
 	case SENSOR_OV7630C:
@@ -7191,15 +7204,15 @@
 		{cs2102_InitialScale, cs2102_Initial},		/* 0 */
 		{cs2102K_InitialScale, cs2102K_Initial},	/* 1 */
 		{gc0305_Initial, gc0305_InitialScale},		/* 2 */
-		{hdcs2020xx_InitialScale, hdcs2020xx_Initial},	/* 3 */
-		{hdcs2020xb_InitialScale, hdcs2020xb_Initial},	/* 4 */
-		{hv7131bxx_InitialScale, hv7131bxx_Initial},	/* 5 */
-		{hv7131cxx_InitialScale, hv7131cxx_Initial},	/* 6 */
-		{icm105axx_InitialScale, icm105axx_Initial},	/* 7 */
-		{MC501CB_InitialScale, MC501CB_Initial},	/* 9 */
-		{OV7620_mode0, OV7620_mode1},			/* 9 */
-		{ov7630c_InitialScale, ov7630c_Initial},	/* 10 */
-		{pas106b_InitialScale, pas106b_Initial},	/* 11 */
+		{hdcs2020xb_InitialScale, hdcs2020xb_Initial},	/* 3 */
+		{hv7131bxx_InitialScale, hv7131bxx_Initial},	/* 4 */
+		{hv7131cxx_InitialScale, hv7131cxx_Initial},	/* 5 */
+		{icm105axx_InitialScale, icm105axx_Initial},	/* 6 */
+		{MC501CB_InitialScale, MC501CB_Initial},	/* 7 */
+		{OV7620_mode0, OV7620_mode1},			/* 8 */
+		{ov7630c_InitialScale, ov7630c_Initial},	/* 9 */
+		{pas106b_InitialScale, pas106b_Initial},	/* 10 */
+		{pas202b_Initial, pas202b_InitialScale},	/* 11 */
 		{pb0330xx_InitialScale, pb0330xx_Initial},	/* 12 */
 /* or		{pb03303x_InitialScale, pb03303x_Initial}, */
 		{PO2030_mode0, PO2030_mode1},			/* 13 */
@@ -7256,6 +7269,11 @@
 		reg_r(gspca_dev, 0x0008);
 		reg_w(dev, 0x00, 0x0008);
 		break;
+	case SENSOR_PAS202B:
+#if 0/*fixme*/
+		reg_r(gspca_dev, ZC3XX_R002_CLOCKSELECT);
+		/* fall thru */
+#endif
 	case SENSOR_GC0305:
 		reg_r(gspca_dev, 0x0008);
 		/* fall thru */
@@ -7269,7 +7287,6 @@
 	switch (sd->sensor) {
 	case SENSOR_CS2102:		/* gamma set in xxx_Initial */
 	case SENSOR_CS2102K:
-	case SENSOR_HDCS2020:
 	case SENSOR_HDCS2020b:
 	case SENSOR_PB0330:		/* pb with chip_revision - see above */
 	case SENSOR_OV7630C:
@@ -7282,6 +7299,7 @@
 	setmatrix(gspca_dev);			/* one more time? */
 	switch (sd->sensor) {
 	case SENSOR_OV7620:
+	case SENSOR_PAS202B:
 		reg_r(gspca_dev, 0x0180);	/* from win */
 		reg_w(dev, 0x00, 0x0180);
 		break;
@@ -7293,37 +7311,29 @@
 
 	switch (sd->sensor) {
 	case SENSOR_GC0305:
-	case SENSOR_OV7620:
 		reg_w(dev, 0x09, 0x01ad);	/* (from win traces) */
 		reg_w(dev, 0x15, 0x01ae);
-		sd->autogain = 0;
-		break;
+		/* fall thru */
+	case SENSOR_PAS202B:
 	case SENSOR_PO2030:
-		reg_w(dev, 0x40, 0x0117);	/* (from win traces) */
-		reg_r(gspca_dev, 0x0180);
-		break;
-	}
-
-	setautogain(gspca_dev);
-	switch (sd->sensor) {
-	case SENSOR_GC0305:
-/*		setlightfreq(gspca_dev);	?? (end: 80 -> [18d]) */
-		reg_w(dev, 0x09, 0x01ad);	/* (from win traces) */
-		reg_w(dev, 0x15, 0x01ae);
-		reg_w(dev, 0x40, 0x0180);
-		reg_w(dev, 0x40, 0x0117);
+/*		reg_w(dev, 0x40, ZC3XX_R117_GGAIN);  * (from win traces) */
 		reg_r(gspca_dev, 0x0180);
-		sd->autogain = 1;
-		setautogain(gspca_dev);
 		break;
 	case SENSOR_OV7620:
+		reg_w(dev, 0x09, 0x01ad);
+		reg_w(dev, 0x15, 0x01ae);
 		i2c_read(gspca_dev, 0x13);	/*fixme: returns 0xa3 */
 		i2c_write(gspca_dev, 0x13, 0xa3, 0x00);
 					 /*fixme: returned value to send? */
-		reg_w(dev, 0x40, 0x0117);	/* (from win traces) */
+		reg_w(dev, 0x40, 0x0117);
 		reg_r(gspca_dev, 0x0180);
-		setautogain(gspca_dev);
-		msleep(500);
+		break;
+	}
+
+	setautogain(gspca_dev);
+	switch (sd->sensor) {
+	case SENSOR_PAS202B:
+		reg_w(dev, 0x00, 0x0007);	/* (from win traces) */
 		break;
 	case SENSOR_PO2030:
 		msleep(500);
@@ -7333,6 +7343,8 @@
 		reg_w(dev, 0x02, 0x0008);
 		break;
 	}
+	if (sd->sensor == SENSOR_PAS202B)
+		reg_w(dev, 0x02, ZC3XX_R008_CLOCKSETTING);
 	return 0;
 }
 
