
ChangeSet@1.2039, 2005-02-23 23:06:26+01:00, vojtech@suse.cz
  input: Add support for less usual ALPS touchpads, rearrange code,
         separate touchpoint/passthrough into its own input device.
  
Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
---

 linux-petero/drivers/input/mouse/alps.c |  262 +++++++++++++++++---------------
 linux-petero/drivers/input/mouse/alps.h |    8 
 2 files changed, 147 insertions(+), 123 deletions(-)

diff -puN drivers/input/mouse/alps.c~p00007_alps-more-protocols drivers/input/mouse/alps.c
--- linux/drivers/input/mouse/alps.c~p00007_alps-more-protocols	2005-04-21 20:01:53.316258944 +0200
+++ linux-petero/drivers/input/mouse/alps.c	2005-04-21 20:01:53.321258184 +0200
@@ -4,6 +4,7 @@
  * Copyright (c) 2003 Neil Brown <neilb@cse.unsw.edu.au>
  * Copyright (c) 2003 Peter Osterlund <petero2@telia.com>
  * Copyright (c) 2004 Dmitry Torokhov <dtor@mail.ru>
+ * Copyright (c) 2005 Vojtech Pavlik <vojtech@suse.cz>
  *
  * ALPS detection, tap switching and status querying info is taken from
  * tpconfig utility (by C. Scott Ananian and Bruce Kall).
@@ -27,53 +28,52 @@
 #define dbg(format, arg...) do {} while (0)
 #endif
 
-#define ALPS_MODEL_GLIDEPOINT	1
-#define ALPS_MODEL_DUALPOINT	2
+#define ALPS_DUALPOINT	0x01
+#define ALPS_WHEEL	0x02
+#define ALPS_FW_BK	0x04
+#define ALPS_4BTN	0x08
+#define ALPS_OLDPROTO	0x10
 
 struct alps_model_info {
 	unsigned char signature[3];
-	unsigned char model;
+	unsigned char flags;
 } alps_model_data[] = {
-/*	{ { 0x33, 0x02, 0x0a },	ALPS_MODEL_GLIDEPOINT },	*/
-	{ { 0x53, 0x02, 0x0a },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x53, 0x02, 0x14 },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x63, 0x02, 0x0a },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x63, 0x02, 0x14 },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x73, 0x02, 0x0a },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x73, 0x02, 0x14 },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x63, 0x02, 0x28 },	ALPS_MODEL_GLIDEPOINT },
-/*	{ { 0x63, 0x02, 0x3c },	ALPS_MODEL_GLIDEPOINT },	*/
-/*	{ { 0x63, 0x02, 0x50 },	ALPS_MODEL_GLIDEPOINT },	*/
-	{ { 0x63, 0x02, 0x64 },	ALPS_MODEL_GLIDEPOINT },
-	{ { 0x20, 0x02, 0x0e },	ALPS_MODEL_DUALPOINT },
-	{ { 0x22, 0x02, 0x0a },	ALPS_MODEL_DUALPOINT },
-	{ { 0x22, 0x02, 0x14 }, ALPS_MODEL_DUALPOINT },
-	{ { 0x63, 0x03, 0xc8 },	ALPS_MODEL_DUALPOINT },
+	{ { 0x33, 0x02, 0x0a },	ALPS_OLDPROTO },
+	{ { 0x53, 0x02, 0x0a },	0 },
+	{ { 0x53, 0x02, 0x14 },	0 },
+	{ { 0x63, 0x02, 0x0a },	0 },
+	{ { 0x63, 0x02, 0x14 },	0 },
+	{ { 0x63, 0x02, 0x28 },	0 },
+	{ { 0x63, 0x02, 0x3c },	ALPS_WHEEL },
+	{ { 0x63, 0x02, 0x50 },	ALPS_FW_BK },
+	{ { 0x63, 0x02, 0x64 },	0 },
+	{ { 0x63, 0x03, 0xc8 }, 0 },
+	{ { 0x73, 0x02, 0x0a },	0 },
+	{ { 0x73, 0x02, 0x14 },	0 },
+	{ { 0x20, 0x02, 0x0e },	ALPS_DUALPOINT }, /* XXX */
+	{ { 0x22, 0x02, 0x0a },	ALPS_DUALPOINT },
+	{ { 0x22, 0x02, 0x14 }, ALPS_DUALPOINT },
 };
 
 /*
- * ALPS abolute Mode
- * byte 0:  1    1    1    1    1  mid0 rig0 lef0
+ * XXX - this entry is suspicious. First byte has zero lower nibble,
+ * which is what a normal mouse would report. Also, the value 0x0e
+ * isn't valid per PS/2 spec.
+ */
+
+/*
+ * ALPS abolute Mode - new format
+ *
+ * byte 0:  1    ?    ?    ?    1    ?    ?    ?
  * byte 1:  0   x6   x5   x4   x3   x2   x1   x0
- * byte 2:  0   x10  x9   x8   x7  up1  fin  ges
- * byte 3:  0   y9   y8   y7    1  mid1 rig1 lef1
+ * byte 2:  0   x10  x9   x8   x7    ?  fin  ges
+ * byte 3:  0   y9   y8   y7    1    M    R    L
  * byte 4:  0   y6   y5   y4   y3   y2   y1   y0
  * byte 5:  0   z6   z5   z4   z3   z2   z1   z0
  *
- * On a dualpoint, {mid,rig,lef}0 are the stick, 1 are the pad.
- * We just 'or' them together for now.
- *
- * We used to send 'ges'tures as BTN_TOUCH but this made it impossible
- * to disable tap events in the synaptics driver since the driver
- * was unable to distinguish a gesture tap from an actual button click.
- * A tap gesture now creates an emulated touch that the synaptics
- * driver can interpret as a tap event, if MaxTapTime=0 and
- * MaxTapMove=0 then the driver will ignore taps.
- *
- * The touchpad on an 'Acer Aspire' has 4 buttons:
- *   left,right,up,down.
- * This device always sets {mid,rig,lef}0 to 1 and
- * reflects left,right,down,up in lef1,rig1,mid1,up1.
+ * ?'s can have different meanings on different models,
+ * such as wheel rotation, extra buttons, stick buttons
+ * on a dualpoint, etc.
  */
 
 static void alps_process_packet(struct psmouse *psmouse, struct pt_regs *regs)
@@ -81,57 +81,60 @@ static void alps_process_packet(struct p
 	struct alps_data *priv = psmouse->private;
 	unsigned char *packet = psmouse->packet;
 	struct input_dev *dev = &psmouse->dev;
-	int x, y, z;
-	int left = 0, right = 0, middle = 0;
-	int ges, fin;
+	struct input_dev *dev2 = &priv->dev2;
+	int x, y, z, ges, fin, left, right, middle;
 
 	input_regs(dev, regs);
 
 	if ((packet[0] & 0xc8) == 0x08) {   /* 3-byte PS/2 packet */
-		x = packet[1];
-		if (packet[0] & 0x10)
-			x = x - 256;
-		y = packet[2];
-		if (packet[0] & 0x20)
-			y = y - 256;
-		left  = (packet[0]     ) & 1;
-		right = (packet[0] >> 1) & 1;
-
-		input_report_rel(dev, REL_X, x);
-		input_report_rel(dev, REL_Y, -y);
-		input_report_key(dev, BTN_A, left);
-		input_report_key(dev, BTN_B, right);
-		input_sync(dev);
+		input_report_key(dev2, BTN_LEFT,   packet[0] & 1);
+		input_report_key(dev2, BTN_RIGHT,  packet[0] & 2);
+		input_report_key(dev2, BTN_MIDDLE, packet[0] & 4);
+		input_report_rel(dev2, REL_X, packet[1] ?
+			(int) packet[1] - (int) ((packet[0] << 4) & 0x100) : 0);
+		input_report_rel(dev2, REL_Y, packet[2] ?
+			(int) ((packet[0] << 3) & 0x100) - (int) packet[2] : 0);
+		input_sync(dev2);
 		return;
 	}
 
-	x = (packet[1] & 0x7f) | ((packet[2] & 0x78)<<(7-3));
-	y = (packet[4] & 0x7f) | ((packet[3] & 0x70)<<(7-4));
-	z = packet[5];
-
-	if ((priv->model == ALPS_MODEL_DUALPOINT) && (z == 127)) {
-		/* DualPoint stick, relative packet */
-		if (x > 383)
-			x = x - 768;
-		if (y > 255)
-			y = y - 512;
-		left  = packet[3] & 1;
-		right = (packet[3] >> 1) & 1;
-
-		input_report_rel(dev, REL_X, x);
-		input_report_rel(dev, REL_Y, -y);
-		input_report_key(dev, BTN_LEFT, left);
-		input_report_key(dev, BTN_RIGHT, right);
-		input_sync(dev);
-		return;
+	if (priv->flags & ALPS_OLDPROTO) {
+		left = packet[2] & 0x08;
+		right = packet[2] & 0x10;
+		middle = 0;
+		x = (packet[1] & 0x7f) | ((packet[0] & 0x07) << 7);
+		y = (packet[4] & 0x7f) | ((packet[3] & 0x07) << 7);
+		z = packet[5];
+	} else {
+		left = packet[3] & 1;
+		right = packet[3] & 2;
+		middle = packet[3] & 4;
+		x = (packet[1] & 0x7f) | ((packet[2] & 0x78) << (7 - 3));
+		y = (packet[4] & 0x7f) | ((packet[3] & 0x70) << (7 - 4));
+		z = packet[5];
+	}
+
+	ges = packet[2] & 1;
+	fin = packet[2] & 2;
+
+	/* Dualpoint has stick buttons in byte 0 */
+	if (priv->flags & ALPS_DUALPOINT) {
+
+		input_report_key(dev2, BTN_LEFT,    packet[0]       & 1);
+		input_report_key(dev2, BTN_MIDDLE, (packet[0] >> 2) & 1);
+		input_report_key(dev2, BTN_RIGHT,  (packet[0] >> 1) & 1);
+
+		/* Relative movement packet */
+ 		if (z == 127) {
+			input_report_rel(dev2, REL_X,  (x > 383 ? x : (x - 768)));
+			input_report_rel(dev2, REL_Y, -(y > 255 ? y : (x - 512)));
+			input_sync(dev2);
+			return;
+		}
 	}
 
-	ges = packet[2] & 1;		    /* gesture bit */
-	fin = packet[2] & 2;		    /* finger bit */
-
 	/* Convert hardware tap to a reasonable Z value */
-	if (ges && !fin)
-		z = 40;
+	if (ges && !fin) z = 40;
 
 	/*
 	 * A "tap and drag" operation is reported by the hardware as a transition
@@ -154,32 +157,22 @@ static void alps_process_packet(struct p
 		input_report_abs(dev, ABS_X, x);
 		input_report_abs(dev, ABS_Y, y);
 	}
+
 	input_report_abs(dev, ABS_PRESSURE, z);
 	input_report_key(dev, BTN_TOOL_FINGER, z > 0);
 
-	left  |= (packet[3]     ) & 1;
-	right |= (packet[3] >> 1) & 1;
-	if (packet[0] == 0xff) {
-		int back    = (packet[3] >> 2) & 1;
-		int forward = (packet[2] >> 2) & 1;
-		if (back && forward) {
-			middle = 1;
-			back = 0;
-			forward = 0;
-		}
-		input_report_key(dev, BTN_BACK,    back);
-		input_report_key(dev, BTN_FORWARD, forward);
-	} else {
-		left   |= (packet[0]     ) & 1;
-		right  |= (packet[0] >> 1) & 1;
-		middle |= (packet[0] >> 2) & 1;
-		middle |= (packet[3] >> 2) & 1;
-	}
-
 	input_report_key(dev, BTN_LEFT, left);
 	input_report_key(dev, BTN_RIGHT, right);
 	input_report_key(dev, BTN_MIDDLE, middle);
 
+	if (priv->flags & ALPS_WHEEL)
+		input_report_rel(dev, REL_WHEEL, ((packet[0] >> 4) & 0x07) | ((packet[2] >> 2) & 0x08));
+
+	if (priv->flags & ALPS_FW_BK) {
+		input_report_key(dev, BTN_FORWARD, packet[0] & 0x10);
+		input_report_key(dev, BTN_BACK, packet[2] & 0x04);
+	}
+
 	input_sync(dev);
 }
 
@@ -194,7 +187,7 @@ static psmouse_ret_t alps_process_byte(s
 	}
 
 	/* ALPS absolute mode packets start with 0b11111mrl */
-	if ((psmouse->packet[0] & 0xf8) != 0xf8)
+	if ((psmouse->packet[0] & 0x88) != 0x88)
 		return PSMOUSE_BAD_DATA;
 
 	/* Bytes 2 - 6 should have 0 in the highest bit */
@@ -219,7 +212,7 @@ int alps_get_model(struct psmouse *psmou
 
 	/*
 	 * First try "E6 report".
-	 * ALPS should return 0x00,0x00,0x0a or 0x00,0x00,0x64
+	 * ALPS should return 0,0,10 or 0,0,100
 	 */
 	param[0] = 0;
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||
@@ -234,10 +227,13 @@ int alps_get_model(struct psmouse *psmou
 
 	dbg("E6 report: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);
 
-	if (param[0] != 0x00 || param[1] != 0x00 || (param[2] != 0x0a && param[2] != 0x64))
+	if (param[0] != 0 || param[1] != 0 || (param[2] != 10 && param[2] != 100))
 		return -1;
 
-	/* Now try "E7 report". ALPS should return 0x33 in byte 1 */
+	/*
+	 * Now try "E7 report". Allowed responses are in
+	 * alps_model_data[].signature
+	 */
 	param[0] = 0;
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||
 	    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||
@@ -252,11 +248,11 @@ int alps_get_model(struct psmouse *psmou
 	dbg("E7 report: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);
 
 	for (i = 0; i < ARRAY_SIZE(rates) && param[2] != rates[i]; i++);
-	*version = (param[0] << 8) | (i << 4) | (param[1] & 0x0f);
+	*version = (param[0] << 8) | (param[1] << 4) | i;
 
 	for (i = 0; i < ARRAY_SIZE(alps_model_data); i++)
 		if (!memcmp(param, alps_model_data[i].signature, sizeof(alps_model_data[i].signature)))
-			return alps_model_data[i].model;
+			return alps_model_data[i].flags;
 
 	return -1;
 }
@@ -353,10 +349,10 @@ static int alps_reconnect(struct psmouse
 	unsigned char param[4];
 	int version;
 
-	if ((priv->model = alps_get_model(psmouse, &version)) < 0)
+	if ((priv->flags = alps_get_model(psmouse, &version)) < 0)
 		return -1;
 
-	if (priv->model == ALPS_MODEL_DUALPOINT && alps_passthrough_mode(psmouse, 1))
+	if (priv->flags & ALPS_DUALPOINT && alps_passthrough_mode(psmouse, 1))
 		return -1;
 
 	if (alps_get_status(psmouse, param))
@@ -370,7 +366,7 @@ static int alps_reconnect(struct psmouse
 		return -1;
 	}
 
-	if (priv->model == ALPS_MODEL_DUALPOINT && alps_passthrough_mode(psmouse, 0))
+	if (priv->flags == ALPS_DUALPOINT && alps_passthrough_mode(psmouse, 0))
 		return -1;
 
 	return 0;
@@ -378,8 +374,10 @@ static int alps_reconnect(struct psmouse
 
 static void alps_disconnect(struct psmouse *psmouse)
 {
+	struct alps_data *priv = psmouse->private;
 	psmouse_reset(psmouse);
-	kfree(psmouse->private);
+	input_unregister_device(&priv->dev2);
+	kfree(priv);
 }
 
 int alps_init(struct psmouse *psmouse)
@@ -393,13 +391,13 @@ int alps_init(struct psmouse *psmouse)
 		goto init_fail;
 	memset(priv, 0, sizeof(struct alps_data));
 
-	if ((priv->model = alps_get_model(psmouse, &version)) < 0)
+	if ((priv->flags = alps_get_model(psmouse, &version)) < 0)
 		goto init_fail;
 
 	printk(KERN_INFO "ALPS Touchpad (%s) detected\n",
-		priv->model == ALPS_MODEL_GLIDEPOINT ? "Glidepoint" : "Dualpoint");
+		(priv->flags & ALPS_DUALPOINT) ? "DualPoint" : "GlidePoint");
 
-	if (priv->model == ALPS_MODEL_DUALPOINT && alps_passthrough_mode(psmouse, 1))
+	if ((priv->flags & ALPS_DUALPOINT) && alps_passthrough_mode(psmouse, 1))
 		goto init_fail;
 
 	if (alps_get_status(psmouse, param)) {
@@ -418,24 +416,42 @@ int alps_init(struct psmouse *psmouse)
 		goto init_fail;
 	}
 
-	if (priv->model == ALPS_MODEL_DUALPOINT && alps_passthrough_mode(psmouse, 0))
+	if ((priv->flags & ALPS_DUALPOINT) && alps_passthrough_mode(psmouse, 0))
 		goto init_fail;
 
-	psmouse->dev.evbit[LONG(EV_REL)] |= BIT(EV_REL);
-	psmouse->dev.relbit[LONG(REL_X)] |= BIT(REL_X);
-	psmouse->dev.relbit[LONG(REL_Y)] |= BIT(REL_Y);
-	psmouse->dev.keybit[LONG(BTN_A)] |= BIT(BTN_A);
-	psmouse->dev.keybit[LONG(BTN_B)] |= BIT(BTN_B);
+	psmouse->dev.evbit[LONG(EV_KEY)] |= BIT(EV_KEY);
+	psmouse->dev.keybit[LONG(BTN_TOUCH)] |= BIT(BTN_TOUCH);
+	psmouse->dev.keybit[LONG(BTN_TOOL_FINGER)] |= BIT(BTN_TOOL_FINGER);
+	psmouse->dev.keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_MIDDLE) | BIT(BTN_RIGHT);
 
 	psmouse->dev.evbit[LONG(EV_ABS)] |= BIT(EV_ABS);
 	input_set_abs_params(&psmouse->dev, ABS_X, 0, 1023, 0, 0);
 	input_set_abs_params(&psmouse->dev, ABS_Y, 0, 767, 0, 0);
 	input_set_abs_params(&psmouse->dev, ABS_PRESSURE, 0, 127, 0, 0);
 
-	psmouse->dev.keybit[LONG(BTN_TOUCH)] |= BIT(BTN_TOUCH);
-	psmouse->dev.keybit[LONG(BTN_TOOL_FINGER)] |= BIT(BTN_TOOL_FINGER);
-	psmouse->dev.keybit[LONG(BTN_FORWARD)] |= BIT(BTN_FORWARD);
-	psmouse->dev.keybit[LONG(BTN_BACK)] |= BIT(BTN_BACK);
+	if (priv->flags & ALPS_WHEEL) {
+		psmouse->dev.evbit[LONG(EV_REL)] |= BIT(EV_REL);
+		psmouse->dev.relbit[LONG(REL_WHEEL)] |= BIT(REL_WHEEL);
+	}
+
+	if (priv->flags & ALPS_FW_BK) {
+		psmouse->dev.keybit[LONG(BTN_FORWARD)] |= BIT(BTN_FORWARD);
+		psmouse->dev.keybit[LONG(BTN_BACK)] |= BIT(BTN_BACK);
+	}
+
+	sprintf(priv->phys, "%s/input1", psmouse->ps2dev.serio->phys);
+	priv->dev2.phys = priv->phys;
+	priv->dev2.name = (priv->flags & ALPS_DUALPOINT) ? "DualPoint Stick" : "PS/2 Mouse";
+	priv->dev2.id.bustype = BUS_I8042;
+	priv->dev2.id.vendor = 0x0002;
+	priv->dev2.id.product = PSMOUSE_ALPS;
+	priv->dev2.id.version = 0x0000;
+
+	priv->dev2.evbit[0] = BIT(EV_KEY) | BIT(EV_REL);
+	priv->dev2.relbit[LONG(REL_X)] |= BIT(REL_X) | BIT(REL_Y);
+	priv->dev2.keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_MIDDLE) | BIT(BTN_RIGHT);
+
+	input_register_device(&priv->dev2);
 
 	psmouse->protocol_handler = alps_process_byte;
 	psmouse->disconnect = alps_disconnect;
@@ -452,13 +468,17 @@ init_fail:
 int alps_detect(struct psmouse *psmouse, int set_properties)
 {
 	int version;
+	int model;
 
-	if (alps_get_model(psmouse, &version) < 0)
+	if ((model = alps_get_model(psmouse, &version)) < 0)
 		return -1;
 
 	if (set_properties) {
 		psmouse->vendor = "ALPS";
-		psmouse->name = "TouchPad";
+		if (model & ALPS_DUALPOINT)
+			psmouse->name = "DualPoint TouchPad";
+		else
+			psmouse->name = "GlidePoint";
 		psmouse->model = version;
 	}
 	return 0;
diff -puN drivers/input/mouse/alps.h~p00007_alps-more-protocols drivers/input/mouse/alps.h
--- linux/drivers/input/mouse/alps.h~p00007_alps-more-protocols	2005-04-21 20:01:53.317258792 +0200
+++ linux-petero/drivers/input/mouse/alps.h	2005-04-21 20:01:53.321258184 +0200
@@ -2,6 +2,7 @@
  * ALPS touchpad PS/2 mouse driver
  *
  * Copyright (c) 2003 Peter Osterlund <petero2@telia.com>
+ * Copyright (c) 2005 Vojtech Pavlik <vojtech@suse.cz>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published by
@@ -15,8 +16,11 @@ int alps_detect(struct psmouse *psmouse,
 int alps_init(struct psmouse *psmouse);
 
 struct alps_data {
-	int model;			    /* Glidepoint or Dualpoint */
-	int prev_fin;			    /* Finger bit from previous packet */
+	struct input_dev dev2;	/* Relative device */
+	char name[32];		/* Name */
+	char phys[32];		/* Phys */
+	int flags;		/* Protocol details */
+	int prev_fin;		/* Finger bit from previous packet */
 };
 
 #endif
_
