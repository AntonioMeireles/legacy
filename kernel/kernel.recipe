#
# Copyright (c) 2004-2005 rpath, Inc.
# All rights reserved
#
# bootsplash testing lines - search for GIL

class Kernel(PackageRecipe):
    buildRequires = [ 'perl:runtime', 'module-init-tools:runtime' ]

    name = 'kernel'
    version = '2.6.12.3'
    # GIL - new serial for bootsplash edition
    serial = 'fdl.2'
    # Every change that is expected to change interfaces requires
    # a change in serial string.  No two kernels of the same flavor
    # and serial can be installed at once due to path conflicts.
    # The serial string has no semantic content; a higher number
    # is not necessarily "more recent" than a lower number.
    # The same serial string may be re-used on different branches;
    # it only differentiates kernels with the same %(version)s
    # within a branch or set of related branches.
    #
    # Pure integer serial strings are reserved for rpath.com
    # Inheriting repositories should use some other rule (decimal
    # numbers, letters, etc.) than all repositories above them in
    # their inheritance tree; especially a different rule from their
    # direct parent.  The example.com@linux repository might use
    # serial = 'example.n'.  As long as the string is different
    # for every kernel with the same %(version)s on all branches
    # that might be installed on a single machine, it will work.
    #
    # This is needed because patches to the kernel, changes in
    # compilation flags, and changes in configuration can all make
    # changes to binary interfaces within the kernel.

    Flags.debug = False
    Flags.debug.setShortDoc('Enable kernel debugging options')
    Flags.smp = True
    Flags.smp.setShortDoc('Enable SMP support')
    Flags.numa = False
    Flags.numa.setShortDoc('Enable NUMA support')
    Flags.debugdata = False
    Flags.debugdata.setShortDoc('Enable saving debug data in :debuginfo')

    configs = (
        # list of (basearch, flaglist, dictlist) tuples:
        # basearch is Arch.basearch
        # flaglist is Arch.basearch.flag for flag in flaglist;
        # where the most specific match "wins"
        # dictlist is list of sets of keyword args to the
        # addConfigs.do_one() function -- see the available keys and
        # default values in the addConfigs.do_one() definition
        ('x86', (), (
            {},
        )),
        ('x86', ('i586',), (
            {},
        )),
        ('x86', ('i586', 'mmx'), (
            {},
            {'smp':True}
        )),
        ('x86', ('i686',), (
            {},
        )),
        ('x86', ('i686', 'cmov'), (
            {},
            {'smp':True},
        )),
        ('x86_64', (), (
            {},
            {'smp':True},
        )),
    )

    def setup(r):
        r.unpack()
        r.configure()
        r.build()

    def unpack(r):
        r.macros.majorversion = ".".join(r.version.split('.')[0:2])
        r.macros.sublevel = r.version.split('.')[-2]
        r.macros.serial = r.serial
        r.mainDir('linux-%(version)s')
        # r.macros.cfgver is set while creating configurations
        # (ah, the wonders of delayed evaluation!)
        r.macros.localversion = '-%(serial)s%(cfgver)s'
        r.macros.kver = '%(version)s%(localversion)s'
        r.macros.sourcever = '%(version)s-%(serial)s'

        # get the last 64 (UTS_LEN) or fewer characters of the parts of
        # the buildLabel to use instead of the username and hostname the
        # kernel was built by/on.
        if '@' not in r.macros.buildlabel:
            # we need an @, use a default string with an @...
            r.macros.buildlabel = 'local@local:LOCAL'
        buildrep, branchname = r.macros.buildlabel.split('@')
        r.macros.buildrep = buildrep[-64:]
        r.macros.branchname = branchname[-64:]

        if not r.Flags.debugdata:
            r.Strip(debuginfo=False)

        r.addArchive(
            'http://ftp.kernel.org/pub/linux/kernel/v%(majorversion)s/linux-%(version)s.tar.bz2',
            keyid='517D0F0E'
        )
        r.addAction(r"""sed -i '
            s/`whoami`/%(buildrep)s/
            s/`hostname | $UTS_TRUNCATE`/%(branchname)s/
            s/ ."`dnsdomainname | $UTS_TRUNCATE`."//
            s/ ."`domainname | $UTS_TRUNCATE`."//
            ' scripts/mkcompile_h""")

        # Inotify patch
        r.addPatch('inotify-0.23-rml-2.6.12-rc6-13.patch')

        # GIL - bootsplash patch
        r.addPatch('bootsplash-3.1.6-2.6.12.diff')

        # Red Hat's nonint_oldconfig to avoid requests for interactive response
        r.addPatch('linux-2.4.0-nonintconfig.patch')

        # Override any "-pre" or premature increment of SUBLEVEL from patches
        r.addAction('sed -i "s/^SUBLEVEL.*/SUBLEVEL = %(sublevel)s/" Makefile')

    def configure(r):
        # Since we will get kernel-source:tree out of this tree, clean it up
        r.addAction('find . -name "*.orig" | xargs rm -f')
        r.addAction('find . -name "*~" | xargs rm -f')
        r.addAction('make -s mrproper')
        r.extraSource(addConfigs(r))

    def build(r):
        r.Create('localversion.rpl', contents='%(localversion)s')
        r.Make('nonint_oldconfig 2>oc.err || { cat oc.err; diff -u .config.old .config > config.changes ; exit 1; }')
        # if we get here, this file is empty, remove it
        r.Run('rm oc.err')
        r.Make('bzImage modules')
        r.Make('-s INSTALL_MOD_PATH=%(destdir)s modules_install KERNELRELEASE=%(kver)s')
        r.Install('System.map', '/boot/System.map-%(kver)s', mode=0644)
        r.Install('.config', '/boot/config-%(kver)s', mode=0644)
        r.Install('arch/*/boot/bzImage', '/boot/vmlinuz-%(kver)s', mode=0644)
        r.Install('vmlinux', '/lib/modules/%(kver)s/', mode=0644)
        r.Symlink('/lib/modules/%(kver)s/vmlinux', '/boot/vmlinux-%(kver)s')
        r.Requires('bootsplash:runtime', '/boot/vmlinux-%(kver)s')
        # remove autogenerated files
        r.Remove('/lib/modules/%(kver)s/modules.*')
        # remove old symlink
        r.Remove('/lib/modules/%(kver)s/pcmcia', recursive=True)

        # replace build symlink, install headers properly
        r.Remove('/lib/modules/%(kver)s/build', recursive=True)
        r.MakeDirs('/lib/modules/%(kver)s/build')
        r.extraBuild(CreateBuildTree(r))
        r.Remove('/lib/modules/%(kver)s/source', recursive=True)
        r.Symlink('build', '/lib/modules/%(kver)s/source')
        r.Install('configs/*', '/lib/modules/%(kver)s/configs/')

        r.ComponentSpec('configs', '/lib/modules/[^/]*/configs/')
        r.ComponentSpec('build-tree', '/lib/modules/[^/]*/build/')
        r.ComponentSpec('debuginfo', '%(debugsrcdir)s/', '%(debuglibdir)s/')
        r.ComponentSpec('runtime', '.*')
        # do not depend on mkinitrd's kernel tagdescription file
        r.TagSpec('kernel', '/boot/vmlinuz-.*', '/lib/modules/.*/.*\.k?o$')
        if Arch.x86:
            r.Provides('abi: ELF32(SysV x86)', '/boot/vmlinu.*')
        if Arch.x86_64:
            r.Provides('abi: ELF32(SysV x86)', '/boot/vmlinu.*')
            r.Provides('abi: ELF64(SysV x86_64)', '/boot/vmlinu.*')
        r.Provides('soname: libkconfig.so',
                   '/lib/modules/.*/build/scripts/kconfig/libkconfig.so')
        r.Requires('mkinitrd:runtime',
                   r'/lib/modules/%(kver)s/.*\.ko$')
        r.ComponentProvides('%(kver)s')




####################################################################
# The rest of this file contains only supporting classes that
# should not normally need to be modified when modifying the
# kernel package
####################################################################

class CreateBuildTree(build.BuildAction):
    import time
    def do(self, macros):
        builddir = macros.builddir % macros
        bldincdir = builddir+'/include/'
        destdir = '%(destdir)s/lib/modules/%(kver)s/build/' %macros
        destincdir = '%(destdir)s/lib/modules/%(kver)s/build/include/' %macros

        # get the kernel's idea of the architecture we have selected
        asmarch = os.readlink('%(builddir)s/include/asm' %macros)
        arch = asmarch.split('-')[1]

        # Copy config, dependency files, and Makefiles
        os.path.walk(builddir, self.copyDepinfo,
                     (destdir, len(builddir), self.time.time(), arch,
                      re.compile(
                        r'(Kconfig|\.config|\.h?depend|Rules\.make|Makefile'
                         '|asm-offsets\.s|\.tmp_versions|gcc-version\.sh)$')))
        util.copyfile('Module.symvers', destdir)

        # now get all the scripts
        util.copytree('scripts', destdir)
        util.remove('%s/scripts/*.o'%destdir)
        util.remove('%s/scripts/*/*.o'%destdir)
        scriptsdir = 'arch/%s/scripts'%arch
        if os.path.exists(scriptsdir):
            util.copytree(scriptsdir, '%s/arch/%s/' %(destdir, arch))
        util.copyfile('arch/%s/*.lds'%arch, '%s/arch/%s/' %(destdir, arch))

        # Create and populate include directories -- do this last to make
        # timestamps work out for dependencies when building against this tree
        util.mkdirChain(destincdir)
        for entry in os.listdir(bldincdir):
            dir = util.joinPaths(destincdir, entry)
            if entry in ('asm-generic', asmarch) or not entry.startswith('asm'):
                srcpath = util.joinPaths(bldincdir, entry)
                util.copytree(srcpath, destincdir)
        os.symlink(asmarch, destincdir+'/asm')

    def copyDepinfo(self, data, dirname, names):
        destdir, srclen, timestamp, arch, regex = data
        subpath = dirname[srclen+1:]
        pathlist = subpath.split('/')
        topdir = pathlist[0]
        nextdir = ''
        if len(pathlist) > 1:
            nextdir = pathlist[1]
        if topdir in ('include', 'scripts', 'Documentation'):
            return
        if topdir in ('arch',):
            if nextdir != arch:
                return
        util.mkdirChain(util.joinPaths(destdir, subpath))
        for name in names:
            if regex.match(name):
                srcpath = util.joinPaths(dirname, name)
                if not os.path.isdir(srcpath):
                    destpath = util.joinPaths(destdir, subpath, name)
                    util.copyfile(util.joinPaths(dirname, name), destpath)
                    # set the timestamp the same on all files to say
                    # the configuration is up-to-date
                    os.utime(destpath, (timestamp, timestamp))



class addConfigs(action.RecipeAction):
    from build import lookaside

    def __init__(self, *args, **keywords):
        self.sourcemap = {}
        self.failed = False
        self.fetching=False
        action.RecipeAction.__init__(self, *args, **keywords)
        # we need to reference the entire flavor from __init__
        # so that the flavor is determined entirely during the
        # setup phase of loading the recipe, and not modified
        # while cooking (i.e. doAction)
        for flag in Flags.values():
            if flag: pass
        for basearch, flaglist, dictlist in self.recipe.configs:
            for flag in flaglist:
                if Arch[basearch][flag]: pass

    def doAction(self):
        self.confdir = '%(builddir)s/%(maindir)s/configs/' %self.recipe.macros
        action.RecipeAction.doAction(self)

    def fetch(self):
        self.fetching=True
        self.do()
        self.fetching=False
        return self.sourcemap.values()

    def do(self):
        if not self.fetching:
            util.mkdirChain(self.confdir)
        for basearch, flaglist, dictlist in self.recipe.configs:
            for dict in dictlist:
                self.do_one(basearch, flaglist, **dict)
        if self.failed:
            raise KernelConfigError, 'all keys set in any config file must be in config.base,\nbecause the order of the keys matters'


    def do_one(self, arch, flaglist, smp=False, numa=False):
        config = self.config()

        thisArch = True and Arch[arch]

        if self.recipe.Flags.debug:
            self.mergefile(config, 'config.debug', unamePrefix=True)

        if smp:
            self.mergefile(config, 'config.smp', unamePrefix=True)
        if smp != self.recipe.Flags.smp:
            if not self.fetching:
                print ' disallowing this config for SMP mismatch'
            thisArch = False

        if numa:
            self.mergefile(config, 'config.numa', unamePrefix=True)
        if numa != self.recipe.Flags.numa:
            if not self.fetching:
                print ' disallowing this config for NUMA mismatch'
            thisArch = False

        flaglen = len(flaglist)
        self.mergefile(config, 'config.' + arch, unameArch=(flaglen == 0))

        selection = arch
        for index in range(flaglen):
            flag = flaglist[index]
            if thisArch and not Arch[arch][flag]:
                if not self.fetching:
                    print ' disallowing this config for unset', flag
                thisArch = False
            selection += '.' + flag
            currentInFile = 'config.' + selection
            self.mergefile(config, currentInFile, unameArch=(index == flaglen-1))
            # some feature-specific flags require platform-specific changes
            if self.recipe.Flags.debug:
                self.mergefile(config, currentInFile + '.debug')
            if smp:
                self.mergefile(config, currentInFile + '.smp')
            if numa:
                self.mergefile(config, currentInFile + '.numa')

        # must come last
        self.mergefile(config, 'config.override')

        if not self.fetching:
            if config.failed:
                self.failed = True
                return

            config.write(self.confdir)

            if thisArch:
                # This is the one true .config
                util.copyfile(config.filename(self.confdir),
                    '%(builddir)s/%(maindir)s/.config' %self.recipe.macros)
                self.recipe.macros.cfgver = config.unamePrefix+config.unameArch
                print 'building with cfgver = "%s"' %self.recipe.macros.cfgver

    def config(self):
        f = self.lookaside.findAll(self.recipe.cfg, self.recipe.laReposCache,
                'config.base', self.recipe.name, self.recipe.srcdirs)
        self.sourcemap['config.base'] = f
        if self.fetching:
            return None
        return KernelConfig(self.sourcemap['config.base'])

    def mergefile(self, config, filename, unamePrefix=False, unameArch=False):
        # searchAll because it is allowed to fail
        f = self.lookaside.searchAll(self.recipe.cfg, self.recipe.laReposCache,
            filename, self.recipe.name, self.recipe.srcdirs)
        if f:
            self.sourcemap[filename] = f

        if self.fetching:
            return

        if f:
            config.mergefile(f)

        # chop off the config part
        configdata = filename[6:]
        if unamePrefix:
            config.setUnamePrefix(configdata)
        elif unameArch:
            config.setUnameArch(configdata)


class KernelConfig(list):
    """
    A list of key=value pairs that can be addressed as a dictionary
    that maps key to value, in which setting self[key]=otherval will
    modify the list in-place.
    """
    def __init__(self, filename):
        self.dict = {}
        self.index = {}
        self.unamePrefix = ''
        self.unameArch = ''
        self.warn = False
        self.failed = False
        self.basefilename = filename
        print 'reading', filename
        f = file(filename)
        self.extend(f.read().split('\n'))
        f.close
        self.warn = True
    def setUnamePrefix(self, data):
        self.unamePrefix += data
    def setUnameArch(self, data):
        self.unameArch = data
    def mergefile(self, filename):
        if os.path.exists(filename):
            print ' merging', filename
            f = file(filename)
            self.applylines(f.read().split('\n'))
            f.close()
    def write(self, dirname):
        f = file(self.filename(dirname), 'w')
        # kernel config files need weird syntax
        self.commentNo()
        f.write("\n".join(self))
        f.close()
    def filename(self, dirname):
        return dirname+'/config'+self.unamePrefix+self.unameArch
    def extend(self, items):
        for item in items:
            self.append(item)
    def append(self, item):
        if self._isval(item):
            key, val = item.split("=")
            if self.warn:
                if key not in self:
                    print 'warning: key %s not found in %s' %(key, self.basefilename)
                    self.failed = True
            else:
                if key in self:
                    # need value stored more than one place
                    list.append(self, item)
                    self.index[key].append(len(self)-1)
            self[key] = val
        else:
            # probably a comment or empty line; just preserve it
            list.append(self, item)
    def applyline(self, line):
        "Do not append a line, only change a value if it is a key=value"
        if self._isval(line):
            self.append(line)
    def applylines(self, lines):
        for line in lines:
            self.applyline(line)
    def _isval(self, item):
        return item.find("=") != -1 and not item.startswith('#')
    def commentNo(self):
        # unusual comment-for-no syntax
        for index in range(len(self)):
            line = self[index]
            if line.endswith("=n"):
                key = line.split("=")[0]
                list.__setitem__(self, index, "# %s is not set" %key)
    def __getitem__(self, key):
        if type(key) == type(""):
            return self.dict[key]
        else:
            return list.__getitem__(self, key)
    def __setitem__(self, key, val):
        line = "=".join((key, val))
        if key in self.dict:
            for index in self.index[key]:
                # make sure all instances are consistent
                list.__setitem__(self, index, line)
            self.dict[key] = val
        else:
            list.append(self, line)
            self.dict[key] = val
            self.index[key] = [ len(self)-1 ]
    def __delitem__(self, key):
        raise IndexError, 'dictionary is append/modify-only'
    def __contains__(self, item):
        return item in self.dict

class KernelConfigError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __repr__(self):
        return self.msg
    def __str__(self):
        return repr(self)
