commit 7e6bc5478812972b61e8d273028c9494d69b2665
Author: Roland McGrath <roland@redhat.com>
Date:   Mon Oct 13 18:36:05 2008 -0700

    x86 syscall.h: fix argument order
    
    Petr Tesarik noticed that I'd bungled the syscall_get_arguments code for
    64-bit kernels, so it inverted the order of the syscall argument registers.
    Petr wrote a patch to fix that, and I've amended it to fix the same braino
    in the syscall_set_arguments code.
    
    Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
    Signed-off-by: Roland McGrath <roland@redhat.com>
---
 include/asm-x86/syscall.h |  106 +++++++++++++++++++++++----------------------
 1 files changed, 54 insertions(+), 52 deletions(-)

diff --git a/include/asm-x86/syscall.h b/include/asm-x86/syscall.h
index 04c47dc..ec2a95e 100644
--- a/include/asm-x86/syscall.h
+++ b/include/asm-x86/syscall.h
@@ -93,26 +93,26 @@ static inline void syscall_get_arguments(struct task_struct *task,
 {
 # ifdef CONFIG_IA32_EMULATION
 	if (task_thread_info(task)->status & TS_COMPAT)
-		switch (i + n) {
-		case 6:
+		switch (i) {
+		case 0:
 			if (!n--) break;
-			*args++ = regs->bp;
-		case 5:
+			*args++ = regs->bx;
+		case 1:
 			if (!n--) break;
-			*args++ = regs->di;
-		case 4:
+			*args++ = regs->cx;
+		case 2:
 			if (!n--) break;
-			*args++ = regs->si;
+			*args++ = regs->dx;
 		case 3:
 			if (!n--) break;
-			*args++ = regs->dx;
-		case 2:
+			*args++ = regs->si;
+		case 4:
 			if (!n--) break;
-			*args++ = regs->cx;
-		case 1:
+			*args++ = regs->di;
+		case 5:
 			if (!n--) break;
-			*args++ = regs->bx;
-		case 0:
+			*args++ = regs->bp;
+		case 6:
 			if (!n--) break;
 		default:
 			BUG();
@@ -120,26 +120,26 @@ static inline void syscall_get_arguments(struct task_struct *task,
 		}
 	else
 # endif
-		switch (i + n) {
-		case 6:
+		switch (i) {
+		case 0:
 			if (!n--) break;
-			*args++ = regs->r9;
-		case 5:
+			*args++ = regs->di;
+		case 1:
 			if (!n--) break;
-			*args++ = regs->r8;
-		case 4:
+			*args++ = regs->si;
+		case 2:
 			if (!n--) break;
-			*args++ = regs->r10;
+			*args++ = regs->dx;
 		case 3:
 			if (!n--) break;
-			*args++ = regs->dx;
-		case 2:
+			*args++ = regs->r10;
+		case 4:
 			if (!n--) break;
-			*args++ = regs->si;
-		case 1:
+			*args++ = regs->r8;
+		case 5:
 			if (!n--) break;
-			*args++ = regs->di;
-		case 0:
+			*args++ = regs->r9;
+		case 6:
 			if (!n--) break;
 		default:
 			BUG();
@@ -154,55 +154,57 @@ static inline void syscall_set_arguments(struct task_struct *task,
 {
 # ifdef CONFIG_IA32_EMULATION
 	if (task_thread_info(task)->status & TS_COMPAT)
-		switch (i + n) {
-		case 6:
+		switch (i) {
+		case 0:
 			if (!n--) break;
-			regs->bp = *args++;
-		case 5:
+			regs->bx = *args++;
+		case 1:
 			if (!n--) break;
-			regs->di = *args++;
-		case 4:
+			regs->cx = *args++;
+		case 2:
 			if (!n--) break;
-			regs->si = *args++;
+			regs->dx = *args++;
 		case 3:
 			if (!n--) break;
-			regs->dx = *args++;
-		case 2:
+			regs->si = *args++;
+		case 4:
 			if (!n--) break;
-			regs->cx = *args++;
-		case 1:
+			regs->di = *args++;
+		case 5:
 			if (!n--) break;
-			regs->bx = *args++;
-		case 0:
+			regs->bp = *args++;
+		case 6:
 			if (!n--) break;
 		default:
 			BUG();
+			break;
 		}
 	else
 # endif
-		switch (i + n) {
-		case 6:
+		switch (i) {
+		case 0:
 			if (!n--) break;
-			regs->r9 = *args++;
-		case 5:
+			regs->di = *args++;
+		case 1:
 			if (!n--) break;
-			regs->r8 = *args++;
-		case 4:
+			regs->si = *args++;
+		case 2:
 			if (!n--) break;
-			regs->r10 = *args++;
+			regs->dx = *args++;
 		case 3:
 			if (!n--) break;
-			regs->dx = *args++;
-		case 2:
+			regs->r10 = *args++;
+		case 4:
 			if (!n--) break;
-			regs->si = *args++;
-		case 1:
+			regs->r8 = *args++;
+		case 5:
 			if (!n--) break;
-			regs->di = *args++;
-		case 0:
+			regs->r9 = *args++;
+		case 6:
 			if (!n--) break;
 		default:
 			BUG();
+			break;
 		}
 }
 
