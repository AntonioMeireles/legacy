Index: linux-2.6.27.x86_64/include/linux/writeback.h
===================================================================
--- linux-2.6.27.x86_64.orig/include/linux/writeback.h
+++ linux-2.6.27.x86_64/include/linux/writeback.h
@@ -63,7 +63,15 @@ struct writeback_control {
 	unsigned for_writepages:1;	/* This is a writepages() call */
 	unsigned range_cyclic:1;	/* range_start is cyclic */
 	unsigned more_io:1;		/* more io to be dispatched */
-	unsigned range_cont:1;
+	/*
+	 * write_cache_pages() won't update wbc->nr_to_write and
+	 * mapping->writeback_index if no_nrwrite_index_update
+	 * is set.  write_cache_pages() may write more than we
+	 * requested and we want to make sure nr_to_write and
+	 * writeback_index are updated in a consistent manner
+	 * so we use a single control to update them
+	 */
+	unsigned no_nrwrite_index_update:1;
 };
 
 /*
Index: linux-2.6.27.x86_64/mm/page-writeback.c
===================================================================
--- linux-2.6.27.x86_64.orig/mm/page-writeback.c
+++ linux-2.6.27.x86_64/mm/page-writeback.c
@@ -876,6 +876,7 @@ int write_cache_pages(struct address_spa
 	pgoff_t end;		/* Inclusive */
 	int scanned = 0;
 	int range_whole = 0;
+	long nr_to_write = wbc->nr_to_write;
 
 	if (wbc->nonblocking && bdi_write_congested(bdi)) {
 		wbc->encountered_congestion = 1;
@@ -939,7 +940,7 @@ retry:
 				unlock_page(page);
 				ret = 0;
 			}
-			if (ret || (--(wbc->nr_to_write) <= 0))
+			if (ret || (--nr_to_write <= 0))
 				done = 1;
 			if (wbc->nonblocking && bdi_write_congested(bdi)) {
 				wbc->encountered_congestion = 1;
@@ -958,11 +959,12 @@ retry:
 		index = 0;
 		goto retry;
 	}
-	if (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))
-		mapping->writeback_index = index;
+	if (!wbc->no_nrwrite_index_update) {
+		if (wbc->range_cyclic || (range_whole && nr_to_write > 0))
+			mapping->writeback_index = index;
+		wbc->nr_to_write = nr_to_write;
+	}
 
-	if (wbc->range_cont)
-		wbc->range_start = index << PAGE_CACHE_SHIFT;
 	return ret;
 }
 EXPORT_SYMBOL(write_cache_pages);
Index: linux-2.6.27.x86_64/include/linux/percpu_counter.h
===================================================================
--- linux-2.6.27.x86_64.orig/include/linux/percpu_counter.h
+++ linux-2.6.27.x86_64/include/linux/percpu_counter.h
@@ -35,7 +35,7 @@ int percpu_counter_init_irq(struct percp
 void percpu_counter_destroy(struct percpu_counter *fbc);
 void percpu_counter_set(struct percpu_counter *fbc, s64 amount);
 void __percpu_counter_add(struct percpu_counter *fbc, s64 amount, s32 batch);
-s64 __percpu_counter_sum(struct percpu_counter *fbc, int set);
+s64 __percpu_counter_sum(struct percpu_counter *fbc);
 
 static inline void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
 {
@@ -44,19 +44,13 @@ static inline void percpu_counter_add(st
 
 static inline s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
 {
-	s64 ret = __percpu_counter_sum(fbc, 0);
+	s64 ret = __percpu_counter_sum(fbc);
 	return ret < 0 ? 0 : ret;
 }
 
-static inline s64 percpu_counter_sum_and_set(struct percpu_counter *fbc)
-{
-	return __percpu_counter_sum(fbc, 1);
-}
-
-
 static inline s64 percpu_counter_sum(struct percpu_counter *fbc)
 {
-	return __percpu_counter_sum(fbc, 0);
+	return __percpu_counter_sum(fbc);
 }
 
 static inline s64 percpu_counter_read(struct percpu_counter *fbc)
Index: linux-2.6.27.x86_64/lib/percpu_counter.c
===================================================================
--- linux-2.6.27.x86_64.orig/lib/percpu_counter.c
+++ linux-2.6.27.x86_64/lib/percpu_counter.c
@@ -52,7 +52,7 @@ EXPORT_SYMBOL(__percpu_counter_add);
  * Add up all the per-cpu counts, return the result.  This is a more accurate
  * but much slower version of percpu_counter_read_positive()
  */
-s64 __percpu_counter_sum(struct percpu_counter *fbc, int set)
+s64 __percpu_counter_sum(struct percpu_counter *fbc)
 {
 	s64 ret;
 	int cpu;
@@ -62,11 +62,9 @@ s64 __percpu_counter_sum(struct percpu_c
 	for_each_online_cpu(cpu) {
 		s32 *pcount = per_cpu_ptr(fbc->counters, cpu);
 		ret += *pcount;
-		if (set)
-			*pcount = 0;
+		*pcount = 0;
 	}
-	if (set)
-		fbc->count = ret;
+	fbc->count = ret;
 
 	spin_unlock(&fbc->lock);
 	return ret;
Index: linux-2.6.27.x86_64/fs/ext4/namei.c
===================================================================
--- linux-2.6.27.x86_64.orig/fs/ext4/namei.c
+++ linux-2.6.27.x86_64/fs/ext4/namei.c
@@ -1061,6 +1061,7 @@ static struct dentry *ext4_lookup(struct
 struct dentry *ext4_get_parent(struct dentry *child)
 {
 	unsigned long ino;
+	struct dentry *parent;
 	struct inode *inode;
 	static const struct qstr dotdot = {
 		.name = "..",
@@ -1082,7 +1083,16 @@ struct dentry *ext4_get_parent(struct de
 		return ERR_PTR(-EIO);
 	}
 
-	return d_obtain_alias(ext4_iget(child->d_inode->i_sb, ino));
+	inode = ext4_iget(child->d_inode->i_sb, ino);
+	if (IS_ERR(inode))
+		return ERR_CAST(inode);
+
+	parent = d_alloc_anon(inode);
+	if (!parent) {
+		iput(inode);
+		parent = ERR_PTR(-ENOMEM);
+	}
+	return parent;
 }
 
 #define S_SHIFT 12
Index: linux-2.6.27.x86_64/fs/ext4/super.c
===================================================================
--- linux-2.6.27.x86_64.orig/fs/ext4/super.c
+++ linux-2.6.27.x86_64/fs/ext4/super.c
@@ -400,7 +400,7 @@ fail:
 static int ext4_blkdev_put(struct block_device *bdev)
 {
 	bd_release(bdev);
-	return blkdev_put(bdev, FMODE_READ|FMODE_WRITE);
+	return blkdev_put(bdev);
 }
 
 static int ext4_blkdev_remove(struct ext4_sb_info *sbi)
@@ -862,7 +862,7 @@ enum {
 	Opt_inode_readahead_blks
 };
 
-static const match_table_t tokens = {
+static match_table_t tokens = {
 	{Opt_bsd_df, "bsddf"},
 	{Opt_minix_df, "minixdf"},
 	{Opt_grpid, "grpid"},
@@ -2555,7 +2555,7 @@ static journal_t *ext4_get_dev_journal(s
 	if (bd_claim(bdev, sb)) {
 		printk(KERN_ERR
 			"EXT4: failed to claim external journal device.\n");
-		blkdev_put(bdev, FMODE_READ|FMODE_WRITE);
+		blkdev_put(bdev);
 		return NULL;
 	}
 
@@ -3327,30 +3327,30 @@ static int ext4_quota_on_mount(struct su
  * Standard function to be called on quota_on
  */
 static int ext4_quota_on(struct super_block *sb, int type, int format_id,
-			 char *name, int remount)
+			 char *path, int remount)
 {
 	int err;
-	struct path path;
+	struct nameidata nd;
 
 	if (!test_opt(sb, QUOTA))
 		return -EINVAL;
-	/* When remounting, no checks are needed and in fact, name is NULL */
+	/* When remounting, no checks are needed and in fact, path is NULL */
 	if (remount)
-		return vfs_quota_on(sb, type, format_id, name, remount);
+		return vfs_quota_on(sb, type, format_id, path, remount);
 
-	err = kern_path(name, LOOKUP_FOLLOW, &path);
+	err = path_lookup(path, LOOKUP_FOLLOW, &nd);
 	if (err)
 		return err;
 
 	/* Quotafile not on the same filesystem? */
-	if (path.mnt->mnt_sb != sb) {
-		path_put(&path);
+	if (nd.path.mnt->mnt_sb != sb) {
+		path_put(&nd.path);
 		return -EXDEV;
 	}
 	/* Journaling quota? */
 	if (EXT4_SB(sb)->s_qf_names[type]) {
 		/* Quotafile not in fs root? */
-		if (path.dentry->d_parent != sb->s_root)
+		if (nd.path.dentry->d_parent->d_inode != sb->s_root->d_inode)
 			printk(KERN_WARNING
 				"EXT4-fs: Quota file not on filesystem root. "
 				"Journaled quota will not work.\n");
@@ -3360,7 +3360,7 @@ static int ext4_quota_on(struct super_bl
 	 * When we journal data on quota file, we have to flush journal to see
 	 * all updates to the file when we bypass pagecache...
 	 */
-	if (ext4_should_journal_data(path.dentry->d_inode)) {
+	if (ext4_should_journal_data(nd.path.dentry->d_inode)) {
 		/*
 		 * We don't need to lock updates but journal_flush() could
 		 * otherwise be livelocked...
@@ -3369,13 +3369,13 @@ static int ext4_quota_on(struct super_bl
 		err = jbd2_journal_flush(EXT4_SB(sb)->s_journal);
 		jbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);
 		if (err) {
-			path_put(&path);
+			path_put(&nd.path);
 			return err;
 		}
 	}
 
-	err = vfs_quota_on_path(sb, type, format_id, &path);
-	path_put(&path);
+	err = vfs_quota_on_path(sb, type, format_id, &nd.path);
+	path_put(&nd.path);
 	return err;
 }
 
Index: linux-2.6.27.x86_64/fs/ext4/mballoc.c
===================================================================
--- linux-2.6.27.x86_64.orig/fs/ext4/mballoc.c
+++ linux-2.6.27.x86_64/fs/ext4/mballoc.c
@@ -2646,7 +2646,6 @@ static void release_blocks_on_commit(jou
 	struct ext4_group_info *db;
 	int err, count = 0, count2 = 0;
 	struct ext4_free_data *entry;
-	ext4_fsblk_t discard_block;
 	struct list_head *l, *ltmp;
 
 	list_for_each_safe(l, ltmp, &txn->t_private_list) {
@@ -2676,12 +2675,6 @@ static void release_blocks_on_commit(jou
 			page_cache_release(e4b.bd_bitmap_page);
 		}
 		ext4_unlock_group(sb, entry->group);
-		discard_block = (ext4_fsblk_t) entry->group * EXT4_BLOCKS_PER_GROUP(sb)
-			+ entry->start_blk
-			+ le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);
-		trace_mark(ext4_discard_blocks, "dev %s blk %llu count %u", sb->s_id,
-			   (unsigned long long) discard_block, entry->count);
-		sb_issue_discard(sb, discard_block, entry->count);
 
 		kmem_cache_free(ext4_free_ext_cachep, entry);
 		ext4_mb_release_desc(&e4b);
Index: linux-2.6.27.x86_64/fs/ext4/file.c
===================================================================
--- linux-2.6.27.x86_64.orig/fs/ext4/file.c
+++ linux-2.6.27.x86_64/fs/ext4/file.c
@@ -140,9 +140,6 @@ static int ext4_file_mmap(struct file *f
 	return 0;
 }
 
-extern int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
-		__u64 start, __u64 len);
-
 const struct file_operations ext4_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -173,6 +170,5 @@ const struct inode_operations ext4_file_
 #endif
 	.permission	= ext4_permission,
 	.fallocate	= ext4_fallocate,
-	.fiemap		= ext4_fiemap,
 };
 
Index: linux-2.6.27.x86_64/fs/ext4/extents.c
===================================================================
--- linux-2.6.27.x86_64.orig/fs/ext4/extents.c
+++ linux-2.6.27.x86_64/fs/ext4/extents.c
@@ -40,7 +40,6 @@
 #include <linux/slab.h>
 #include <linux/falloc.h>
 #include <asm/uaccess.h>
-#include <linux/fiemap.h>
 #include "ext4_jbd2.h"
 #include "ext4_extents.h"
 
@@ -3079,143 +3078,3 @@ retry:
 	mutex_unlock(&inode->i_mutex);
 	return ret > 0 ? ret2 : ret;
 }
-
-/*
- * Callback function called for each extent to gather FIEMAP information.
- */
-int ext4_ext_fiemap_cb(struct inode *inode, struct ext4_ext_path *path,
-		       struct ext4_ext_cache *newex, struct ext4_extent *ex,
-		       void *data)
-{
-	struct fiemap_extent_info *fieinfo = data;
-	unsigned long blksize_bits = inode->i_sb->s_blocksize_bits;
-	__u64	logical;
-	__u64	physical;
-	__u64	length;
-	__u32	flags = 0;
-	int	error;
-
-	logical =  (__u64)newex->ec_block << blksize_bits;
-
-	if (newex->ec_type == EXT4_EXT_CACHE_GAP) {
-		pgoff_t offset;
-		struct page *page;
-		struct buffer_head *bh = NULL;
-
-		offset = logical >> PAGE_SHIFT;
-		page = find_get_page(inode->i_mapping, offset);
-		if (!page || !page_has_buffers(page))
-			return EXT_CONTINUE;
-
-		bh = page_buffers(page);
-
-		if (!bh)
-			return EXT_CONTINUE;
-
-		if (buffer_delay(bh)) {
-			flags |= FIEMAP_EXTENT_DELALLOC;
-			page_cache_release(page);
-		} else {
-			page_cache_release(page);
-			return EXT_CONTINUE;
-		}
-	}
-
-	physical = (__u64)newex->ec_start << blksize_bits;
-	length =   (__u64)newex->ec_len << blksize_bits;
-
-	if (ex && ext4_ext_is_uninitialized(ex))
-		flags |= FIEMAP_EXTENT_UNWRITTEN;
-
-	/*
-	 * If this extent reaches EXT_MAX_BLOCK, it must be last.
-	 *
-	 * Or if ext4_ext_next_allocated_block is EXT_MAX_BLOCK,
-	 * this also indicates no more allocated blocks.
-	 *
-	 * XXX this might miss a single-block extent at EXT_MAX_BLOCK
-	 */
-	if (logical + length - 1 == EXT_MAX_BLOCK ||
-	    ext4_ext_next_allocated_block(path) == EXT_MAX_BLOCK)
-		flags |= FIEMAP_EXTENT_LAST;
-
-	error = fiemap_fill_next_extent(fieinfo, logical, physical,
-					length, flags);
-	if (error < 0)
-		return error;
-	if (error == 1)
-		return EXT_BREAK;
-
-	return EXT_CONTINUE;
-}
-
-/* fiemap flags we can handle specified here */
-#define EXT4_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)
-
-int ext4_xattr_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo)
-{
-	__u64 physical = 0;
-	__u64 length;
-	__u32 flags = FIEMAP_EXTENT_LAST;
-	int blockbits = inode->i_sb->s_blocksize_bits;
-	int error = 0;
-
-	/* in-inode? */
-	if (EXT4_I(inode)->i_state & EXT4_STATE_XATTR) {
-		struct ext4_iloc iloc;
-		int offset;	/* offset of xattr in inode */
-
-		error = ext4_get_inode_loc(inode, &iloc);
-		if (error)
-			return error;
-		physical = iloc.bh->b_blocknr << blockbits;
-		offset = EXT4_GOOD_OLD_INODE_SIZE +
-				EXT4_I(inode)->i_extra_isize;
-		physical += offset;
-		length = EXT4_SB(inode->i_sb)->s_inode_size - offset;
-		flags |= FIEMAP_EXTENT_DATA_INLINE;
-	} else { /* external block */
-		physical = EXT4_I(inode)->i_file_acl << blockbits;
-		length = inode->i_sb->s_blocksize;
-	}
-
-	if (physical)
-		error = fiemap_fill_next_extent(fieinfo, 0, physical,
-						length, flags);
-	return (error < 0 ? error : 0);
-}
-
-int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
-		__u64 start, __u64 len)
-{
-	ext4_lblk_t start_blk;
-	ext4_lblk_t len_blks;
-	int error = 0;
-
-	/* fallback to generic here if not in extents fmt */
-	if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))
-		return generic_block_fiemap(inode, fieinfo, start, len,
-			ext4_get_block);
-
-	if (fiemap_check_flags(fieinfo, EXT4_FIEMAP_FLAGS))
-		return -EBADR;
-
-	if (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {
-		error = ext4_xattr_fiemap(inode, fieinfo);
-	} else {
-		start_blk = start >> inode->i_sb->s_blocksize_bits;
-		len_blks = len >> inode->i_sb->s_blocksize_bits;
-
-		/*
-		 * Walk the extent tree gathering extent information.
-		 * ext4_ext_fiemap_cb will push extents back to user.
-		 */
-		down_write(&EXT4_I(inode)->i_data_sem);
-		error = ext4_ext_walk_space(inode, start_blk, len_blks,
-					  ext4_ext_fiemap_cb, fieinfo);
-		up_write(&EXT4_I(inode)->i_data_sem);
-	}
-
-	return error;
-}
-
