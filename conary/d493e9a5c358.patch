# HG changeset patch
# User Michael Tharp <michael.tharp@sas.com>
# Date 1384802379 0
#      Mon Nov 18 19:19:39 2013 +0000
# Node ID d493e9a5c358cd079b25f0a59ddae886fbaf8976
# Parent  3004eefc2cee87eaa980abadcba70b6348cad622
Allow committing changesets with multiple versions of a trove (RCE-2376)

diff -r 3004eefc2cee -r d493e9a5c358 conary/repository/netrepos/trovestore.py
--- a/conary/repository/netrepos/trovestore.py	Mon Nov 18 19:19:28 2013 +0000
+++ b/conary/repository/netrepos/trovestore.py	Mon Nov 18 19:19:39 2013 +0000
@@ -193,9 +193,6 @@
 
         self.needsCleanup = False
         self.log = log or tracelog.getLog(None)
-        self.LATEST_TYPE_ANY = versionops.LATEST_TYPE_ANY
-        self.LATEST_TYPE_NORMAL = versionops.LATEST_TYPE_NORMAL
-        self.LATEST_TYPE_PRESENT = versionops.LATEST_TYPE_PRESENT
 
         self.versionIdCache = {}
         self.itemIdCache = {}
@@ -312,14 +309,19 @@
     # refresh the latest for all the recently presented troves
     def presentHiddenTroves(self):
         cu = self.db.cursor()
+        schema.resetTable(cu, 'tmpNewTroves')
         cu.execute("""
-        select i.instanceId, i.itemId, n.branchId, i.flavorId
-        from Instances as i join Nodes as n using(itemId, versionId)
-        where i.isPresent = ?""", instances.INSTANCE_PRESENT_HIDDEN)
-        for (instanceId, itemId, branchId, flavorId) in cu.fetchall():
-            cu.execute("UPDATE Instances SET isPresent=? WHERE instanceId=?",
-                       (instances.INSTANCE_PRESENT_NORMAL, instanceId))
-            self.latest.update(cu, itemId, branchId, flavorId)
+            INSERT INTO tmpNewTroves (itemId, branchId, flavorId,
+                versionId, instanceId, hidden, finaltimestamp)
+            SELECT itemId, branchId, flavorId, 0, instanceId, 0, 0
+            FROM Instances
+            JOIN Nodes USING (itemId, versionId)
+            WHERE isPresent = ?
+            """, instances.INSTANCE_PRESENT_HIDDEN)
+        cu.execute("""UPDATE Instances SET isPresent = ?
+            WHERE instanceId IN (SELECT instanceId FROM tmpNewTroves)
+            """, instances.INSTANCE_PRESENT_NORMAL)
+        self.latest.updateFromNewTroves('tmpNewTroves')
 
     def addTrove(self, trv, trvCs, hidden = False):
         cu = self.db.cursor()
@@ -869,140 +871,10 @@
 
         self.ri.addInstanceIdSet('tmpNewTroves', 'instanceId')
         self.depAdder.done()
+        self.depAdder = None
 
-        d = { 'LATEST_TYPE_ANY' : versionops.LATEST_TYPE_ANY,
-              'LATEST_TYPE_PRESENT' : versionops.LATEST_TYPE_PRESENT,
-              'LATEST_TYPE_NORMAL' : versionops.LATEST_TYPE_NORMAL,
-              'TROVE_TYPE_REDIRECT' : trove.TROVE_TYPE_REDIRECT,
-              'TROVE_TYPE_REMOVED' : trove.TROVE_TYPE_REMOVED,
-              'INSTANCE_PRESENT_HIDDEN' : instances.INSTANCE_PRESENT_HIDDEN }
-
-        # LATEST_TYPE_ANY -- if what was just committed is newer, it wins.
-        # if not, it loses. Note that Nodes.finalTimestamp could be NULL,
-        # and the logic in the CASE gives the new troves timestamp in that
-        # case. We do a normal join against UserGroups here to make sure
-        # we check this trove for every user group, not just user groups
-        # who currently have permissions for troves on the branch. The
-        # WHERE clause restricts us to adding rows where we have something
-        # currently latest or where we have permissions to see the not
-        # hidden new trove.
-        #
-        # Note that the WHEN clause in the CASE is nearly the inverse of the
-        # WHERE clause after the OR. That's important to make sure we don't try
-        # to insert NULLs.
-        sql1 = """
-        INSERT INTO tmpNewLatest(userGroupId, itemId, branchId, flavorId,
-                                 versionId, latestType)
-        SELECT UserGroups.userGroupId, tmpNewTroves.itemId,
-               tmpNewTroves.branchId, tmpNewTroves.flavorId,
-               CASE
-                   WHEN Nodes.finalTimestamp > tmpNewTroves.finalTimestamp OR
-                        ugi.instanceId IS NULL OR
-                        tmpNewTroves.hidden = 1
-                   THEN lc.versionId
-                   ELSE tmpNewTroves.versionId
-               END AS latestVersionId,
-               %(LATEST_TYPE_ANY)d
-        FROM tmpNewTroves
-        CROSS JOIN UserGroups
-        LEFT OUTER JOIN UserGroupInstancesCache AS ugi ON
-                ugi.instanceId = tmpNewTroves.instanceId AND
-                ugi.userGroupId = UserGroups.userGroupId
-        LEFT OUTER JOIN LatestCache AS lc ON
-                tmpNewTroves.itemId = lc.itemId AND
-                tmpNewTroves.branchId = lc.branchId AND
-                tmpNewTroves.flavorId = lc.flavorId AND
-                UserGroups.userGroupId = lc.userGroupId AND
-                lc.latestType = %(LATEST_TYPE_ANY)d
-        LEFT OUTER JOIN Nodes ON lc.itemId = Nodes.itemId AND
-                                 lc.versionId = Nodes.versionId
-        WHERE
-            lc.versionId IS NOT NULL OR
-            (ugi.instanceId IS NOT NULL AND tmpNewTroves.hidden = 0)
-        """ % d
-        callback.updatingDatabase('latest', 1, 5)
-        cu.execute(sql1)
-
-        # LATEST_TYPE_PRESENT -- this is the same as LATEST_TYPE_ANY, but
-        # if a REMOVED type is being added stick with whatever was already
-        # in the latest table (unless there is nothing in the latest table;
-        # in that case we don't add anything here either)
-        sql2 = """
-        INSERT INTO tmpNewLatest(userGroupId, itemId, branchId, flavorId,
-                                 versionId, latestType)
-        SELECT UserGroups.userGroupId, tmpNewTroves.itemId,
-               tmpNewTroves.branchId, tmpNewTroves.flavorId,
-               CASE
-                   WHEN Nodes.finalTimestamp > tmpNewTroves.finalTimestamp OR
-                        tmpNewTroves.troveType = %(TROVE_TYPE_REMOVED)d OR
-                        ugi.instanceId IS NULL OR
-                        tmpNewTroves.hidden = 1
-                   THEN lc.versionId
-                   ELSE tmpNewTroves.versionId
-               END AS latestVersionId,
-               %(LATEST_TYPE_PRESENT)d
-        FROM tmpNewTroves
-        CROSS JOIN UserGroups
-        LEFT OUTER JOIN UserGroupInstancesCache AS ugi ON
-                ugi.instanceId = tmpNewTroves.instanceId AND
-                ugi.userGroupId = UserGroups.userGroupId
-        LEFT OUTER JOIN LatestCache AS lc ON
-                tmpNewTroves.itemId = lc.itemId AND
-                tmpNewTroves.branchId = lc.branchId AND
-                tmpNewTroves.flavorId = lc.flavorId AND
-                UserGroups.userGroupId = lc.userGroupId AND
-                lc.latestType = %(LATEST_TYPE_PRESENT)d
-        LEFT OUTER JOIN Nodes ON lc.itemId = Nodes.itemId AND
-                                 lc.versionId = Nodes.versionId
-        WHERE
-                lc.versionId IS NOT NULL OR
-                (tmpNewTroves.troveType != %(TROVE_TYPE_REMOVED)d AND
-                 tmpNewTroves.hidden = 0 AND
-                 ugi.instanceId IS NOT NULL)
-        """ % d
-        callback.updatingDatabase('latest', 2, 5)
-        cu.execute(sql2)
-
-        # LATEST_TYPE_NORMAL -- this is the same as LATEST_TYPE_PRESENT, but
-        # if a REDIRECT type is latest omit the row entirely
-        sql3 = """
-        INSERT INTO tmpNewLatest(userGroupId, itemId, branchId, flavorId,
-                                 versionId, latestType)
-        SELECT tmpNewLatest.userGroupId, tmpNewLatest.itemId,
-               tmpNewLatest.branchId, tmpNewLatest.flavorId,
-               tmpNewLatest.versionId, %(LATEST_TYPE_NORMAL)d
-        FROM tmpNewLatest JOIN Instances USING
-                (itemId, versionId, flavorId)
-        WHERE
-                tmpNewLatest.latestType = %(LATEST_TYPE_PRESENT)d AND
-                (Instances.troveType != %(TROVE_TYPE_REDIRECT)d OR
-                 Instances.isPresent = %(INSTANCE_PRESENT_HIDDEN)d)
-        """ % d
-        callback.updatingDatabase('latest', 3, 5)
-        cu.execute(sql3)
-
-        callback.updatingDatabase('latest', 4, 5)
-        if self.db.kind == 'postgresql':
-            cu.execute("DELETE FROM LatestCache USING tmpNewTroves WHERE"
-                        "   LatestCache.itemId = tmpNewTroves.itemId AND "
-                       "    LatestCache.branchId = tmpNewTroves.branchId AND "
-                       "    LatestCache.flavorId = tmpNewTroves.flavorId")
-        else:
-            new = list(cu.execute("SELECT DISTINCT itemId, branchId, "
-                                  "flavorId FROM tmpNewTroves"))
-            for (i, b, f) in new:
-                cu.execute("DELETE FROM LatestCache WHERE "
-                           "itemId = ? AND branchId = ? AND "
-                           "flavorId = ?", i, b, f)
-
-        callback.updatingDatabase('latest', 5, 5)
-        cu.execute("""
-                INSERT INTO LatestCache(userGroupId, itemId, branchId,
-                                        flavorId, versionId, latestType)
-                    SELECT userGroupId, itemId, branchId, flavorId,
-                           versionId, latestType FROM tmpNewLatest""")
-
-        self.depAdder = None
+        callback.updatingDatabase('latest', 1, 1)
+        self.latest.updateFromNewTroves('tmpNewTroves')
 
     def updateMetadata(self, troveName, branch, shortDesc, longDesc,
                     urls, licenses, categories, source, language):
diff -r 3004eefc2cee -r d493e9a5c358 conary/repository/netrepos/versionops.py
--- a/conary/repository/netrepos/versionops.py	Mon Nov 18 19:19:28 2013 +0000
+++ b/conary/repository/netrepos/versionops.py	Mon Nov 18 19:19:39 2013 +0000
@@ -189,6 +189,36 @@
         for itemId, flavorId, branchId in cu.fetchall():
             self.update(cu, itemId, branchId, flavorId, roleId)
 
+    def updateFromNewTroves(self, table='tmpNewTroves'):
+        """
+        Update latest entries for all item+branch+flavor slots mentioned in
+        tmpNewTroves.
+        """
+        cu = self.db.cursor()
+        if self.db.kind != 'sqlite':
+            cu.execute("""
+                DELETE FROM LatestCache old USING %s new
+                    WHERE old.itemId = new.itemId
+                    AND old.branchId = new.branchId
+                    AND old.flavorId = new.flavorId
+                """ % (table,))
+        else:
+            cu.execute("""SELECT DISTINCT itemId, branchId, flavorId
+                    FROM %s""" % (table,))
+            slots = [tuple(x) for x in cu.fetchall()]
+            cu.executemany("""DELETE FROM LatestCache
+                    WHERE itemId = ? AND branchId = ? AND flavorId = ?""",
+                    slots)
+
+        cu.execute("""
+            INSERT INTO LatestCache (latestType, userGroupId, itemId, branchId,
+                    flavorId, versionId)
+            SELECT DISTINCT v.latestType, v.userGroupId, v.itemId, v.branchId,
+                    v.flavorId, v.versionId
+            FROM LatestView v
+            JOIN %s n USING (itemId, branchId, flavorId)
+            """ % (table,))
+
 
 class LabelMap(idtable.IdPairSet):
     def __init__(self, db):
diff -r 3004eefc2cee -r d493e9a5c358 conary/repository/repository.py
--- a/conary/repository/repository.py	Mon Nov 18 19:19:28 2013 +0000
+++ b/conary/repository/repository.py	Mon Nov 18 19:19:39 2013 +0000
@@ -18,10 +18,12 @@
 # defines the Conary repository
 
 import itertools
+import time
 
 from conary.repository import changeset, errors, filecontents
 from conary import files, trove
-from conary.lib import log, patch, openpgpkey, openpgpfile, sha1helper, util
+from conary.lib import log, patch, sha1helper, util
+
 
 class AbstractTroveDatabase:
 
@@ -706,22 +708,35 @@
         newList = [ x for x in cs.iterNewTroveList() ]
 
         if resetTimestamps:
-            # This depends intimiately on the versions cache. We don't
-            # change the timestamps on each version, because the cache
-            # ensures they are all a single underlying object. Slick,
-            # but brittle?
-            updated = {}
+            now = time.time()
+            slots = {}
+            for trvCs in newList:
+                slot = (trvCs.getName(), trvCs.getNewVersion().branch())
+                slots.setdefault(slot, set()).add(trvCs)
+            for slot, troves in slots.iteritems():
+                # The latest trove in each LatestCache slot is reset to the
+                # current server time. This avoids client clock skew causing
+                # new troves to be older than existing troves. All other
+                # versions in that slot must have a lower timestamp than the
+                # latest one.
 
-            for csTrove in newList:
-                ver = csTrove.getNewVersion()
-                if ver in updated:
-                    pass
-                else:
-                    oldVer = ver.copy()
-                    ver.trailingRevision().resetTimeStamp()
-                    updated[oldVer] = ver
-
-            del updated
+                # First, map out the latest timestamp for each unique version
+                # in this slot. This establishes an order to the versions.
+                nodes = {}
+                for trvCs in troves:
+                    ver = trvCs.getNewVersion()
+                    nodes[str(ver)] = max(nodes.get(str(ver), 0),
+                            ver.trailingRevision().timeStamp)
+                # Now reset all the timestamps, using now for the latest node
+                # and a lesser value for each preceding one.
+                newStamp = now
+                for ver, stamp in sorted(nodes.items(), key=lambda x: x[1],
+                        reverse=True):
+                    for trvCs in troves:
+                        if str(trvCs.getNewVersion()) == ver:
+                            trvCs.getNewVersion().trailingRevision(
+                                    ).timeStamp = newStamp
+                    newStamp -= 1
 
         troveNo, configRestoreList, normalRestoreList = \
             self._createInstallTroveObjects(fileHostFilter = fileHostFilter,
@@ -757,7 +772,7 @@
                     raise errors.IntegrityError(
                         "Missing file contents for pathId %s, fileId %s" % (
                                         sha1helper.md5ToString(pathId),
-                                        sha1helper.sha1ToString(fileId)))
+                                        sha1helper.sha1ToString(oldFileId)))
 
                 oldLines = f.readlines()
                 f.close()
