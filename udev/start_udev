#!/bin/sh
#
# start_udev
#
# script to initialize /dev by using udev.
#
# Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
#
# Released under the GPL v2 only.
#
# This needs to be run at the earliest possible point in the boot 
# process.
#
# Based on the udev init.d script
#
# Thanks go out to the Gentoo developers for proving 
# that this is possible to do.
#
# Yes, it's very verbose, feel free to turn off all of the echo calls,
# they were there to make me feel better that everything was working
# properly during development...
#
# don't use udev if sysfs is not mounted.

sysfs_dir=/sys

[ -d $sysfs_dir/class ] || exit 1
[ -r /proc/mounts ] || exit 1
[ -x /sbin/udev ] || exit 1
[ -f /etc/udev/udev.conf ] && . /etc/udev/udev.conf


. /etc/init.d/functions

prog=udev
bin=/sbin/udev
udevd=/sbin/udevd
MAKEDEV="/sbin/MAKEDEV"

xargs_simple () {
	if [ "$1" = "-n" ]; then
		shift
		MAXNR="$1"
		shift
	else
		MAXNR=100
	fi
	NR=$MAXNR
	ARGS=""
	[ -z "$1" ] && set echo

	while read line; do
		if [ $NR -gt 0 ]; then
        		ARGS="$ARGS $line"
	        	NR=$[$NR - 1]
		else
        		"$@" $ARGS
	        	NR=$MAXNR
		        ARGS="$line"
		fi
	done
	if [ -n "$ARGS" ]; then
		"$@" $ARGS
	fi 
}

make_extra_nodes () {
	ln -snf /proc/self/fd $udev_root/fd
	ln -snf /proc/self/fd/0 $udev_root/stdin
	ln -snf /proc/self/fd/1 $udev_root/stdout
	ln -snf /proc/self/fd/2 $udev_root/stderr
	ln -snf /proc/kcore $udev_root/core

	[ -d $udev_root/pts ] || mkdir -m 0755 $udev_root/pts
	[ -d $udev_root/shm ] || mkdir -m 0755 $udev_root/shm
	[ -a /dev/MAKEDEV ] || ln -s $MAKEDEV /dev/MAKEDEV;

	if [ -x $MAKEDEV ]; then
		for i in /etc/udev/makedev.d/*.nodes; do
			if [ -f "$i" ]; then 
				cat "$i" | sed -e 's,#.*,,g' | \
					xargs_simple -n 100 $MAKEDEV
			fi
		done 
	fi
	pushd /etc/udev/devices &> "$udev_root/null"
	set *
	if [ "$1" != "*" ]; then
        	cp -ar "$@" $udev_root/ 
		pushd "$udev_root" &> "$udev_root/null"
		[ -x /sbin/restorecon ] && /sbin/restorecon "$@" 
		popd &> "$udev_root/null"
	fi
	popd &> "$udev_root/null"
}

# we cannot use /usr/bin/find here
find_d () {
        where=$1
        what=$2
        found=""
        for f in $where/*; do
                if [ -d "$f" -a ! -L "$f" ]; then
			if [ "$f" != "${f%%$what}" ];then 
			        # make sure we are at the path end
			        # we have no dirname and basename
				rest="${f#*$what}"
				[ "${rest##*/}" = "$rest" ] && found="$found $f"
			fi
                        found="$found $(find_d $f $what)"
                fi
        done
        echo "$found"
}

# we cannot use /usr/bin/find here
find_f () {
	where=$1
	what=$2
	found=""
	for f in $where/*; do
		if [ -d "$f" -a ! -L "$f" ]; then
			found="$found $(find_f $f $what)"
		elif [ -e "$f" ]; then 
			[ "$where/" = "${f%$what}" ] && found="$found $f"
		fi
	done
	[ -n "$found" ] && echo "$found"
}

kill_udevd() {
	if [ -x /sbin/pidof ]; then
		pid=`/sbin/pidof -x udevd`
        	[ -n "$pid" ] && kill $pid
	fi
}


# call hotplug with the scsi devices
scsi_replay () {
	HOTPLUG="/sbin/udevsend"

        scsi_hosts=$(find_d /sys/devices host\*)

        for host in $scsi_hosts;do
                [ -d $host ] || continue
                devs=$(find_f $host type)
                for dev in $devs;do
                        [ -f $dev ] || continue
                        DEVPATH=${dev%/type}
                        DEVPATH=${DEVPATH#/sys}
                        /bin/env -i DEVPATH="$DEVPATH" SUBSYSTEM=scsi_device ACTION=add $HOTPLUG scsi_device
                        /bin/env -i DEVPATH="$DEVPATH" ACTION=add SUBSYSTEM=scsi $HOTPLUG scsi
                done
        done
        return 0
}

ide_scan() {
    if [ ! -d /proc/ide ]; then
	return 1
    fi
    for i in /proc/ide/*/media; do
	read media < "$i"
	case "$media" in
	    disk)
		module=ide-disk
		;;
	    cdrom)
		module=ide-cd
		;;
	    tape)
		module=ide-tape
		;;
	    floppy)
		module=ide-floppy
		;;
	    *)
		module=ide-generic
		;;
	esac
	/sbin/modprobe $module
    done
    return 0
}


export ACTION=add
prog=udev
ret=0
STRING=$"Starting $prog: "
# propagate $udev_root from /sys
echo -n $STRING

# mount the tmpfs on ${udev_root%/}, if not already done
LANG=C awk "\$2 == \"${udev_root%/}\" && \$3 == \"tmpfs\" { exit 1 }" /proc/mounts && {
	if LANG=C fgrep -q "none ${udev_root%/}/pts " /proc/mounts; then
		PTSDIR=$(mktemp -d)
		mount --move $udev_root/pts "$PTSDIR"
	fi
	if LANG=C fgrep -q "none ${udev_root%/}/shm " /proc/mounts; then
		SHMDIR=$(mktemp -d)
		mount --move $udev_root/shm "$SHMDIR"
	fi
	mount -n -o mode=0755 -t tmpfs none "$udev_root"
	mkdir -m 0755 $udev_root/pts
	mkdir -m 0755 $udev_root/shm
	if [ -n "$PTSDIR" ]; then
		mount --move "$PTSDIR" $udev_root/pts
		rmdir "$PTSDIR"
	fi
	if [ -n "$SHMDIR" ]; then
		mount --move "$SHMDIR" $udev_root/shm
		rmdir "$SHMDIR"
	fi
	
	ret=$[$ret + $?]
}

rm -fr "$udev_db"
make_extra_nodes
kill_udevd > "$udev_root/null" 2>&1
scsi_replay > "$udev_root/null" 2>&1
ret=$[$ret + $?]
ide_scan > "$udev_root/null" 2>&1
/sbin/udevstart 
ret=$[$ret + $?]
[ $ret -eq 0 ] && success $"$STRING" || failure $"$STRING"
echo
exit 0
