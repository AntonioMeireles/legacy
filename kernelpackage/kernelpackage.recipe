#
# Copyright (c) 2004-2009 rPath, Inc.
#               2008-2013 The Foresight Linux Project
# This file is distributed under the terms of the MIT License.
# A copy is available at http://www.rpath.com/permanent/mit-license.html
#

loadInstalled('gcc')
loadInstalled('python')
class KernelPackageRecipe(CPackageRecipe):
    buildRequires = [ 'perl:runtime', 'perl:perl',
                      'module-init-tools:runtime',
                      # for 'hostname' cmd
                      'net-tools:runtime', 
                      # for perf and cpupower
                      'elfutils:devel', 'libelf:devel',
                      'newt:devel', 'python:devel', 
                      'slang:devel', 'audit:python',
                      'chkconfig:runtime', 'gettext:runtime',
                      'intltool:runtime', 
                      'pciutils:devel', 
                      'asciidoc:runtime', 'xmlto:runtime',
                      # for perf
                      'pkgconfig:devel', 'bison:runtime',
                      'flex:runtime', 'audit:devel',
                      # 'libunwind:devel',
    ]

    name = 'kernelpackage'
    version = '0.0.0'
    longterm = False

    #serial = '1'
    # If you are not trying to manage binary kernel module compatibility,
    # then do not set a serial string, and the source count will be used
    # instead.
    #
    # If you are trying to manage binary kernel module compatibility,
    # you will need to set the serial string manually.
    #
    # Every change that is expected to change interfaces requires
    # a change in serial string.  No two kernels of the same flavor
    # and serial can be installed at once due to path conflicts.
    # The serial string has no semantic content; a higher number
    # is not necessarily "more recent" than a lower number.
    # The same serial string may be re-used on different branches;
    # it only differentiates kernels with the same %(version)s
    # within a branch or set of related branches.
    #
    # Pure integer serial strings are reserved for rPath, Inc.
    # Inheriting repositories should use some other rule (decimal
    # numbers, letters, etc.) than all repositories above them in
    # their inheritance tree; especially a different rule from their
    # direct parent.  The example.com@linux repository might use
    # serial = 'example.n'.  As long as the string is different
    # for every kernel with the same %(version)s on all branches
    # that might be installed on a single machine, it will work.
    #
    # This is needed because patches to the kernel, changes in
    # compilation flags, and changes in configuration can all make
    # changes to binary interfaces within the kernel.

    Flags.debug = False
    Flags.debug.setShortDoc('Enable kernel debugging options')
    Flags.smp = True
    Flags.smp.setShortDoc('Enable SMP support')
    Flags.pae = False
    Flags.pae.setShortDoc('Enable PAE support')
    Flags.numa = False
    Flags.numa.setShortDoc('Enable NUMA support')
    Flags.debugdata = False
    Flags.debugdata.setShortDoc('Enable saving debug data in :debuginfo')

    # configs is a base list of configurations; subclasses will normally
    # be able to just use this list; if not, they can extend it or replace
    # it.
    configs = [
        # list of (basearch, flaglist, dictlist) tuples:
        # basearch is Arch.basearch
        # flaglist is read as Arch.basearch.<flag> for flag in flaglist
        #  except that 'flags.<flag>' is read as Flags.<flag> to allow
        #  for flavors based on additional local flavors and
        #  'use.<flag>' is read as Use.<flag>;
        #  where the most specific match "wins"
        # dictlist is list of sets of keyword args to the
        # addConfigs.do_one() function -- see the available keys and
        # default values in the addConfigs.do_one() definition
        # This list must be maintained in order from least specific
        # to most specific.
        ('x86', (), (
            {},
        )),
        ('x86', ('i586',), (
            {},
            {'smp':True}
        )),
        ('x86', ('i686',), (
            {},
            {'smp':True},
            {'smp':True, 'pae':True},
        )),
        ('x86', ('i686', 'use.xen', 'use.dom0'), (
            {'smp':True},
            {'smp':True, 'pae':True},
        )),
        ('x86', ('i686', 'use.xen', 'use.domU'), (
            {'smp':True},
            {'smp':True, 'pae':True},
        )),
        ('x86_64', (), (
            {},
            {'smp':True},
        )),
        ('x86_64', ('use.xen', 'use.dom0'), (
            {'smp':True},
        )),
        ('x86_64', ('use.xen', 'use.domU'), (
            {'smp':True},
        )),
    ]

    def setup(r):
        """
        subclasses should only have to override unpack() and perhaps
        policy(); everything else should normally work fine without
        an override. However, if a user wants to use a totally different
        .config, it may be necessary to override configure(). See
        http://wiki.rpath.com/KernelDotOrgTemplate
        """
        # pure virtual
        if r.__class__.__name__ == 'KernelPackageRecipe':
            return
        r.setMacros()
        r.setImageTargetMacro()
        r.unpackBase()
        r.fixPermissions()
        r.addNonInteractiveConfig()
        r.setCompileInfo()
        r.unpack() # patches go here
        r.distCleanup()
        r.createLocalVersion()
        r.configure() # manually generated .config's go here
        r.buildBase() # includes installation
        r.buildPerfAndTools()
        r.buildAtaModuleMap() # may be overridden if modules.libata not needed
        r.build() # extra build actions go here
        r.policyBase()
        r.policy() # extra policy goes here
        
    def _getCfgVer(r):
        # Have to calculate the kver early because by the time addConfigs runs
        # all the macros need to already be defined.
        flags = []
        # if Flags.debug:
        #     flags.append('debug')
        # if Flags.smp:
        #     flags.append('smp')
        # if Flags.pae:
        #     flags.append('pae')
        # if Flags.numa:
        #     flags.append('numa')
        # flags.append(r.macros.gccver)
        for basearch, flaglist, dictlist in r.configs:
            if True and Arch[basearch]:
                flags.append(basearch)
                break
        return '.'.join(flags)

    def setMacros(r):
        # set most custom macros; see setImageTargetMacro() for imagetarget
        r.macros.archive_version = r.version.replace('_', '-')
        r.macros.majorversion = ".".join(r.version.split('.')[0:2])
        r.macros.kseries = ".".join(r.version.split('.')[0:3])
        r.macros.level = r.version.split('.')[0]
        r.macros.patchlevel = r.version.split('.')[1]
        r.macros.sublevel = r.version.split('.')[2].split('_')[0]

        if int(r.macros.level) < 3:
            r.macros.lastlevel = r.version.split('.')[3].split('_')[0]

        # Versions of Conary since 1.2.6 print the methods that are
        # called, but hasattr always returns a proxy function, so
        # we have to check whether we're getting the real thing or not:
        if hasattr(r, 'serial') and isinstance(r.serial, basestring):
            r.macros.serial = r.serial
        else:
            if 'sourceVersion' in r.__dict__ and hasattr(r.sourceVersion,
                                                         'trailingRevision'):
                    r.macros.serial = str(
                        r.sourceVersion.trailingRevision().getSourceCount())
            else:
                # If r.sourceVersion does not exist (rmake build from a
                # recipe, for instance) or r.sourceVersion is a NewVersion
                # object without a trailingRevision object, we'll set it
                # to something unlikely to conflict
                r.macros.serial = '0.NEW'

        # r.macros.cfgver is set later while creating configurations
        # This works because macros have delayed evaluation
        r.macros.gccver = 'gcc%s' %'.'.join(Gcc.version.split('.')[0:2])
        r.macros.cfgver = r._getCfgVer()
        r.macros.localversion = '-%(serial)s-foresight.%(cfgver)s'
        r.macros.kver = '%(archive_version)s%(localversion)s'
        r.macros.sourcever = '%(version)s-%(serial)s'
        print 'kver =', r.macros.kver

        # get the last 64 (UTS_LEN) or fewer characters of the parts of
        # the buildLabel to use instead of the username and hostname the
        # kernel was built by/on.
        if '@' not in r.macros.buildlabel:
            # we need an @, use a default string with an @...
            r.macros.buildlabel = 'local@local:LOCAL'
        buildrep, branchname = r.macros.buildlabel.split('@')
        r.macros.buildrep = buildrep[-64:]
        r.macros.branchname = branchname[-64:]

        if not r.Flags.debugdata:
            r.Strip(debuginfo=False)

        if 'archive_dir' in r.__dict__:
            r.macros.archive_dir = r.archive_dir + '/'
        else:
            if r.longterm == True:
                r.macros.archive_dir = 'longterm/v%(kseries)s/'
            elif '-rc' in r.macros.archive_version:
                r.macros.archive_dir = 'testing/'
            else:
                r.macros.archive_dir = ''

    def setImageTargetMacro(r):
        # The imagetarget macro might reasonably need to be overridden,
        # so this is broken out from setMacros() for convenience
        # We assume that building a Xen kernel with 2.6.29 or later,
        # we have bzImage support in xen loader for domU and in the
        # xen hypervisor for dom0.  Override this method if this
        # heuristic is incorrect for your case.
        if Use.xen and int(r.macros.sublevel) < 29:
            r.macros.imagetarget = 'vmlinuz'
        else:
            r.macros.imagetarget = 'bzImage'

    def unpackBase(r):
        r.addArchive(
            'http://ftp.kernel.org/pub/linux/kernel/v%(majorversion)s/'
            '%(archive_dir)s'
            'linux-%(archive_version)s.tar.bz2',
            keyid='517D0F0E'
        )

    def fixPermissions(r):
        # Conary preserves world-write/execute permissions in the tarball,
        # which we do not want to preserve on the installed system or in
        # the build
        r.addAction('chmod -R go-w .')

    def addNonInteractiveConfig(r):
        if int(r.macros.level) < 3 and int(r.macros.sublevel) < 38:
            # avoid requests for interactive response
            r.addPatch('linux-2.6-build-nonintconfig.patch')
        # upstreamed in 38+ kernels

    def setCompileInfo(r):
        r.addAction(r"""sed -i '
            s/`whoami`/%(buildrep)s/
            s/`hostname | $UTS_TRUNCATE`/%(branchname)s/
            s/ ."`dnsdomainname | $UTS_TRUNCATE`."//
            s/ ."`domainname | $UTS_TRUNCATE`."//
            ' scripts/mkcompile_h""")

    def unpack(r):
        """
        Add any special patches here
        """
        pass

    def distCleanup(r):
        # play safe
        #r.addAction('sed -i "s/^VERSION.*/VERSION = %(level)s/" Makefile')
        #r.addAction('sed -i "s/^PATCHLEVEL.*/PATCHLEVEL = %(patchlevel)s/" Makefile')
        # Override any "-pre" or premature increment of SUBLEVEL from patches
        #r.addAction('sed -i "s/^SUBLEVEL.*/SUBLEVEL = %(sublevel)s/" Makefile')
        if int(r.macros.level) < 3:
            r.addAction('sed -i "s/^EXTRAVERSION.*/EXTRAVERSION = .%(lastlevel)s/" Makefile')

        # Since we will get kernel-source:tree out of this tree, clean it up
        r.addAction('find . -name "*.orig" | xargs rm -f')
        r.addAction('find . -name "*~" | xargs rm -f')
        r.addAction('make -s mrproper')

    def createLocalVersion(r):
        r.Create('localversion.rpl', contents='%(localversion)s')

    def addConfiguration(r):
        # broken out from configure() to allow make nonint_oldconfig
        # with custom complete configuration instead of config.* files
        # by overriding this method
        r.extraSource(addConfigs(r))

    def configure(r):
        r.addConfiguration()

        # complements addNonInteractiveConfig()
        if int(r.macros.level) < 3 and  int(r.macros.sublevel) < 38:
            r.macros.makeCfg = 'nonint_oldconfig'
        else: 
            r.macros.makeCfg = 'oldnoconfig'

        r.Make('%(makeCfg)s 2>oc.err ||'
               ' { diff -u .config.old .config > config.changes;'
               '   cat config.changes ;'
               '   echo "missing config items:"; cat oc.err ;'
               '   exit 1; }')
        # if we get here, this file is empty, remove it
        r.Remove('oc.err')

    def buildBase(r):
        r.Make('%(imagetarget)s modules')
               # Override $(mod-fw) bellow because we don't want it to
               # install any firmware. We would do that ourselves later
               # with 'make firmware_install' or externally as we 
               # actually are doing atm
        r.Make('-s INSTALL_MOD_PATH=%(destdir)s modules_install'
               ' KERNELRELEASE=%(kver)s'
               ' mod-fw=')
        r.Install('System.map', '/boot/System.map-%(kver)s', mode=0644)
        r.Install('.config', '/boot/config-%(kver)s', mode=0644)
        if Use.xen and r.macros.imagetarget == 'vmlinuz':
            r.Install('vmlinuz', '/boot/vmlinuz-%(kver)s', mode=0644)
        # Unified arch leaves x86_64 with a symlink so */boot/bzImage doesnt work.
        elif Arch.x86_64 or Arch.x86 and int(r.macros.sublevel) > 23:
            r.Install('arch/x86/boot/bzImage', '/boot/vmlinuz-%(kver)s', mode=0644)
        else:
            r.Install('arch/*/boot/bzImage', '/boot/vmlinuz-%(kver)s', mode=0644)
        r.Install('vmlinux', '/lib/modules/%(kver)s/', mode=0644)
        r.Symlink('/lib/modules/%(kver)s/vmlinux', '/boot/vmlinux-%(kver)s')
        # remove autogenerated files
        r.Remove('/lib/modules/%(kver)s/modules.*')
        # remove old symlink
        r.Remove('/lib/modules/%(kver)s/pcmcia', recursive=True)

        # replace build symlink, install headers properly
        r.Remove('/lib/modules/%(kver)s/build', recursive=True)
        r.MakeDirs('/lib/modules/%(kver)s/build')
        r.extraBuild(CreateBuildTree(r))
        r.Create('/lib/modules/%(kver)s/build/include/linux/autoconf.h')
        r.Remove('/lib/modules/%(kver)s/source', recursive=True)
        r.Symlink('build', '/lib/modules/%(kver)s/source')
        r.Install('configs/*', '/lib/modules/%(kver)s/configs/')
        r.Install('localversion.rpl', '/lib/modules/%(kver)s/build/')

        r.vmwareComponent()
        r.ComponentSpec('configs', '/lib/modules/[^/]*/configs/')
        r.ComponentSpec('build-tree', '/lib/modules/[^/]*/build/')
        r.ComponentSpec('debuginfo', '%(debugsrcdir)s/', '%(debuglibdir)s/')
        r.ComponentSpec('runtime', '/boot/', '/lib/modules/')
        # do not depend on dracut's kernel tagdescription file
        r.TagSpec('kernel', '/boot/vmlinuz-.*', '/lib/modules/.*/.*\.k?o$')
        if Arch.x86:
            r.Provides('abi: ELF32(SysV x86)', '/boot/vmlinu.*')
        if Arch.x86_64:
            r.Provides('abi: ELF32(SysV x86)', '/boot/vmlinu.*')
            r.Provides('abi: ELF64(SysV x86_64)', '/boot/vmlinu.*')

    def buildPerfAndTools(r):
        # FIXME 
        # i'm not specially happy about doing this here... (a la RH)
        # ideally we'll do later this in a separate package (kernel-tools ?)
        # that subclasses kernel class. 
        #
        # cpupower
        r.Make('CPUFREQ_BENCH=false', dir = 'tools/power/cpupower')
        r.MakeInstall(' CPUFREQ_BENCH=false '
                      ' libdir=%(libdir)s '
                      ' mandir=%(mandir)s '
                      ' bindir=%(bindir)s',
                      dir = 'tools/power/cpupower',
                      package = 'cpupower-tools')
        # this will fail for non x86 arches...
        if Arch.x86:
            dpath = 'tools/power/cpupower/debug/i386'
        elif Arch.x86_64:
            dpath = 'tools/power/cpupower/debug/x86_64'

        r.Make('centrino-decode powernow-k8-decode', dir = dpath)

        for d in [ 'x86_energy_perf_policy/',
                   'turbostat',]:
            r.Make(dir = 'tools/power/x86/%s' % d)
            r.MakeInstall('mandir=%(mandir)s bindir=%(bindir)s',
                          dir = 'tools/power/x86/%s' % d,
                          package = 'cpupower-tools')

        for f in ['centrino-decode', 'powernow-k8-decode']:
            r.Install(dpath + '/%s' % f,
                      '%(bindir)s/',
                      package = 'cpupower-tools')

        cpupowerDefaultCfg = ("""# See 'cpupower help' and cpupower(1) for more info\n"""
                              """CPUPOWER_START_OPTS="frequency-set -g ondemand"\n""")

        r.Create('%(sysconfdir)s/sysconfig/cpupower',
                 contents = cpupowerDefaultCfg, mode = 0644,
                 package = 'cpupower-tools')
        r.addSource('cpupower.init')
        r.Install('cpupower.init', '%(initdir)s/cpupower',
                  mode = 0755, package = 'cpupower-tools')
        # perf
        makeArgs = (' -s'
                    ' V=1'
                    ' HAVE_CPLUS_DEMANGLE=1'
                    ' WERROR=0 '
                    ' NO_LIBUNWIND=1'
                    ' NO_GTK2=1'
                    ' NO_LIBNUMA=1'
                    ' NO_STRLCPY=1'
                    ' prefix=%(prefix)s mandir=%(mandir)s '
                    # ' EXTRA_CFLAGS="-Wno-error=array-bounds" '
                    )
        r.Make('%s all' % makeArgs, dir = 'tools/perf')
        r.Make('%s man' % makeArgs, dir = 'tools/perf')

        r.MakeInstall(makeArgs,
                      dir = 'tools/perf', package = 'perf')
        r.MakeInstall(makeArgs,
                      installtarget= 'install-man',
                      dir = 'tools/perf',
                      package = 'perf')
        r.MakeInstall(installtarget='install-python_ext',
                      dir = 'tools/perf',
                      package = 'perf')
        r.Doc('tools/perf/{CREDITS,Documentation/{perfconfig.example,examples.txt}}',
              package = 'perf')
        r.Remove('%(libdir)s/python%(pyver)s/site-packages/*.egg-info')

    def buildAtaModuleMap(r):
        # find libata modules
        r.Run('for i in $(find %(destdir)s | grep drivers\/ata); '
              'do if [ $(nm $i |grep --count ata_pci_remove_one) -ne 0 ]; '
              'then basename `echo $i` ;fi ; done | grep -v sata | '
              'grep -v pdc_adma | sort >> modules.libata')
        r.Install('modules.libata', '/lib/modules/%(kver)s/modules.libata')

    def build(r):
        """
        Add any special build actions here
        """
        pass

    def vmwareComponent(r):
        # Place open-vm-tools modules into a seperate component.  This
        # allows easy removal for people who wish to run a vmware host.
        r.ComponentSpec('vmware',
                        '/lib/modules/%(kver)s/kernel/fs/vm.*',
                        '/lib/modules/%(kver)s/kernel/drivers/misc/v.*',
                        '/lib/modules/%(kver)s/kernel/drivers/net/vm.*',
                        '/lib/modules/%(kver)s/kernel/drivers/net/vsock/v.*')

    def policyBase(r):
        # Disable Autodoc. Users tend to have more than 1 kernel installed
        r.AutoDoc(exceptions='.*')
        # perl scripts in build-tree are not required to build most
        # modules, and perl is a constraint on some systems, therefore
        # push the perl deps up to modules that require perl to build
        r.Requires(exceptions=r'.*(kernel-doc|\.pl)')
        r.Provides(exceptions=r'/lib/modules/%(kver)s/.*\.ko$')
        r.Provides('soname: libkconfig.so',
                   '/lib/modules/.*/build/scripts/kconfig/libkconfig.so')
        r.Requires('dracut:runtime',
                   r'/lib/modules/%(kver)s/.*\.ko$')
        r.ComponentProvides(('%(kver)s', '%(gccver)s'))

        # we don't want spurious deps on py24 in :build-tree as it will create odd
	# chroots when building external kmods with consequent assorted breackage
        r.macros.pyver = Python.majversion
        pybin = '%(bindir)s/python%(pyver)s'
        r.NormalizePythonInterpreterVersion(versionMap=(
                ('%(bindir)s/python2.4', pybin),
                ('%(bindir)s/python2.5', pybin),
                ('%(bindir)s/python', pybin),
                ))
        # rm cruft
        r.Remove('/lib/modules/%(kver)s/source/open-vm-tools-%(ovmtoolsver)s/',
                 recursive = True, allowNoMatch=True)
        # 
        r.RemoveNonPackageFiles(r'.*\..*.cmd')

    def policy(r):
        """
        Add any extra policy here
        """
        pass



####################################################################
# The rest of this file contains only supporting classes that
# should not normally need to be modified when modifying the
# kernel package
####################################################################

class CreateBuildTree(build.BuildAction):
    import time
    def do(self, macros):
        builddir = macros.builddir % macros
        bldincdir = builddir+'/include/'
        destdir = '%(destdir)s/lib/modules/%(kver)s/build/' %macros
        destincdir = '%(destdir)s/lib/modules/%(kver)s/build/include/' %macros

        if Arch.x86 or Arch.x86_64:
            arch = 'x86'
        
        # Copy config, dependency files, and Makefiles
        os.path.walk(builddir, self.copyDepinfo,
                     (destdir, len(builddir), self.time.time(), arch,
                      re.compile(
                        r'(Kconfig(|\.[^/]*)|\.config|\.h?depend|Rules\.make|Makefile(.+)?'
                         '|asm-offsets\.s|\.tmp_versions|gcc-version\.sh)$')))
        util.copyfile('Module.symvers', destdir)

        # now get all the scripts
        util.copytree('scripts', destdir)
        util.remove('%s/scripts/*.o'%destdir)
        util.remove('%s/scripts/*/*.o'%destdir)
        scriptsdir = 'arch/%s/scripts'%arch
        if os.path.exists(scriptsdir):
            util.copytree(scriptsdir, '%s/arch/%s/' %(destdir, arch))
        util.copyfile('arch/%s/*.lds'%arch, '%s/arch/%s/' %(destdir, arch))

        # Create and populate include directories -- do this last to make
        # timestamps work out for dependencies when building against this tree

        util.copytree(bldincdir, destdir)

        if (macros.level % macros > 3) or ((macros.level % macros < 3) and (macros.sublevel % macros ) > 43):

            if os.path.exists('arch/%s/include/' % arch):
                util.copytree('arch/%s/include/' % arch,
                              destdir +'arch/%s/'%arch)
        else:
            util.copytree('arch/%s/include/asm' % arch, destincdir)
            os.symlink(destincdir +'/asm', 'asm-%s' % arch)

    def copyDepinfo(self, data, dirname, names):
        destdir, srclen, timestamp, arch, regex = data
        subpath = dirname[srclen+1:]
        pathlist = subpath.split('/')
        topdir = pathlist[0]
        nextdir = ''
        if len(pathlist) > 1:
            nextdir = pathlist[1]
        if topdir in ('include', 'scripts', 'Documentation'):
            return
        if topdir in ('arch',):
            if nextdir != arch:
                return
        for name in names:
            if regex.match(name):
                util.mkdirChain(util.joinPaths(destdir, subpath))
                srcpath = util.joinPaths(dirname, name)
                if not os.path.isdir(srcpath):
                    destpath = util.joinPaths(destdir, subpath, name)
                    util.copyfile(util.joinPaths(dirname, name), destpath)
                    # set the timestamp the same on all files to say
                    # the configuration is up-to-date
                    os.utime(destpath, (timestamp, timestamp))



class addConfigs(action.RecipeAction):
    from conary.build import lookaside

    def __init__(self, *args, **keywords):
        self.sourcemap = {}
        self.failed = False
        self.fetching=False
        action.RecipeAction.__init__(self, *args, **keywords)
        # we need to reference the entire flavor from __init__
        # so that the flavor is determined entirely during the
        # setup phase of loading the recipe, and not modified
        # while cooking (i.e. doAction)
        for flag in Flags.values():
            if flag: pass
        for basearch, flaglist, dictlist in self.recipe.configs:
            for flag in flaglist:
                if flag.startswith('flags.'):
                    pass
                elif flag.startswith('use.'):
                    if Use[flag.split('.')[1]]: pass
                else:
                    if Arch[basearch][flag]: pass

    def doAction(self):
        self.confdir = '%(builddir)s/%(maindir)s/configs/' %self.recipe.macros
        action.RecipeAction.doAction(self)

    def fetch(self, refreshFilter=None):
        self.fetching=True
        self.do()
        self.fetching=False
        return self.sourcemap.values()

    def do(self):
        if not self.fetching:
            util.mkdirChain(self.confdir)
        for basearch, flaglist, dictlist in self.recipe.configs:
            for dict in dictlist:
                self.do_one(basearch, flaglist, **dict)
        if self.failed:
            raise KernelConfigError, 'all keys set in any config file must be in config.base,\nbecause the order of the keys matters'


    def do_one(self, arch, flaglist, smp=False, pae=False, numa=False):
        print 'Creating configuration file for flavor [%s %s is: %s]' %(
            {True: 'kernel.smp', False:''}[smp] +
            {True: 'kernel.pae', False:''}[pae] +
            {True: 'kernel.numa', False:''}[numa],
            ', '.join(flaglist), arch,
        )
        config = self.getConfig()

        thisArch = True and Arch[arch]
        if not thisArch:
            print ' disallowing this config for architecture mismatch'

        if self.recipe.Flags.debug:
            self.mergefile(config, 'config.debug', unamePrefix=True)
        else:
            self.mergefile(config, 'config.nodebug', unamePrefix=True)

        if smp:
            self.mergefile(config, 'config.smp', unamePrefix=True)
        if smp != self.recipe.Flags.smp:
            if thisArch and not self.fetching:
                print ' disallowing this config for SMP mismatch'
            thisArch = False

        if pae:
            self.mergefile(config, 'config.pae', unamePrefix=True)
        if pae != self.recipe.Flags.pae:
            if thisArch and not self.fetching:
                print ' disallowing this config for PAE mismatch'
            thisArch = False

        if numa:
            self.mergefile(config, 'config.numa', unamePrefix=True)
        if numa != self.recipe.Flags.numa:
            if thisArch and not self.fetching:
                print ' disallowing this config for NUMA mismatch'
            thisArch = False

        flaglen = len(flaglist)
        self.mergefile(config, 'config.' + arch, unameArch=(flaglen == 0))

        selection = arch
        for index in range(flaglen):
            flag = flaglist[index]
            allowThisConfig = True
            isLocalFlag = flag.startswith('flags.')
            isUseFlag = flag.startswith('use.')
            if isLocalFlag:
                flag = flag.split('.')[1]
                allowThisConfig = self.recipe.Flags[flag]
            elif isUseFlag:
                flag = flag.split('.')[1]
                allowThisConfig = Use[flag]
            else:
                if thisArch and not Arch[arch][flag]:
                    allowThisConfig = False
            if not allowThisConfig:
                if thisArch and not self.fetching:
                    print ' disallowing this config for unset', flag
                thisArch = False
            selection += '.' + flag
            baseInFile = 'config.' + flag
            currentInFile = 'config.' + selection
            # config.<arch>.<foo>.<bar>.<flag> overrides config.<flag>
            self.mergefile(config, baseInFile)
            self.mergefile(config, currentInFile, unameArch=(index == flaglen-1))
            # some feature-specific flags require platform-specific changes
            if self.recipe.Flags.debug:
                self.mergefile(config, currentInFile + '.debug')
            if smp:
                self.mergefile(config, currentInFile + '.smp')
            if pae:
                self.mergefile(config, currentInFile + '.pae')
            if numa:
                self.mergefile(config, currentInFile + '.numa')

        self.mergefile(config, 'config.%s' % self.recipe.macros.gccver,
                       unamePrefix=True)

        # must come last
        self.mergefile(config, 'config.override')

        if not self.fetching:
            if config.failed:
                self.failed = True
                return

            config.write(self.confdir)

            if thisArch:
                # This is the one true .config, unless something more
                # specific comes along later
                util.copyfile(config.filename(self.confdir),
                    '%(builddir)s/%(maindir)s/.config' %self.recipe.macros)
                self.recipe.kernelConfig = config

    def getConfig(self):
        f = self.lookaside.findAll(self.recipe.cfg, self.recipe.laReposCache,
                'config.base', self.recipe.name, self.recipe.srcdirs)
        self.sourcemap['config.base'] = f
        if self.fetching:
            return None
        return KernelConfig(self.sourcemap['config.base'])

    def mergefile(self, config, filename, unamePrefix=False, unameArch=False):
        # searchAll because it is allowed to fail
        f = self.lookaside.searchAll(self.recipe.cfg, self.recipe.laReposCache,
            filename, self.recipe.name, self.recipe.srcdirs, localOnly=True)
        if f:
            self.sourcemap[filename] = f

        if self.fetching:
            return

        if f:
            config.mergefile(f)

        # chop off the config part
        configdata = filename[6:]
        if unamePrefix:
            config.setUnamePrefix(configdata)
        elif unameArch:
            config.setUnameArch(configdata)


# kernelConfigs can't be tested until after configuration has happened
class testConfig(action.RecipeAction):
    def __init__(self, *args, **keywords):
        self.key, self.value, self.errMsg = args[1:]
        action.RecipeAction.__init__(self, *args, **keywords)

    def do(self):
        if not self.recipe.kernelConfig[self.key] == self.value:
            self.recipe.reportErrors(self.errorMsg)



class KernelConfig(list):
    """
    A list of key=value pairs that can be addressed as a dictionary
    that maps key to value, in which setting self[key]=otherval will
    modify the list in-place.
    """
    def __init__(self, filename):
        self.dict = {}
        self.index = {}
        self.unamePrefix = ''
        self.unameArch = ''
        self.warn = False
        self.failed = False
        self.basefilename = filename
        print 'reading', filename
        f = file(filename)
        self.extend(f.read().split('\n'))
        f.close
        self.warn = True
    def setUnamePrefix(self, data):
        self.unamePrefix += data
    def setUnameArch(self, data):
        self.unameArch = data
    def mergefile(self, filename):
        if os.path.exists(filename):
            print ' merging', filename
            f = file(filename)
            self.applylines(f.read().split('\n'))
            f.close()
    def write(self, dirname):
        f = file(self.filename(dirname), 'w')
        f.write(self.format())
        f.close()
    def format(self):
        # kernel config files need weird syntax
        return "\n".join(self.commentNo(x) for x in self)
    def filename(self, dirname):
        return dirname+'/config'+self.unamePrefix+self.unameArch
    def extend(self, items):
        for item in items:
            self.append(item)
    def append(self, item):
        if self._isval(item):
            key, val = item.split("=")
            if self.warn:
                if key not in self:
                    print 'warning: key %s not found in %s' %(key, self.basefilename)
                    self.failed = True
            else:
                if key in self:
                    # need value stored more than one place
                    list.append(self, item)
                    self.index[key].append(len(self)-1)
            self[key] = val
        else:
            # probably a comment or empty line; just preserve it
            list.append(self, item)
    def applyline(self, line):
        "Do not append a line, only change a value if it is a key=value"
        if self._isval(line):
            self.append(line)
    def applylines(self, lines):
        for line in lines:
            self.applyline(line)
    def _isval(self, item):
        return item.find("=") != -1 and not item.startswith('#')
    def commentNo(self, line):
        # unusual comment-for-no syntax
        if line.endswith("=n"):
            key = line.split("=")[0]
            return "# %s is not set" %key
        return line
    def __getitem__(self, key):
        if type(key) == type(""):
            return self.dict[key]
        else:
            return list.__getitem__(self, key)
    def __setitem__(self, key, val):
        line = "=".join((key, val))
        if key in self.dict:
            for index in self.index[key]:
                # make sure all instances are consistent
                list.__setitem__(self, index, line)
            self.dict[key] = val
        else:
            list.append(self, line)
            self.dict[key] = val
            self.index[key] = [ len(self)-1 ]
    def __delitem__(self, key):
        raise IndexError, 'dictionary is append/modify-only'
    def __contains__(self, item):
        return item in self.dict

class KernelConfigError(Exception):
    pass

class KernelPackageError(Exception):
    pass
