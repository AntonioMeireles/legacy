#!/usr/bin/python
#
# Copyright (c) 2006-2009 rPath, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation and
# available from http://www.rpath.com/licenses/copyright/GPL-2
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#

from conary import rpmhelper
from conary.lib import log

# common arguments for all the policy exceptions
_args = dict(exceptions='.*', allowUnusedFilters=True)

class RPMImportRecipe(PackageRecipe):
    name = 'rpm-import'
    version = '0.1'
    rpms = None
    rpmNames = None
    rpmFiles = None
    rpmFileMap = None
    archs = set()
    extraArch =  { 'i686': []}
    abstractBaseClass = True
    rpmUrl = ''
    importScripts = True

    # variable used for package creator
    fileArches = None

    def __init__(r, *args, **kw):
        r.usedrpms = set()
        r.headers = []
        PackageRecipe.__init__(r, *args, **kw)

    @staticmethod
    def parseNVRA(filename):
        assert(filename.endswith('.rpm'))
        filename = os.path.basename(filename)
        # Strip trailing .rpm and extract arch
        dotPos = filename[:-4].rindex('.')
        nvr, a = filename[:dotPos], filename[dotPos + 1:-4]
        arr = nvr.split('-')
        n = None
        v = None
        r = None
        if len(arr) > 2:
            v, r = arr[-2], arr[-1]
            n = '-'.join(arr[:-2])
        return n, v, r, a

    @staticmethod
    def parseManifest(stream):
        ret = []
        # Grab all non-commented lines
        for line in stream:
            line = line.strip()
            if line[0] == '#':
                continue
            ret.append(line)
        return ret

    @classmethod
    def extractSources(cls, sources, openSourceFileFn):
        rpms = []
        for src in sources:
            if src.endswith('.rpm'):
                rpms.append(src)
                continue
            if src != 'manifest':
                # No manifest file
                continue
            f = openSourceFileFn(src)
            rpms.extend(cls.parseManifest(f))
        return rpms

    @classmethod
    def computeVersion(cls, rpms):
        ver = None
        for rpm in rpms:
            n_, v_, r_, a_ = cls.parseNVRA(rpm)
            vr = '_'.join([v_, r_])
            if ver is None:
                ver = vr
            elif vr != ver:
                raise ValueError("inconsistent RPM version/release pair "
                    "'%s' and '%s'" % (vr, ver))

        return ver

    def _extractRpmNamesArches(r):
        # Extract list of rpm names
        r.rpmNames = set()
        r.rpmFileMap = {}
        for rpm in r.sourceFiles:
            n_, v_, r_, a_ = r.parseNVRA(rpm)
            if a_ in ('src', 'nosrc'):
                r.addSource(r.rpmUrl + rpm)
                continue
            nvr_ = '-'.join((n_, v_, r_))
            nv_ = '-'.join((n_, v_))
            r.rpmNames.add((n_, v_))
            if (nv_, a_) in r.rpmFileMap:
                raise RPMImportError('multiple rpms of the same name, '
                                     'version, and arch found')
            r.rpmFileMap[(nv_, a_)] = rpm
            if a_ == 'i686':
                r.extraArch['i686'].append(n_)
            r.archs.add(a_)

    @staticmethod
    def _getRpmName(rpm):
        # if we have a tuple, it's name, version
        if isinstance(rpm, tuple):
            rpmname, ver = rpm
            rpm = rpmname + '-%s' % ver
        else:
            rpmname = rpm
            rpm += '-%(version)s-%(release)s'
        return rpmname, rpm

    def _getCommonPkgArch(r):
        scores = {'i386':   0,
                  'i486':   1,
                  'i586':   2,
                  'i686':   3}

        lcd = None
        for arch in r.archs:
            if arch not in scores:
                continue
            if lcd is None or scores[arch] < scores[lcd]:
                lcd = arch

        return lcd

    def _computeArch(r, rpm, rpmname, rpmarch):
        pkgarch = rpmarch
        if rpmarch.startswith('i') and rpmarch.endswith('86'):
            arch = Arch.x86
            if rpmarch != 'i386':
                arch = arch[rpmarch]
            if (rpmarch in r.extraArch
                and rpmname not in r.extraArch[rpmarch]):
                pkgarch = r._getCommonPkgArch()
        elif rpmarch == 'x86_64':
            arch = Arch.x86_64
        elif rpmarch == 'noarch':
            arch = True
        else:
            raise RPMImportError('unsupported arch: %s' % rpmarch)

        if (rpm, pkgarch) in r.rpmFileMap:
            rpmfile = r.rpmFileMap[(rpm, pkgarch)]
        elif (rpm, 'noarch') in r.rpmFileMap:
            arch = True
            rpmfile = r.rpmFileMap[(rpm, 'noarch')]
        elif pkgarch in r.extraArch:
            return None
        else:
            raise RPMImportError('Could not find a %s version of %s'
                                 % (pkgarch, rpm))
        rpmfilename = os.path.basename(rpmfile % r.macros)

        if arch:
            r.usedrpms.add(rpmfilename)

        return arch, rpmfile

    def _collapsePackages(r, rpmname):
        # follow the packaging splitting from the RPMs we're importing
        packagename = rpmname
        # collapse libfoo -> foo when the main package name is foo
        # but don't collapse libbar -> bar when it's produced by the
        # foo src rpm.
        if (not r.name.startswith('lib')
            and packagename.startswith('lib')
            and packagename[3:].startswith(r.name)):
            packagename = packagename[3:]
        # collapse suffixes
        for suffix in ('-devel', '-docs', '-doc', '-info',
                       '-lib', '-libs', '-locale', '-man',
                       '-i18ndata', '-html', '-debuginfo',
                       '-debugsource',):
            # collapse foo-devel -> foo
            if rpmname.endswith(suffix) and r.name != rpmname:
                packagename = packagename[:-len(suffix)]
                break
        return packagename

    def unpack(r):
        r._extractRpmNamesArches()
        for rpm in r.rpmNames:
            rpmname, rpm = r._getRpmName(rpm)
            for rpmarch in r.archs:
                val = r._computeArch(rpm, rpmname, rpmarch)
                if not val: continue
                arch, rpmfile = val

                # maintain compatibility with pcreator
                if r.fileArches:
                    arch = r.fileMatchesArch(rpmfile)

                packagename = r._collapsePackages(rpmname)
                fullUrl = os.path.join(r.rpmUrl % { 'arch' : rpmarch },
                                       rpmfile % r.macros)
                r.addArchive(fullUrl, dir='/', use=arch,
                             package=packagename, preserveOwnership = True)

    def disableBuildRequirementsPolicy(r):
        del r.EnforceSonameBuildRequirements
        del r.EnforceJavaBuildRequirements
        del r.EnforceCILBuildRequirements
        del r.EnforceConfigLogBuildRequirements
        # Note that perl and python runtime requirement CANNOT
        # be discovered without listing them as runtime requirements,
        # so it is important not to disable
        # r.Enforce{Perl,Python}BuildRequirements

    def disablePolicy(r):
        del r.BadInterpreterPaths
        del r.CheckDesktopFiles
        del r.CheckDestDir
        r.CheckSonames(**_args)
        r.DanglingSymlinks(**_args)
        r.ExecutableLibraries(**_args)
        del r.FilesForDirectories
        del r.FilesInMandir
        del r.FixDirModes
        # On Ubuntu there is no FixupMultilibPaths policy
        if 'FixupMultilibPaths' in r._policyMap:
            del r.FixupMultilibPaths
        r.LinkCount(**_args)
        del r.IgnoredSetuid
        del r.ImproperlyShared
        del r.NonBinariesInBindirs
        del r.NonMultilibComponent
        del r.NonMultilibDirectories
        del r.NormalizeInfoPages
        del r.NormalizeCompression
        del r.NormalizeInterpreterPaths
        del r.RemoveNonPackageFiles
        r.WarnWriteable(**_args)
        del r.WorldWriteableExecutables
        # ObsoletePaths does not honor exceptions
        del r.ObsoletePaths
        del r.NormalizeManPages

    def disableStrip(r):
        """
        Default to not stripping; allow override in subclasses with:

        def disableStrip(r): pass
        """
        r.Strip(**_args)

    def policy(r):
        """
        hook for adding additional policy in subclasses.
        """
        pass

    def preprocess(r):
        "hook for adding sources/policy calls before anything else"
        pass

    def postprocess(r):
        "hook for adding sources/policy calls after anything else"
        pass

    def readHeaders(r):
        sourceList = set(r.fetchAllSources())
        for rpmname in r.usedrpms:
            rpmfiles = [ x for x in sourceList
                         if os.path.basename(x) == rpmname ]
            if len(rpmfiles) != 1:
                raise RPMImportError('more than one source object matches '
                                      'the "%s" rpm filename' %rpmname)
            rpmfile = rpmfiles[0]
            r.headers.append(rpmhelper.readHeader(file(rpmfile)))

    def processScripts(r):
        for header in r.headers:
            r._addTroveScripts(header)

    def processFiles(r):
        # given the set of RPM headers used, set permissions, config
        # flags, etc appropriately
        for header in r.headers:
            for path, mode, rdev, flags, username, groupname in zip(
                header.paths(),
                header[rpmhelper.FILEMODES],
                header[rpmhelper.FILERDEVS],
                header[rpmhelper.FILEFLAGS],
                header[rpmhelper.FILEUSERNAME],
                header[rpmhelper.FILEGROUPNAME]):
                path = util.normpath(path)
                escaped_path = util.literalRegex(path)
                escaped_path = escaped_path.replace('\\/', '/')
                if stat.S_ISCHR(mode) or stat.S_ISBLK(mode):
                    if stat.S_ISCHR(mode):
                        type='c'
                    else:
                        type='b'
                    # this is correct for 32-bit device number
                    # RPM does not provide 64-bit device number
                    minor = rdev & 0xff | (rdev >> 12) & 0xffffff00
                    major = (rdev >> 8) & 0xfff
                    r.MakeDevices(escaped_path, type, major, minor,
                                  username, groupname, mode&0777)
                    continue

                if flags & (1 << 0):
                    # CONFIG
                    r.Config(escaped_path)
                if (flags & (1 << 1) or
                      flags & (1 << 7) or
                      flags & (1 << 8)):
                    # DOC, LICENSE, README
                    r.ComponentSpec('doc', escaped_path)
                if flags & (1 << 4):
                    # NOREPLACE
                    r.InitialContents(escaped_path)
                if flags & (1 << 6):
                    # GHOST.  We only handle ghost files, not ghost dirs
                    if stat.S_ISREG(mode):
                        r.Create(path)
                        # Do not mark pyc and pyo files as InitialContents
                        # since they are automatically marked as transient.
                        # Also applies to emacs lisp files.
                        if not (path.endswith('.pyc') or
                                path.endswith('.pyo') or
                                path.endswith('.el')):
                            r.InitialContents(escaped_path)
                    elif stat.S_ISDIR(mode):
                        r.MakeDirs(escaped_path)
                        r.ExcludeDirectories(exceptions=escaped_path)

                # handle "special" permissions (although un-cpio'ing
                # the payload should have set them all correctly, payload
                # doesn't include things like %ghost)
                if not stat.S_ISLNK(mode):
                    r.SetModes(path, mode & 07777)

    def processRequires(r):
        # FIXME: implement
        pass

    def processProvides(r):
        # FIXME: implement
        pass

    def setup(r):
        if r.__class__.__name__ == 'RPMImportRecipe':
            return

        r.macros.release = ''
        if '_' in r.version:
            r.macros.version, r.macros.release = r.version.rsplit('_', 1)

        r.preprocess()
        r.unpack()
        r.policy()
        if r._lightInstance:
            return
        r.readHeaders()
        if r.importScripts:
            r.processScripts()
        r.processFiles()
        r.disableBuildRequirementsPolicy()
        r.disableStrip()
        r.disablePolicy()
        r.postprocess()

    # Compatibility with Package Creator
    recipeClassSetup = setup

    _tagNameMap = {
        rpmhelper.PREIN:    "preinstall",
        rpmhelper.POSTIN:   "postinstall",
        rpmhelper.PREUN:    "preuninstall",
        rpmhelper.POSTUN:   "postuninstall",
    }

    def _getScript(self, header, scriptTag, scriptInterpTag):
        if scriptTag not in header:
            return None
        tagName = self._tagNameMap[scriptTag]
        interp = header.get(scriptInterpTag, "/bin/sh")
        if interp == "/sbin/ldconfig":
            log.info("  Ignoring %s script with interpreter %s" % (
                     tagName, interp))
            return None
        if interp != "/bin/sh":
            log.info("  Ignoring %s script with unsupported interpreter %s" % (
                     tagName, interp))
            return None
        return header[scriptTag]

    def _getRandomString(self):
        import os
        import sha

        x = sha.new()

        if not os.path.exists("/dev/urandom"):
            import time
            x.update("%.9f" % time.time())
        else:
            x.update(file("/dev/urandom").read(16))

        return x.hexdigest()

    def _getTroveScripts(self, header):
        _map = {
            'prein':    (rpmhelper.PREIN, rpmhelper.PREINPROG),
            'postin':   (rpmhelper.POSTIN, rpmhelper.POSTINPROG),
            'preun':    (rpmhelper.PREUN, rpmhelper.PREUNPROG),
            'postun':   (rpmhelper.POSTUN, rpmhelper.POSTUNPROG),
        }
        scripts = ( (x, self._getScript(header, t, ti))
                              for (x, (t, ti)) in _map.items() )
        scripts = dict((x, y) for (x, y) in scripts if y)
        return scripts

    _scriptTemplate = """\
#!/bin/sh
cat << %(separator)s | %(interpreter)s
%(contents)s
%(separator)s
"""

    @staticmethod
    def _filenameFromHeader(header):
        return "%s-%s-%s.%s.rpm" % (
            header[rpmhelper.NAME],
            header[rpmhelper.VERSION],
            header[rpmhelper.RELEASE],
            header[rpmhelper.ARCH],
        )

    def _addTroveScripts(self, header):
        # For now, we are adding the scripts we find in the rpm in the package
        # with the same name as the rpm (no components)

        log.info("Importing scripts for %s" % self._filenameFromHeader(header))

        rpmScripts = self._getTroveScripts(header)
        if not rpmScripts:
            return
        randString = self._getRandomString()

        # Map rpm tags into conary tags. The second value in the map is the
        # argument count ($1) that gets passed into the rpm scriptlet.
        scriptsMap = [
            ('prein',  [('preupdate', 2), ('preinstall', 1)]),
            ('postin', [('postupdate', 2), ('postinstall', 1)]),
            ('preun',  [('preupdate', 1), ('preerase', 0)]),
            ('postun', [('postupdate', 1), ('posterase', 0)]),
        ]

        conaryScripts = {}
        for (rpmTag, actList) in scriptsMap:
            if rpmTag not in rpmScripts:
                continue
            d = dict(separator = randString, contents = rpmScripts[rpmTag])
            for (conaryTag, argCount) in actList:
                d['interpreter'] = "/bin/sh -s %s" % argCount
                ns = self._scriptTemplate % d
                if conaryTag in conaryScripts:
                    ns = "%s\n%s" % (conaryScripts[conaryTag], ns)
                conaryScripts[conaryTag] = ns

        methodMap = [
            ('preinstall',  self.ScriptPreInstall),
            ('postinstall', self.ScriptPostInstall),
            ('preupdate',   self.ScriptPreUpdate),
            ('postupdate',  self.ScriptPostUpdate),
            ('preerase',    self.ScriptPreErase),
            ('posterase',   self.ScriptPostErase),
        ]
        rpmName = header[rpmhelper.NAME]
        for conaryTag, method in methodMap:
            if conaryTag in conaryScripts:
                log.info("    Adding %s script" % conaryTag)
                method(rpmName, contents = conaryScripts[conaryTag])

class RPMImportError(Exception):
    pass
