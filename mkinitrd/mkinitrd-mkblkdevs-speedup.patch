diff --git a/nash/devtree.c b/nash/devtree.c
index 6ced12d..1aaad44 100644
--- a/nash/devtree.c
+++ b/nash/devtree.c
@@ -1131,6 +1131,23 @@ static const struct devtree_constraint {
     { DEV_TYPE_NONE, DEV_TYPE_NONE, 0, 0 }
 };
 
+struct nash_slave_list {
+    const char *name;
+    int valid;
+    dev_t devno;
+    struct nash_slave_list *next;
+};
+
+/* Setting this to zero rather than one ups the mkblkdevs time on a
+ * certain box (*) from 4 minutes to 5.2 minutes (nearly zero system
+ * time), compared with 19.5 minutes without any caching whatsoever
+ * (more than 2/3rd of which on system CPU use).
+ *
+ * (*) 4 disks, 15 partitions each, combined in RAID 1 pairs, almost
+ * all of which used as physical volumes of a single volume group
+ * containing 6 logical volumes.  */
+#define CACHE_SLAVES_ONCE 1
+
 static int is_sysfs_slave(struct nash_dev_node *adult,
     struct nash_dev_node *child)
 {
@@ -1139,43 +1156,91 @@ static int is_sysfs_slave(struct nash_dev_node *adult,
     struct stat sb;
     int rc = 0;
     char slaves[strlen(child->bdev->sysfs_path) + strlen("/slaves") + 1];
+    struct nash_slave_list **slavepp = &child->slave_cache, *slavep;
+
+#if CACHE_SLAVES_ONCE
+    if (*slavepp == (void*)-1)
+	return 0;
+#endif
+
+    for (slavep = *slavepp; slavep; slavep = slavep->next)
+	if (slavep->valid && slavep->devno == adult->bdev->devno)
+	    return 1;
+
+#if CACHE_SLAVES_ONCE
+    if (*slavepp)
+	return 0;
+#endif
 
     strcpy(slaves, child->bdev->sysfs_path);
     strcat(slaves, "/slaves");
 
-    if (!(dir = opendir(slaves)))
+    if (!(dir = opendir(slaves))) {
+#if CACHE_SLAVES_ONCE
+	child->slave_cache = (void*)-1;
+#endif
         return 0;
+    }
 
     while ((entry = readdir(dir))) {
-        char slave[strlen(slaves) + 1 + strlen(entry->d_name) + 1];
-        char devpath[sizeof(slave) + strlen("/dev") + 1];
-        char devbuf[32] = "";
-        int maj, min;
-        FILE *df;
-
-        strcpy(slave, slaves); 
-        strcat(slave, "/");
-        strcat(slave, entry->d_name);
-        strcpy(devpath, slave);
-        strcat(devpath, "/dev");
-
-        lstat(slave, &sb);
-        if (!S_ISLNK(sb.st_mode))
-            continue;
-
-        if (!(df = fopen(devpath, "r")))
-            continue;
-
-        if (!fgets(devbuf, 31, df)) {
-            fclose(df);
-            continue;
-        }
-        fclose(df);
-
-        if (sscanf(devbuf, "%d:%d", &maj, &min) != 2)
-            continue;
-
-        if (makedev(maj,min) == adult->bdev->devno) {
+	dev_t devno;
+
+	while (*slavepp &&
+	       strcmp(entry->d_name, (slavep = *slavepp)->name) != 0) {
+	    *slavepp = slavep->next;
+	    free(slavep);
+	}
+
+	if (!*slavepp) {
+	    char slave[strlen(slaves) + 1 + strlen(entry->d_name) + 1];
+	    char devpath[sizeof(slave) + strlen("/dev") + 1];
+	    char devbuf[32] = "";
+	    int maj, min;
+	    FILE *df;
+
+	    *slavepp = slavep = calloc (1, sizeof (*slavep));
+	    if (slavep) {
+		slavep->name = strdup(entry->d_name);
+		slavep->next = NULL;
+		slavep->valid = 0;
+		slavepp = &slavep->next;
+	    }
+
+	    strcpy(slave, slaves);
+	    strcat(slave, "/");
+	    strcat(slave, entry->d_name);
+	    strcpy(devpath, slave);
+	    strcat(devpath, "/dev");
+
+	    lstat(slave, &sb);
+	    if (!S_ISLNK(sb.st_mode))
+		continue;
+
+	    if (!(df = fopen(devpath, "r")))
+		continue;
+
+	    if (!fgets(devbuf, 31, df)) {
+		fclose(df);
+		continue;
+	    }
+	    fclose(df);
+
+	    if (sscanf(devbuf, "%d:%d", &maj, &min) != 2)
+		continue;
+
+	    devno = makedev(maj,min);
+	    if (slavep) {
+		slavep->valid = 1;
+		slavep->devno = devno;
+	    }
+	} else {
+	    slavepp = &slavep->next;
+	    if (!slavep->valid)
+		continue;
+	    devno = slavep->devno;
+	}
+
+	if (devno == adult->bdev->devno) {
             rc = 1;
             break;
         }
diff --git a/nash/devtree.h b/nash/devtree.h
index 5775579..63cd34b 100644
--- a/nash/devtree.h
+++ b/nash/devtree.h
@@ -60,6 +60,8 @@ struct nash_dev_node {
 
     struct nash_dev_tree *tree;
 
+    struct nash_slave_list *slave_cache;
+
     int probe_mask;
 };
 
