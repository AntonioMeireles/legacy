diff -Naur anaconda-10.2.1.5.orig/conaryinstall.py~ anaconda-10.2.1.5/conaryinstall.py~
--- anaconda-10.2.1.5.orig/conaryinstall.py~	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-10.2.1.5/conaryinstall.py~	2005-09-16 21:49:40.000000000 -0400
@@ -0,0 +1,350 @@
+#
+# Copyright (c) 2004-2005 rpath, Inc.
+#
+# This file is distributed under the terms of the Common Public License,
+# version 1.0. A copy of this license should have been distributed with this
+# source file in a file called LICENSE. If it is not present, the license
+# is always available at http://www.opensource.org/licenses/cpl.php.
+#
+# This program is distributed in the hope that it will be useful, but
+# without any waranty; without even the implied warranty of merchantability
+# or fitness for a particular purpose. See the Common Public License for
+# full details.
+#
+
+from flags import flags
+from hdrlist import groupSetFromCompsFile, HeaderList, HeaderListFromFile
+from installmethod import InstallMethod, FileCopyException
+from product import *
+from rhpl.log import log
+from rhpl.translate import _
+from syslogd import syslog
+import iutil
+import packages
+import rpm
+import timer
+
+import conarycomps
+import conaryclient, conarycfg
+from repository import changeset, netclient, repository
+from callbacks import UpdateCallback, ChangesetCallback
+from lib import util
+
+import sys
+
+class InstallCallback(UpdateCallback, ChangesetCallback):
+    def preparingChangeSet(self):
+        self.status = 'preparing'
+        self.progress.setPackageStatus("Building changeset request...", None)
+
+    def resolvingDependencies(self):
+        self.status = 'resolving'
+        self.progress.setPackageStatus("Resolving dependencies...", None)
+
+    def requestingChangeSet(self):
+        self.timer.start()
+        self.status = 'downloading'
+        self.progress.setPackageStatus("Requesting changeset...", None)
+
+    def downloadingChangeSet(self, got, need):
+        self.status = 'downloading'
+        if need != 0:
+            self.progress.setPackageStatus(self.status, "(%d%% of %dk)"
+                                           % ((got * 100) / need, need / 1024))
+
+    def restoreFiles(self, size, totalSize):
+        if self.status != 'install':
+            self.progress.setPackageStatus(_("Installing..."), None)
+            self.status = 'install'
+        self.restored += size
+        if totalSize != 0:
+            self.progress.setPackageScale(self.restored, totalSize)
+
+    def setUpdateHunk(self, num, total):
+        if not total:
+            return
+        if num:
+            # mark the last hunk complete
+            h = rpm.Header(None, "Changeset %d" %(num-1), None,
+                           "of", "%d" %total,
+                           iutil.getArch(), self.restored, 0)
+            self.progress.completePackage(h, self.timer)
+        self.restored = 0
+        self.updateHunk = (num, total)
+        h = rpm.Header(None, "Changeset %d" %num, None, "of", "%d" %total,
+                       iutil.getArch(), 0, 0)
+        self.progress.setPackage(h)
+        self.progress.setPackageScale(0, 1)
+
+    def __init__(self, progress, timer):
+        self.timer = timer
+        self.progress = progress
+        self.restored = 0
+        self.status = None
+        self.updateHunk = None
+
+class HeaderListFromChangeSet(HeaderList):
+    def __init__(self, cs):
+        headerGen = conarycomps.HeaderListGenerator(iutil.getArch())
+        hdlist = headerGen.generateHeaderListFromChangeSet(cs)
+	HeaderList.__init__(self, hdlist)
+
+class ConaryRepositoryInstallMethod(InstallMethod):
+    def readCompsViaMethod(self, hdlist):
+        compsGen = conarycomps.CompsGenerator(self.cfg)
+        comps = compsGen.generateCompsFromChangeSet(self.cs)
+        # unfortunately we can't just feed the comps string in, we have to
+        # write it to a file
+        f = open('/tmp/comps.xml', 'w')
+        f.write(comps)
+        f.close()
+        return groupSetFromCompsFile('file:///tmp/comps.xml', hdlist)
+
+    def readHeaders(self):
+        repos = netclient.NetworkRepositoryClient(self.cfg.repositoryMap)
+
+        # get the latest group-dist for our default flavor
+        try:
+            trvList = repos.findTrove(self.cfg.installLabelPath[0],
+                                      ('group-os', '', None),
+                                      defaultFlavor=self.cfg.flavor)
+        # translate exceptions to one that packages.py can handle
+        except Exception, e:
+            raise FileCopyException, str(e)
+        name, version, flavor = trvList[0]
+
+        # generate a changeset in order to get all the needed trove
+        # information.  Save this changeset
+        csList = [(name, (None, None), (version, flavor), True)]
+        self.cs = repos.createChangeSet(csList, withFiles=False,
+                                        withFileContents=False)
+
+        hdrlist = HeaderListFromChangeSet(self.cs)
+        return hdrlist
+
+    def getFilename(self, filename, callback=None, destdir=None, retry=1,
+                    disc = 1):
+        # we have no way to access individual files from the repository
+        return '/dev/null'
+
+    def __init__(self, method, rootPath, intf):
+	InstallMethod.__init__(self, method, rootPath, intf)
+        self.cfg = conarycfg.ConaryConfiguration()
+        self.cfg.initializeFlavors()
+        self.cfg.root = rootPath
+        self.cfg.threaded = False
+        self.cfg.tempDir = '/tmp/'
+        util.settempdir(self.cfg.tempDir)
+        self.cs = None
+
+from urlinstall import UrlInstallMethod
+class ConaryUrlInstallMethod(UrlInstallMethod):
+    def readHeaders(self):
+	fn = self.getFilename("%s/base/cslist" % (productPath,), callback=None)
+        hdrlist = HeaderListFromFile(fn)
+        os.unlink(fn)
+        return hdrlist
+
+def conaryInstallPost(id, intf, instPath):
+    iutil.copyFile('/etc/conaryrc', instPath + '/etc/conaryrc')
+    # run the tag scripts (if they exist)
+    if os.path.exists(instPath + '/root/conary-tag-script'):
+        win = intf.waitWindow(_("Running"),
+                              _("Running post installation scripts"))
+        old = open(instPath + '/root/conary-tag-script', 'r')
+        new = open(instPath + '/root/conary-tag-script.new', 'w')
+        # put ldconfig at the top of the script, kill all the others
+        new.write('/sbin/ldconfig\n')
+        for line in old:
+            if not line.startswith('/sbin/ldconfig'):
+                new.write(line)
+        new.close()
+        old.close()
+        os.rename(instPath + '/root/conary-tag-script.new',
+                  instPath + '/root/conary-tag-script')
+        iutil.execWithRedirect('/bin/sh',
+                               ('/bin/sh', '-x', '/root/conary-tag-script'),
+                               stdout='/root/conary-tag-script.output',
+                               stderr='/root/conary-tag-script.output',
+                               root=instPath)
+        win.pop()
+
+    for (n, tag) in id.grpset.kernelVersionList():
+        log('making initrd for %s', n)
+        packages.recreateInitrd(n, instPath)
+
+def doConaryRepositoryInstall(method, id, intf, instPath):
+    # set up install.log
+    instLogName = instPath + '/root/install.log'
+    try:
+	iutil.rmrf(instLogName)
+    except OSError:
+	pass
+    instLog = open(instLogName, "w+")
+    instLogFd = instLog.fileno()
+
+    # set up our syslogd
+    if flags.setupFilesystems:
+        # dont start syslogd if we arent creating filesystems
+	syslogname = instLogName + '.syslog'
+	try:
+	    iutil.rmrf (syslogname)
+	except OSError:
+	    pass
+	syslog.start(instPath, syslogname)
+    else:
+	syslogname = None
+
+    pkgTimer = timer.Timer(start = 0)
+
+    total = 0
+    l = []
+    for p in id.grpset.hdrlist.values():
+        if p.isSelected():
+            instLog.write('installing %s %s-%s.\n' %(p.hdr['name'],
+                                                     p.hdr['version'],
+                                                     p.hdr['release']))
+            n, v, f = p.hdr.nvf
+            job = (name, (None, None), (v, f), False)
+            l.append(job)
+            total += (p[rpm.RPMTAG_SIZE] / 1024)
+
+    id.instProgress.setSizes(len(l), total, 0)
+    id.instProgress.processEvents()
+    # XXX use config from somewhere else
+    cfg = conarycfg.ConaryConfiguration()
+    cfg.initializeFlavors()
+    cfg.root = instPath
+    cfg.threaded = False
+    cfg.tempDir = instPath + '/var/tmp'
+    cfg.repositoryMap['conary.rpath.com'] = 'http://conary-commits.rpath.com/conary/'
+    util.settempdir(cfg.tempDir)
+
+    client = conaryclient.ConaryClient(cfg)
+
+    callback = InstallCallback(id.instProgress, pkgTimer)
+
+    updJob = client.updateChangeSet(l, resolveDeps = False,
+                                    keepExisting = True,
+                                    callback = callback,
+                                    recurse = True,
+                                    split = True)[0]
+    client.applyUpdate(updJob, replaceFiles = True,
+                       tagScript = instPath + '/root/conary-tag-script',
+                       localRollbacks = cfg.localRollbacks,
+                       callback = callback)
+    id.instProgress.setPackageScale(1, 1)
+    id.instProgress = None
+
+    conaryInstallPost(id, intf, instPath)
+
+    for (n, tag) in id.grpset.kernelVersionList():
+        log('making initrd for %s', n)
+        packages.recreateInitrd(n, instPath)
+
+    method.filesDone()
+
+def doConaryInstall(method, id, intf, instPath):
+    if flags.test:
+	return
+
+    if isinstance(method, ConaryRepositoryInstallMethod):
+        # we handle conary repository installs differently
+        return doConaryRepositoryInstall(method, id, intf, instPath)
+
+    # set up install.log
+    instLogName = instPath + '/root/install.log'
+    try:
+	iutil.rmrf (instLogName)
+    except OSError:
+	pass
+    instLog = open(instLogName, "w+")
+    instLogFd = instLog.fileno()
+
+    # set up our syslogd
+    if flags.setupFilesystems:
+        # dont start syslogd if we arent creating filesystems
+	syslogname = instLogName + '.syslog'
+	try:
+	    iutil.rmrf (syslogname)
+	except OSError:
+	    pass
+	syslog.start(instPath, syslogname)
+    else:
+	syslogname = None
+
+    pkgTimer = timer.Timer(start = 0)
+
+    total = 0
+    l = []
+    for p in id.grpset.hdrlist.values():
+        if p.isSelected():
+            l.append(p)
+            total += (p[rpm.RPMTAG_SIZE] / 1024)
+    l.sort(packages.sortPackages)
+
+    id.instProgress.setSizes(len(l), total, 0)
+    id.instProgress.processEvents()
+    # FIXME: use config from somewhere else
+    cfg = conarycfg.ConaryConfiguration()
+    cfg.initializeFlavors()
+    cfg.root = instPath
+    cfg.threaded = False
+
+    cfg.tempDir = instPath + '/var/tmp'
+    util.settempdir(cfg.tempDir)
+
+    client = conaryclient.ConaryClient(cfg)
+
+    for p in l:
+        h = p.hdr
+        instLog.write('installing %s %s-%s.\n' %(h['name'],
+                                                 h['version'],
+                                                 h['release']))
+        instLog.flush()
+        id.instProgress.setPackage(h)
+        id.instProgress.setPackageScale(0, 1)
+        # do the install
+        pkgTimer.start()
+        downloadCb = id.instProgress.setPackageStatus
+        while True:
+            try:
+                fn = method.getPackageFilename(h, pkgTimer,
+                                               callback=downloadCb)
+                break
+            except FileCopyException:
+                method.unmountCD()
+                intf.messageWindow(_("Error"),
+                    _("The package %s-%s-%s cannot be opened. This is due "
+                      "to a missing file or perhaps a corrupt package.  "
+                      "If you are installing from CD media this usually "
+                      "means the CD media is corrupt, or the CD drive is "
+                      "unable to read the media.\n\n"
+                      "Press <return> to try again.") % (h['name'],
+                                                         h['version'],
+                                                         h['release']))
+
+        cs = changeset.ChangeSetFromFile(fn)
+        # do not recurse if we're installing a group
+        recurse = not h['name'].startswith('group-')
+        callback = InstallCallback(id.instProgress, pkgTimer)
+        updJob = client.updateChangeSet([cs], resolveDeps = False,
+                                        keepExisting = True,
+                                        callback = callback,
+                                        recurse = recurse)[0]
+        client.applyUpdate(updJob, replaceFiles = True,
+                           tagScript = instPath + '/root/conary-tag-script',
+                           localRollbacks = cfg.localRollbacks,
+                           callback = callback)
+        method.unlinkFilename(fn)
+        id.instProgress.setPackageScale(1, 1)
+        id.instProgress.completePackage(h, pkgTimer)
+
+        # explicitly delete the changeset so that the underlying file
+        # will be closed.
+        del cs
+        del updJob
+
+    id.instProgress = None
+    conaryInstallPost(id, intf, instPath)
+    method.filesDone()
diff -Naur anaconda-10.2.1.5.orig/packages.py~ anaconda-10.2.1.5/packages.py~
--- anaconda-10.2.1.5.orig/packages.py~	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-10.2.1.5/packages.py~	2005-09-16 21:49:40.000000000 -0400
@@ -0,0 +1,1643 @@
+#
+# packages.py: package management - mainly package installation
+#
+# Erik Troan <ewt@redhat.com>
+# Matt Wilson <msw@redhat.com>
+# Michael Fulbright <msf@redhat.com>
+# Jeremy Katz <katzj@redhat.com>
+#
+# Copyright 2001-2003 Red Hat, Inc.
+#
+# This software may be freely redistributed under the terms of the GNU
+# library public license.
+#
+# You should have received a copy of the GNU Library Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+import iutil
+import isys
+import rpm
+import os
+import timer
+import time
+import sys
+import string
+import pcmcia
+import language
+import fsset
+import kudzu
+from flags import flags
+from product import *
+from constants import *
+from syslogd import syslog
+from hdrlist import PKGTYPE_MANDATORY, PKGTYPE_DEFAULT, DependencyChecker
+from installmethod import FileCopyException
+
+from rhpl.log import log
+from rhpl.translate import _
+import rhpl.arch
+import bootloader
+
+def queryUpgradeContinue(intf, dir):
+    if dir == DISPATCH_FORWARD:
+        return
+
+    rc = intf.messageWindow(_("Proceed with upgrade?"),
+                       _("The file systems of the Linux installation "
+                         "you have chosen to upgrade have already been "
+                         "mounted. You cannot go back past this point. "
+                         "\n\n") + 
+                     _( "Would you like to continue with the upgrade?"),
+                                      type = "yesno")
+    if rc == 0:
+        sys.exit(0)
+    return DISPATCH_FORWARD
+
+def doPostAction(id, instPath, intf = None):
+    id.instClass.postAction(instPath, flags.serial, intf)
+
+def firstbootConfiguration(id, instPath):
+    if id.firstboot == FIRSTBOOT_RECONFIG:
+        f = open(instPath + '/etc/reconfigSys', 'w+')
+        f.close()
+    elif id.firstboot == FIRSTBOOT_SKIP:
+        f = open(instPath + '/etc/sysconfig/firstboot', 'w+')
+        f.write('RUN_FIRSTBOOT=NO')
+        f.close()
+
+    return
+        
+
+def writeConfiguration(id, instPath):
+    log("Writing main configuration")
+    if not flags.test:
+        id.write(instPath)
+
+def writeKSConfiguration(id, instPath):
+    log("Writing autokickstart file")
+    if not flags.test:
+	fn = instPath + "/root/anaconda-ks.cfg"
+    else:
+	fn = "/tmp/anaconda-ks.cfg"
+
+    id.writeKS(fn)
+
+def copyAnacondaLogs(instPath):
+    log("Copying anaconda logs")
+    for (fn, dest) in (("/tmp/anaconda.log", "anaconda.log"),
+                       ("/tmp/syslog", "anaconda.syslog"),
+                       ("/tmp/ramfs/X.log", "anaconda.xlog")):
+        if os.access(fn, os.R_OK):
+            try:
+                iutil.copyFile(fn, "%s/var/log/%s" %(instPath, dest))
+                os.chmod("%s/var/log/%s" %(instPath, dest), 0600)
+            except:
+                pass
+
+def writeXConfiguration(id, instPath):
+    testmode = flags.test
+
+# comment out to test
+    if testmode:
+        return
+# end code to comment to test 
+# uncomment to test writing X config in test mode
+#    try:
+#	os.mkdir("/tmp/etc")
+#    except:
+#	pass
+#    try:
+#	os.mkdir("/tmp/etc/X11")
+#    except:
+#	pass
+#    instPath = '/'
+# end code for test writing
+
+    if id.xsetup.skipx:
+        return
+
+    xserver = id.videocard.primaryCard().getXServer()
+    if not xserver:
+	return
+
+    log("Writing X configuration")
+    if not testmode:
+        fn = instPath
+
+        if os.access (instPath + "/etc/X11/X", os.R_OK):
+            os.rename (instPath + "/etc/X11/X",
+                       instPath + "/etc/X11/X.rpmsave")
+
+        try:
+            os.unlink (instPath + "/etc/X11/X")
+        except OSError:
+            pass
+            
+        os.symlink ("../../usr/X11R6/bin/" + xserver,
+			    instPath + "/etc/X11/X")
+    else:
+        fn = "/tmp/"
+
+    id.xsetup.write(fn+"/etc/X11", id.mouse, id.keyboard)
+    id.desktop.write(instPath)
+
+def readPackages(intf, method, id):
+    if id.grpset:
+        grpset = id.grpset
+        hdrlist = id.grpset.hdrlist
+        doselect = 0
+    else:
+        grpset = None
+        hdrlist = None
+        doselect = 1
+        
+    while hdrlist is None:
+	w = intf.waitWindow(_("Reading"), _("Reading package information..."))
+        try:
+            hdrlist = method.readHeaders()
+        except FileCopyException, e:
+            w.pop()
+            method.unmountCD()
+            intf.messageWindow(_("Error"),
+                               _("Unable to read header list.  This may be "
+                                 "due to a missing file or bad media.  "
+                                 "Press <return> to try again."))
+            continue
+
+        w.pop()
+
+    while grpset is None:
+        try:
+            grpset = method.readComps(hdrlist)
+        except FileCopyException, e:
+            method.unmountCD()            
+            intf.messageWindow(_("Error"),
+                               _("Unable to read comps file.  This may be "
+                                 "due to a missing file or bad media.  "
+                                 "Press <return> to try again."))
+            continue
+
+    # people make bad tree copies all the time.  let's just mandate that
+    # the Core group has to exist in the comps file else we complain
+    if not grpset.groups.has_key("core"):
+        intf.messageWindow(_("Error"),
+                           _("The comps file in your installation tree is "
+                             "missing critical groups.  Please ensure that "
+                             "your install tree has been correctly "
+                             "generated."),
+                           type="custom", custom_icon="error",
+                           custom_buttons=[_("_Exit")])
+        sys.exit(0)
+        
+
+    # this is a crappy hack, but I don't want bug reports from these people
+    if (iutil.getArch() == "i386") and (not grpset.hdrlist.has_key("kernel")):
+        intf.messageWindow(_("Error"),
+                           _("You are trying to install on a machine "
+                             "which isn't supported by this release of "
+                             "%s.") %(productName,),
+                           type="custom", custom_icon="error",
+                           custom_buttons=[_("_Exit")])
+        sys.exit(0)
+        
+    id.grpset = grpset
+
+    if doselect:
+        id.instClass.setGroupSelection(grpset, intf)
+        id.instClass.setPackageSelection(hdrlist, intf)
+
+def handleX11Packages(dir, intf, disp, id, instPath):
+
+    if dir == DISPATCH_BACK:
+        return
+        
+    # skip X setup if it is not being installed
+    #
+    # uncomment this block if you want X configuration to be presented
+    #
+# START BLOCK
+#     if (not id.grpset.hdrlist.has_key('XFree86') or
+#         not id.grpset.hdrlist['XFree86'].isSelected()):
+#         disp.skipStep("videocard")
+#         disp.skipStep("monitor")
+#         disp.skipStep("xcustom")
+#         disp.skipStep("writexconfig")
+#         id.xsetup.skipx = 1
+#     elif disp.stepInSkipList("videocard"):
+#         # if X is being installed, but videocard step skipped
+#         # need to turn it back on
+#         disp.skipStep("videocard", skip=0)
+#         disp.skipStep("monitor", skip=0)
+#         disp.skipStep("xcustom", skip=0)
+#         disp.skipStep("writexconfig", skip=0)
+#         id.xsetup.skipx = 0
+# END BLOCK
+
+    # set default runlevel based on packages
+    gnomeSelected = (id.grpset.hdrlist.has_key('gnome-session')
+                     and id.grpset.hdrlist['gnome-session'].isSelected())
+    gdmSelected = (id.grpset.hdrlist.has_key('gdm')
+                     and id.grpset.hdrlist['gdm'].isSelected())
+    kdeSelected = (id.grpset.hdrlist.has_key('kdebase')
+                   and id.grpset.hdrlist['kdebase'].isSelected())
+    xinstalled = ((id.grpset.hdrlist.has_key('xorg-x11')
+                   and id.grpset.hdrlist['xorg-x11'].isSelected()) or
+                  (id.grpset.hdrlist.has_key('XFree86')
+                   and id.grpset.hdrlist['XFree86'].isSelected()))
+
+    if gnomeSelected:
+        id.desktop.setDefaultDesktop("GNOME")
+    elif kdeSelected:
+        id.desktop.setDefaultDesktop("KDE")
+
+    if (gdmSelected or kdeSelected) and (xinstalled) and (not flags.serial) and (not flags.virtpconsole):
+        id.desktop.setDefaultRunLevel(5)
+    else:
+        id.desktop.setDefaultRunLevel(3)        
+
+# verifies that monitor is not Unprobed, and if so we can skip monitor question
+def checkMonitorOK(monitor, dispatch):
+    rc = 0
+    if monitor is not None:
+	if monitor.getMonitorID() != "Unprobed Monitor":
+	    rc = 1
+
+    dispatch.skipStep("monitor", skip=rc)
+
+# sets a reasonable default for X settings.
+def setSaneXSettings(xsetup):
+    if xsetup is not None and xsetup.xhwstate is not None:
+	if not xsetup.imposed_sane_default:
+	    # XXX HACK see if we have a user specified LCD display
+	    import re
+	    
+	    regx = re.compile("LCD Panel .*x.*")
+	    monid = xsetup.xhwstate.monitor.getMonitorID()
+	    lcdres = None
+	    if regx.match(monid):
+		for testres in ["640x480", "800x600", "1024x480", "1024x768",
+				"1280x960", "1280x1024", "1400x1050",
+				"1600x1200"]:
+		    if string.find(monid, testres) != -1:
+			lcdres = testres
+			break
+		
+	    if lcdres is not None:
+		xsetup.xhwstate.set_resolution(lcdres)
+	    else:
+		xsetup.xhwstate.choose_sane_default()
+		xsetup.imposed_sane_default = 1
+	    
+def getAnacondaTS(instPath = None):
+    if instPath:
+        ts = rpm.TransactionSet(instPath)
+    else:
+        ts = rpm.TransactionSet()
+    ts.setVSFlags(~(rpm.RPMVSF_NORSA|rpm.RPMVSF_NODSA))
+    ts.setFlags(rpm.RPMTRANS_FLAG_ANACONDA)
+
+    # set color if needed.  FIXME: why isn't this the default :/
+    if (rhpl.arch.canonArch.startswith("ppc64") or
+        rhpl.arch.canonArch in ("s390x", "sparc64", "x86_64", "ia64")):
+        ts.setColor(3)
+
+    return ts
+
+def checkDependencies(dir, intf, disp, id, instPath):
+    if dir == DISPATCH_BACK:
+	return
+
+    win = intf.waitWindow(_("Dependency Check"),
+      _("Checking dependencies in packages selected for installation..."))
+
+    # FIXME: we really don't need to build up a ts more than once
+    # granted, this is better than before still
+    if id.getUpgrade():
+        ts = getAnacondaTS(instPath)
+        how = "u"
+    else:
+        ts = getAnacondaTS()        
+        how = "i"
+
+    # set the rpm log file to /dev/null so that we don't segfault
+    f = open("/dev/null", "w+")
+    rpm.setLogFile(f)
+    ts.scriptFd = f.fileno()
+    
+    for p in id.grpset.hdrlist.pkgs.values():
+        if p.isSelected():
+            ts.addInstall(p.hdr, p.hdr, how)
+    depcheck = DependencyChecker(id.grpset, how)
+    id.dependencies = ts.check(depcheck.callback)
+
+    win.pop()
+
+    if depcheck.added and id.handleDeps == CHECK_DEPS:
+	disp.skipStep("dependencies", skip = 0)
+        log("had unresolved dependencies, resolved.")
+	disp.skipStep("dependencies")
+    else:
+	disp.skipStep("dependencies")
+
+    f.close()
+
+    return
+    # FIXME: I BROKE IT
+    # this is kind of hackish, but makes kickstart happy
+    if id.handleDeps == CHECK_DEPS:
+        pass
+    elif id.handleDeps == IGNORE_DEPS:
+        id.comps.selectDepCause(id.dependencies)
+        id.comps.unselectDeps(id.dependencies)
+    elif id.handleDeps == RESOLVE_DEPS:
+        id.comps.selectDepCause(id.dependencies)        
+        id.comps.selectDeps(id.dependencies)
+
+class InstallCallback:
+    def packageDownloadCB(self, state,  amount):
+	self.progress.setPackageStatus(state, amount)
+    
+    def cb(self, what, amount, total, h, (param)):
+	# first time here means we should pop the window telling
+	# user to wait until we get here
+	if not self.beenCalled:
+	    self.beenCalled = 1
+	    self.initWindow.pop()
+
+	if (what == rpm.RPMCALLBACK_TRANS_START):
+	    # step 6 is the bulk of the transaction set
+	    # processing time
+	    if amount == 6:
+		self.progressWindow = \
+		   self.progressWindowClass (_("Processing"),
+					     _("Preparing to install..."),
+					     total)
+                try:
+                    self.incr = total / 10
+                except:
+                    pass
+	if (what == rpm.RPMCALLBACK_TRANS_PROGRESS):
+            if self.progressWindow and amount > self.lastprogress + self.incr:
+		self.progressWindow.set (amount)
+                self.lastprogress = amount
+		
+	if (what == rpm.RPMCALLBACK_TRANS_STOP and self.progressWindow):
+	    self.progressWindow.pop ()
+
+	if (what == rpm.RPMCALLBACK_INST_OPEN_FILE):
+	    # We don't want to start the timer until we get to the first
+	    # file.
+	    self.pkgTimer.start()
+
+	    self.progress.setPackage(h)
+	    self.progress.setPackageScale(0, 1)
+	    self.instLog.write (self.modeText % (h[rpm.RPMTAG_NAME],
+                                                 h[rpm.RPMTAG_VERSION],
+                                                 h[rpm.RPMTAG_RELEASE],
+                                                 h[rpm.RPMTAG_ARCH]))
+	    self.instLog.flush ()
+
+	    self.rpmFD = -1
+            self.size = h[rpm.RPMTAG_SIZE]
+
+	    while self.rpmFD < 0:
+		try:
+                    fn = self.method.getPackageFilename(h, self.pkgTimer,
+			 callback=self.packageDownloadCB)
+		    self.rpmFD = os.open(fn, os.O_RDONLY)
+
+                    # Make sure this package seems valid
+                    try:
+                        hdr = self.ts.hdrFromFdno(self.rpmFD)
+                        os.lseek(self.rpmFD, 0, 0)
+                    
+                        # if we don't have a valid package, throw an error
+                        if not hdr:
+                            raise SystemError
+
+		    except:
+			try:
+			    os.close(self.rpmFD)
+			except:
+			    pass
+			self.rpmFD = -1
+			raise FileCopyException
+		except Exception, e:
+                    log("exception was %s for %s-%s-%s" %(e, h['name'],
+                                                          h['version'],
+                                                          h['release']))
+                                                          
+                    self.method.unmountCD()
+		    rc = self.messageWindow(_("Error"),
+			_("The package %s-%s-%s cannot be opened. This is due "
+                          "to a missing file or perhaps a corrupt package.  "
+                          "If you are installing from CD media this usually "
+			  "means the CD media is corrupt, or the CD drive is "
+			  "unable to read the media.\n\n"
+			  "Press <return> to try again.") % (h['name'],
+                                                             h['version'],
+                                                             h['release']),
+                                            type="custom",
+                                            custom_icon="error",
+                                            custom_buttons = [ _("Re_boot"),
+                                                               _("_Retry") ])
+                    if rc == 0:
+                        rc = self.messageWindow(_("Warning"),
+                                                _("If you reboot, your system "
+                                                  "will be left in an "
+                                                  "inconsistent state that "
+                                                  "will likely require "
+                                                  "reinstallation.  Are you "
+                                                  "sure you wish to "
+                                                  "continue?"),
+                                                type = "custom",
+                                                custom_icon="warning",
+                                                custom_buttons = [_("_Cancel"),
+                                                                  _("_Reboot")])
+                        if rc == 1:
+                            sys.exit(0)
+                        
+	    self.progress.setPackageStatus(_("Installing..."), None)
+	    self.method.unlinkFilename(fn)
+	    return self.rpmFD
+	elif (what == rpm.RPMCALLBACK_INST_PROGRESS):
+	    # RPM returns strange values sometimes
+            if amount > total:
+                amount = total
+            if not total or total == 0 or total == "0":
+                total = amount
+            self.progress.setPackageScale(amount, total)
+	elif (what == rpm.RPMCALLBACK_INST_CLOSE_FILE):
+	    os.close (self.rpmFD)
+	    self.progress.completePackage(h, self.pkgTimer)
+	    self.progress.processEvents()
+        elif ((what == rpm.RPMCALLBACK_UNPACK_ERROR) or
+              (what == rpm.RPMCALLBACK_CPIO_ERROR)):
+            # we may want to make this error more fine-grained at some
+            # point
+            pkg = "%s-%s-%s" % (h[rpm.RPMTAG_NAME],
+                                h[rpm.RPMTAG_VERSION],
+                                h[rpm.RPMTAG_RELEASE])
+            self.messageWindow(_("Error Installing Package"),
+                               _("There was an error installing %s.  This "
+                                 "can indicate media failure, lack of disk "
+                                 "space, and/or hardware problems.  This is "
+                                 "a fatal error and your install will be "
+                                 "aborted.  Please verify your media and try "
+                                 "your install again.\n\n"
+                                 "Press the OK button to reboot "
+                                 "your system.") % (pkg,))
+            sys.exit(0)
+	else:
+	    pass
+
+	self.progress.processEvents()
+
+    def __init__(self, messageWindow, progress, pkgTimer, method,
+		 progressWindowClass, instLog, modeText, ts):
+	self.messageWindow = messageWindow
+	self.progress = progress
+	self.pkgTimer = pkgTimer
+	self.method = method
+	self.progressWindowClass = progressWindowClass
+	self.progressWindow = None
+        self.lastprogress = 0
+        self.incr = 20
+	self.instLog = instLog
+	self.modeText = modeText
+	self.beenCalled = 0
+	self.initWindow = None
+        self.ts = ts
+
+def sortPackages(first, second):
+    # install packages in cd order (cd tag is 1000002)
+    one = None
+    two = None
+
+    if first[1000003] != None:
+	one = first[1000003]
+
+    if second[1000003] != None:
+	two = second[1000003]
+
+    if one == None or two == None:
+	one = 0
+	two = 0
+	if first[1000002] != None:
+	    one = first[1000002]
+
+	if second[1000002] != None:
+	    two = second[1000002]
+
+    if one < two:
+	return -1
+    elif one > two:
+	return 1
+    elif (string.lower(first[rpm.RPMTAG_NAME])
+          < string.lower(second[rpm.RPMTAG_NAME])):
+	return -1
+    elif (string.lower(first[rpm.RPMTAG_NAME])
+          > string.lower(second[rpm.RPMTAG_NAME])):
+	return 1
+
+    return 0
+
+class rpmErrorClass:
+
+    def cb(self):
+	self.f.write (rpm.errorString () + "\n")
+
+    def __init__(self, f):
+	self.f = f
+
+def doMigrateFilesystems(dir, thefsset, diskset, upgrade, instPath):
+    if dir == DISPATCH_BACK:
+        return DISPATCH_NOOP
+
+    if thefsset.haveMigratedFilesystems():
+        return DISPATCH_NOOP
+
+    thefsset.migrateFilesystems (instPath)
+
+    # if we're upgrading, we may need to do lvm device node hackery
+    if upgrade:
+        thefsset.makeLVMNodes(instPath, trylvm1 = 1)
+    
+
+def turnOnFilesystems(dir, thefsset, diskset, partitions, upgrade, instPath):
+    if dir == DISPATCH_BACK:
+        log("unmounting filesystems")
+	thefsset.umountFilesystems(instPath)
+	return
+
+    if flags.setupFilesystems:
+	if not upgrade:
+            partitions.doMetaDeletes(diskset)
+            thefsset.setActive(diskset)
+            if not thefsset.isActive():
+                diskset.savePartitions ()
+            thefsset.checkBadblocks(instPath)
+            if not thefsset.volumesCreated:
+                thefsset.createLogicalVolumes(instPath)
+            thefsset.formatSwap(instPath)
+            thefsset.turnOnSwap(instPath)
+	    thefsset.makeFilesystems (instPath)
+            thefsset.mountFilesystems (instPath)
+
+def setupTimezone(timezone, upgrade, instPath, dir):
+    # we don't need this on an upgrade or going backwards
+    if upgrade or (dir == DISPATCH_BACK):
+        return
+
+    # dont do this in test mode!
+    if flags.test:
+	return
+    
+    os.environ["TZ"] = timezone.tz
+    tzfile = "/usr/share/zoneinfo/" + timezone.tz
+    if not os.access(tzfile, os.R_OK):
+        log("unable to set timezone")
+    else:
+        try:
+            iutil.copyFile(tzfile, "/etc/localtime")
+        except OSError, (errno, msg):
+            log("Error copying timezone (from %s): %s" %(tzfile, msg))
+
+    if iutil.getArch() == "s390":
+        return
+    args = [ "/usr/sbin/hwclock", "--hctosys" ]
+    if timezone.utc:
+        args.append("-u")
+    elif timezone.arc:
+        args.append("-a")
+
+    try:
+        iutil.execWithRedirect(args[0], args, stdin = None,
+                               stdout = "/dev/tty5", stderr = "/dev/tty5")
+    except RuntimeError:
+        log("Failed to set clock")
+
+# do miscellaneous package selections based on other installation selections
+def handleMiscPackages(intf, id, dir):
+    if dir == DISPATCH_BACK:
+        return
+
+    arch = iutil.getArch ()
+
+    # this is a crappy hack, but I don't want bug reports from these people
+    if (arch == "i386") and (not id.grpset.hdrlist.has_key("kernel")):
+        intf.messageWindow(_("Error"),
+                           _("You are trying to install on a machine "
+                             "which isn't supported by this release of "
+                             "%s.") %(productName,),
+                           type="custom", custom_icon="error",
+                           custom_buttons=[_("_Exit")])
+        sys.exit(0)
+
+    # shorthand
+    upgrade = id.getUpgrade()
+
+    def select(hdrlist, name):
+        if hdrlist.has_key(name):
+            hdrlist[name].select(isManual = 1)
+            return 1
+        return 0
+
+    def selected(hdrlist, name):
+        if hdrlist.has_key(name) and hdrlist[name].isSelected():
+            return 1
+        return 0
+
+    if not upgrade:
+        foundkernel = 0
+	if isys.smpAvailable() or isys.htavailable():
+            if id.grpset.hdrlist.has_key("kernel-smp") and \
+               id.grpset.hdrlist["kernel-smp"][rpm.RPMTAG_ARCH] == \
+               id.grpset.hdrlist["kernel"][rpm.RPMTAG_ARCH]:
+                if select(id.grpset.hdrlist, 'kernel-smp'):
+                    foundkernel = 1
+                    if selected(id.grpset.hdrlist, "gcc"):
+                        select(id.grpset.hdrlist, "kernel-smp-devel")
+
+        if foundkernel == 0:
+            # we *always* need to have some sort of kernel installed
+            select(id.grpset.hdrlist, 'kernel')
+            if selected(id.grpset.hdrlist, "gcc"):
+                select(id.grpset.hdrlist, "kernel-devel")
+
+	# if NIS is configured, install ypbind and dependencies:
+	if id.auth.useNIS:
+            select(id.grpset.hdrlist, 'ypbind')
+            select(id.grpset.hdrlist, 'yp-tools')
+            select(id.grpset.hdrlist, 'portmap')
+
+	if id.auth.useLdap:
+            select(id.grpset.hdrlist, 'nss_ldap')
+            select(id.grpset.hdrlist, 'openldap')
+            select(id.grpset.hdrlist, 'perl')
+
+	if id.auth.useKrb5:
+            select(id.grpset.hdrlist, 'pam_krb5')
+            select(id.grpset.hdrlist, 'krb5-workstation')
+            select(id.grpset.hdrlist, 'krbafs')
+            select(id.grpset.hdrlist, 'krb5-libs')
+
+        if id.auth.useSamba:
+            select(id.grpset.hdrlist, 'pam_smb')
+
+        if iutil.getArch() == "i386" and id.bootloader.useGrubVal == 1:
+            select(id.grpset.hdrlist, 'grub')
+        elif iutil.getArch() == "s390":
+            select(id.grpset.hdrlist, 's390utils')
+        elif iutil.getArch() == "ppc":
+            select(id.grpset.hdrlist, 'yaboot')
+        elif iutil.getArch() == "ia64":
+            select(id.grpset.hdrlist, 'elilo')
+
+        if pcmcia.pcicType():
+            select(id.grpset.hdrlist, 'pcmcia-cs')
+
+        for entry in id.fsset.entries:
+            for pkg in entry.fsystem.getNeededPackages():
+                if select(id.grpset.hdrlist, pkg):
+                    log("Needed %s for %s" %(pkg, entry.getMountPoint()))
+
+def doPreInstall(method, id, intf, instPath, dir):
+    if dir == DISPATCH_BACK:
+        for d in ("/selinux", "/dev"):
+            try:
+                isys.umount(instPath + d, removeDir = 0)
+            except Exception, e:
+                log("unable to unmount %s: %s" %(d, e))
+        return
+
+    if flags.test:
+	return
+
+    # shorthand
+    upgrade = id.getUpgrade()
+
+    # make sure that all comps that include other comps are
+    # selected (i.e. - recurse down the selected comps and turn
+    # on the children
+    while 1:
+        try:
+            method.mergeFullHeaders(id.grpset.hdrlist)
+        except FileCopyException:
+            method.unmountCD()
+            intf.messageWindow(_("Error"),
+                               _("Unable to merge header list.  This may be "
+                                 "due to a missing file or bad media.  "
+                                 "Press <return> to try again."))
+        else:
+            break
+
+    if upgrade:
+	# An old mtab can cause confusion (esp if loop devices are
+	# in it)
+	f = open(instPath + "/etc/mtab", "w+")
+	f.close()
+
+        # we really started writing modprobe.conf out before things were
+        # all completely ready.  so now we need to nuke old modprobe.conf's
+        # if you're upgrading from a 2.4 dist so that we can get the
+        # transition right
+        if (os.path.exists(instPath + "/etc/modules.conf") and
+            os.path.exists(instPath + "/etc/modprobe.conf") and
+            not os.path.exists(instPath + "/etc/modprobe.conf.anacbak")):
+            log("renaming old modprobe.conf -> modprobe.conf.anacbak")
+            os.rename(instPath + "/etc/modprobe.conf",
+                      instPath + "/etc/modprobe.conf.anacbak")
+            
+
+    if method.systemMounted (id.fsset, instPath):
+	id.fsset.umountFilesystems(instPath)
+	return DISPATCH_BACK
+
+    for i in ( '/var', '/var/lib', '/tmp', '/dev', '/etc',
+	       '/etc/sysconfig', '/etc/sysconfig/network-scripts',
+	       '/etc/X11', '/root', '/var/tmp' ):
+	try:
+	    os.mkdir(instPath + i)
+	except os.error, (errno, msg):
+            pass
+#            log("Error making directory %s: %s" % (i, msg))
+
+
+    if flags.setupFilesystems:
+        # setup /etc/rpm/platform for the post-install environment
+        iutil.writeRpmPlatform(instPath)
+        
+	try:
+            # FIXME: making the /var/lib/rpm symlink here is a hack to
+            # workaround db->close() errors from rpm
+            iutil.mkdirChain("/var/lib")
+            for path in ("/var/tmp", "/var/lib/rpm"):
+                if os.path.exists(path) and not os.path.islink(path):
+                    iutil.rmrf(path)
+                if not os.path.islink(path):
+                    os.symlink("/mnt/sysimage/%s" %(path,), "%s" %(path,))
+                else:
+                    log("%s already exists as a symlink to %s" %(path, os.readlink(path),))
+	except Exception, e:
+	    # how this could happen isn't entirely clear; log it in case
+	    # it does and causes problems later
+	    log("error creating symlink, continuing anyway: %s" %(e,))
+
+        # SELinux hackery (#121369)
+        if flags.selinux:
+            try:
+                os.mkdir(instPath + "/selinux")
+            except Exception, e:
+                pass
+            try:
+                isys.mount("/selinux", instPath + "/selinux", "selinuxfs")
+            except Exception, e:
+                log("error mounting selinuxfs: %s" %(e,))
+
+        # we need to have a /dev during install and now that udev is
+        # handling /dev, it gets to be more fun.  so just bind mount the
+        # installer /dev
+        if not id.grpset.hdrlist.has_key("dev"):
+            log("no dev package, going to bind mount /dev")
+            isys.mount("/dev", "/mnt/sysimage/dev", bindMount = 1)
+
+    # try to copy the comps package.  if it doesn't work, don't worry about it
+    try:
+        id.compspkg = method.copyFileToTemp("%s/base/comps.rpm" % (productPath,))
+    except:
+        log("Unable to copy comps package")
+        id.compspkg = None
+
+    # write out the fstab
+    if not upgrade:
+        id.fsset.write(instPath)
+        # rootpath mode doesn't have this file around
+        if os.access("/tmp/modprobe.conf", os.R_OK):
+            iutil.copyFile("/tmp/modprobe.conf", 
+                           instPath + "/etc/modprobe.conf")
+        if os.access("/tmp/zfcp.conf", os.R_OK):
+            iutil.copyFile("/tmp/zfcp.conf", 
+                           instPath + "/etc/zfcp.conf")
+
+    # make a /etc/mtab so mkinitrd can handle certain hw (usb) correctly
+    f = open(instPath + "/etc/mtab", "w+")
+    f.write(id.fsset.mtab())
+    f.close()
+
+#    delay writing migrate adjusted fstab till later, in case
+#    rpm transaction set determines they don't have enough space to upgrade
+#    else:
+#        id.fsset.migratewrite(instPath)
+
+def doInstall(method, id, intf, instPath):
+    if flags.test:
+	return
+
+    # set up dependency white outs
+    import whiteout
+    
+    upgrade = id.getUpgrade()
+    ts = getAnacondaTS(instPath)
+
+    total = 0
+    totalSize = 0
+    totalFiles = 0
+
+    if upgrade:
+	how = "u"
+    else:
+	how = "i"
+        rpm.addMacro("__dbi_htconfig", "hash nofsync %{__dbi_other} %{__dbi_perms}")
+
+    if id.excludeDocs:
+        rpm.addMacro("_excludedocs", "1")
+
+    l = []
+
+    for p in id.grpset.hdrlist.values():
+        if p.isSelected():
+            l.append(p)
+    l.sort(sortPackages)
+
+    progress = intf.progressWindow(_("Processing"),
+                                   _("Preparing RPM transaction..."),
+                                   len(l))
+
+
+    # this is kind of a hack, but has to be done so we can have a chance
+    # with broken triggers
+    if upgrade and len(id.upgradeRemove) > 0:
+        # simple rpm callback since erasure doesn't need anything
+        def install_callback(what, bytes, total, h, user):
+            pass
+
+        for pkg in id.upgradeRemove:
+            ts.addErase(pkg)
+
+        # set the rpm log file to /dev/null to start with so we don't segfault
+        f = open("/dev/null", "w+")
+        rpm.setLogFile(f)
+        ts.scriptFd = f.fileno()
+
+        # if we hit problems, it's not like there's anything we can
+        # do about it
+        ts.run(install_callback, 0)
+
+        # new transaction set
+        ts.closeDB()
+        del ts
+        ts = getAnacondaTS(instPath)
+
+        # we don't want to try to remove things more than once (#84221)
+        id.upgradeRemove = []
+
+    i = 0
+    updcount = 0
+    updintv = len(l) / 25
+    for p in l:
+	ts.addInstall(p.hdr, p.hdr, how)
+	total = total + 1
+	totalSize = totalSize + (p[rpm.RPMTAG_SIZE] / 1024)
+	totalFiles = totalFiles + len(p[rpm.RPMTAG_BASENAMES])
+        i = i + 1
+
+	# HACK - dont overload progress bar with useless requests
+	updcount = updcount + 1
+	if updcount > updintv:
+	    progress.set(i)
+	    updcount = 0
+
+    progress.pop()
+
+    # set the rpm log file to /dev/null to start with so we don't segfault
+    f = open("/dev/null", "w+")
+    rpm.setLogFile(f)
+    ts.scriptFd = f.fileno()
+
+    depcheck = DependencyChecker(id.grpset)
+    if not id.grpset.hdrlist.preordered():
+	log ("WARNING: not all packages in hdlist had order tag")
+        # have to call ts.check before ts.order() to set up the alIndex
+        ts.check(depcheck.callback)
+        ts.order()
+    else:
+        ts.check(depcheck.callback)
+
+    f.close()
+
+    if upgrade:
+	logname = '/root/upgrade.log'
+    else:
+	logname = '/root/install.log'
+
+    instLogName = instPath + logname
+    try:
+	iutil.rmrf (instLogName)
+    except OSError:
+	pass
+
+    instLog = open(instLogName, "w+")
+
+    # dont start syslogd if we arent creating filesystems
+    if flags.setupFilesystems:
+	syslogname = "%s%s.syslog" % (instPath, logname)
+	try:
+	    iutil.rmrf (syslogname)
+	except OSError:
+	    pass
+	syslog.start (instPath, syslogname)
+    else:
+	syslogname = None
+
+    if id.compspkg is not None:
+        num = i + 1
+    else:
+        num = i
+
+    if upgrade:
+        instLog.write(_("Upgrading %s packages\n\n") % (num,))
+    else:
+        instLog.write(_("Installing %s packages\n\n") % (num,))
+
+    ts.scriptFd = instLog.fileno ()
+    rpm.setLogFile(instLog)
+    # the transaction set dup()s the file descriptor and will close the
+    # dup'd when we go out of scope
+
+    if upgrade:
+	modeText = _("Upgrading %s-%s-%s.%s.\n")
+    else:
+	modeText = _("Installing %s-%s-%s.%s.\n")
+
+    errors = rpmErrorClass(instLog)
+    pkgTimer = timer.Timer(start = 0)
+
+    id.instProgress.setSizes(total, totalSize, totalFiles)
+    id.instProgress.processEvents()
+
+    cb = InstallCallback(intf.messageWindow, id.instProgress, pkgTimer,
+			 method, intf.progressWindow, instLog, modeText,
+                         ts)
+
+    # write out migrate adjusted fstab so kernel RPM can get initrd right
+    if upgrade:
+        id.fsset.migratewrite(instPath)
+    if id.upgradeDeps:
+        instLog.write(_("\n\nThe following packages were automatically\n"
+                        "selected to be installed:"
+                        "\n"
+                        "%s"
+                        "\n\n") % (id.upgradeDeps,))
+
+    cb.initWindow = intf.waitWindow(_("Install Starting"),
+				    _("Starting install process, this may take several minutes..."))
+
+    ts.setProbFilter(~rpm.RPMPROB_FILTER_DISKSPACE)
+    problems = ts.run(cb.cb, 0)
+
+    if problems:
+        # restore old fstab if we did anything for migrating
+        if upgrade:
+            id.fsset.restoreMigratedFstab(instPath)
+
+	spaceneeded = {}
+	nodeneeded = {}
+	size = 12
+
+	for (descr, (type, mount, need)) in problems:
+            log("(%s, (%s, %s, %s))" %(descr, type, mount, need))
+            if mount and mount.startswith(instPath):
+		mount = mount[len(instPath):]
+            if not mount:
+                mount = '/'
+
+	    if type == rpm.RPMPROB_DISKSPACE:
+		if spaceneeded.has_key (mount) and spaceneeded[mount] < need:
+		    spaceneeded[mount] = need
+		else:
+		    spaceneeded[mount] = need
+	    elif type == nodeprob:
+		if nodeneeded.has_key (mount) and nodeneeded[mount] < need:
+		    nodeneeded[mount] = need
+		else:
+		    nodeneeded[mount] = need
+	    else:
+                if descr is None:
+                    descr = "no description"
+		log ("WARNING: unhandled problem returned from "
+                     "transaction set type %d (%s)",
+		     type, descr)
+
+	probs = ""
+	if spaceneeded:
+	    probs = probs + _("You don't appear to have enough disk space "
+                              "to install the packages you've selected. "
+                              "You need more space on the following "
+                              "file systems:\n\n")
+	    probs = probs + ("%-15s %s\n") % (_("Mount Point"),
+                                              _("Space Needed"))
+
+	    for (mount, need) in spaceneeded.items ():
+                log("(%s, %s)" %(mount, need))
+		if need > (1024*1024):
+		    need = (need + 1024 * 1024 - 1) / (1024 * 1024)
+		    suffix = "M"
+		else:
+		    need = (need + 1023) / 1024
+		    suffix = "k"
+
+		prob = "%-15s %d %c\n" % (mount, need, suffix)
+		probs = probs + prob
+	if nodeneeded:
+	    if probs:
+		probs = probs + '\n'
+	    probs = probs + _("You don't appear to have enough file nodes "
+                              "to install the packages you've selected. "
+                              "You need more file nodes on the following "
+                              "file systems:\n\n")
+	    probs = probs + ("%-15s %s\n") % (_("Mount Point"),
+                                              _("Nodes Needed"))
+
+	    for (mount, need) in nodeneeded.items ():
+		prob = "%-15s %d\n" % (mount, need)
+		probs = probs + prob
+
+        if len(probs) == 0:
+            probs = ("ERROR: NO!  An unexpected problem has occurred with "
+                     "your transaction set.  Please see tty3 for more "
+                     "information")
+
+	intf.messageWindow (_("Disk Space"), probs)
+
+        ts.closeDB()
+	del ts
+	instLog.close()
+
+	if syslogname:
+	    syslog.stop()
+
+	method.systemUnmounted ()
+
+	return DISPATCH_BACK
+
+    # This should close the RPM database so that you can
+    # do RPM ops in the chroot in a %post ks script
+    ts.closeDB()
+    del ts
+
+    # make sure the window gets popped (#82862)
+    if not cb.beenCalled:
+        cb.initWindow.pop()
+    
+    method.filesDone ()
+
+    # rpm environment files go bye-bye
+    for file in ["__db.001", "__db.002", "__db.003"]:
+        try:
+            os.unlink("%s/var/lib/rpm/%s" %(instPath, file))
+        except Exception, e:
+            log("failed to unlink /var/lib/rpm/%s: %s" %(file,e))
+    # FIXME: remove the /var/lib/rpm symlink that keeps us from having
+    # db->close error messages shown.  I don't really like this though :(
+    try:
+        os.unlink("/var/lib/rpm")
+    except Exception, e:
+        log("failed to unlink /var/lib/rpm: %s" %(e,))
+
+    instLog.close ()
+
+    id.instProgress = None
+
+def doPostInstall(method, id, intf, instPath):
+    if flags.test:
+	return
+
+    #if id.grpset.hdrlist.has_key("rhgb") and id.grpset.hdrlist["rhgb"].isSelected():
+        #log("rhgb installed, adding to boot loader config")
+    id.bootloader.args.append("quiet")
+
+    w = intf.progressWindow(_("Post Install"),
+                            _("Performing post install configuration..."), 6)
+
+    upgrade = id.getUpgrade()
+    arch = iutil.getArch ()
+
+    if upgrade:
+	logname = '/root/upgrade.log'
+    else:
+	logname = '/root/install.log'
+
+    instLogName = instPath + logname
+    instLog = open(instLogName, "a")
+    
+    try:
+	if not upgrade:
+	    w.set(1)
+
+	    copyExtraModules(instPath, id.grpset, id.extraModules)
+
+	    w.set(2)
+
+	    # pcmcia is supported only on i386 at the moment
+	    if arch == "i386":
+		pcmcia.createPcmciaConfig(
+			instPath + "/etc/sysconfig/pcmcia")
+
+            # we need to write out the network bits before kudzu runs
+            # to avoid getting devices in the wrong order (#102276)
+            id.network.write(instPath)
+		       
+	    w.set(3)
+
+	    # blah.  If we're on a serial mouse, and we have X, we need to
+	    # close the mouse device, then run kudzu, then open it again.
+
+	    # turn it off
+	    mousedev = None
+
+	    # XXX currently Bad Things (X async reply) happen when doing
+	    # Mouse Magic on Sparc (Mach64, specificly)
+	    # The s390 doesn't even have a mouse!
+            if os.environ.get('DISPLAY') == ':1' and arch != 'sparc':
+		try:
+                    import xmouse
+		    mousedev = xmouse.get()[0]
+		except RuntimeError:
+		    pass
+
+	    if mousedev:
+		try:
+		    os.rename (mousedev, "/dev/disablemouse")
+		except OSError:
+		    pass
+		try:
+		    xmouse.reopen()
+		except RuntimeError:
+		    pass
+
+	    if arch != "s390" and flags.setupFilesystems:
+		# we need to unmount usbdevfs before mounting it
+		usbWasMounted = iutil.isUSBDevFSMounted()
+		if usbWasMounted:
+                    isys.umount('/proc/bus/usb', removeDir = 0)
+
+		    # see if unmount suceeded, if not pretent it isnt mounted
+		    # because we're screwed anywyas if system is going to
+		    # lock up
+		    if iutil.isUSBDevFSMounted():
+			usbWasMounted = 0
+		    
+                unmountUSB = 0
+                try:
+                    isys.mount('/usbfs', instPath+'/proc/bus/usb', 'usbfs')
+                    unmountUSB = 1
+                except:
+                    log("Mount of /proc/bus/usb in chroot failed")
+                    pass
+
+                argv = [ "/usr/sbin/kudzu", "-q" ]
+                if id.grpset.hdrlist.has_key("kernel"):
+                    ver = "%s-%s" %(id.grpset.hdrlist["kernel"][rpm.RPMTAG_VERSION],
+                                    id.grpset.hdrlist["kernel"][rpm.RPMTAG_RELEASE])
+                    argv.extend(["-k", ver])
+                
+                devnull = os.open("/dev/null", os.O_RDWR)
+                iutil.execWithRedirect(argv[0], argv, root = instPath,
+                                       stdout = devnull)
+                # turn it back on            
+                if mousedev:
+                    try:
+                        os.rename ("/dev/disablemouse", mousedev)
+                    except OSError:
+                        pass
+                    try:
+                        xmouse.reopen()
+                    except RuntimeError:
+                        pass
+
+                if unmountUSB:
+                    try:
+                        isys.umount(instPath + '/proc/bus/usb', removeDir = 0)
+                    except SystemError:
+                        # if we fail to unmount, then we should just not
+                        # try to remount it.  this protects us from random
+                        # suckage
+                        usbWasMounted = 0
+
+		if usbWasMounted:
+                    isys.mount('/usbfs', '/proc/bus/usb', 'usbfs')
+
+	w.set(4)
+
+        if upgrade and id.dbpath is not None:
+            # remove the old rpmdb
+	    try:
+		iutil.rmrf (id.dbpath)
+	    except OSError:
+		pass
+
+        if upgrade:
+	    # needed for prior systems which were not xinetd based
+	    migrateXinetd(instPath, instLogName)
+
+            # needed for prior to 2.6 so that mice have some chance
+            # of working afterwards. FIXME: this is a hack
+            migrateMouseConfig(instPath, instLogName)
+
+        if id.grpset.hdrlist.has_key("rhgb") and id.grpset.hdrlist["rhgb"].isSelected():
+            log("rhgb installed, adding to boot loader config")
+            id.bootloader.args.append("rhgb quiet")
+
+        w.set(5)
+
+        # FIXME: hack to install the comps package
+        if (id.compspkg is not None and
+            os.access(id.compspkg, os.R_OK)):
+            log("found the comps package")
+            try:
+                # ugly hack
+                path = id.compspkg.split("/mnt/sysimage")[1]
+                args = ["/bin/rpm", "-Uvh", path]
+                rc = iutil.execWithRedirect(args[0], args,
+                                            stdout = "/dev/tty5",
+                                            stderr = "/dev/tty5",
+                                            root = instPath)
+                ts = rpm.TransactionSet()
+                ts.setVSFlags(~(rpm.RPMVSF_NORSA|rpm.RPMVSF_NODSA))
+                ts.closeDB()
+                fd = os.open(id.compspkg, os.O_RDONLY)
+                h = ts.hdrFromFdno(fd)
+                os.close(fd)
+                if upgrade:
+                    text = _("Upgrading %s-%s-%s.%s.\n")
+                else:
+                    text = _("Installing %s-%s-%s.%s.\n")
+                instLog.write(text % (h['name'],
+                                      h['version'],
+                                      h['release'],
+                                      h['arch']))
+                os.unlink(id.compspkg)
+                del ts
+
+            except Exception, e:
+                log("comps.rpm failed to install: %s" %(e,))
+                try:
+                    os.unlink(id.compspkg)
+                except:
+                    pass
+        else:
+            log("no comps package found")
+                
+        w.set(6)
+
+
+    finally:
+	pass
+
+    if upgrade:
+        instLog.write(_("\n\nThe following packages were available in "
+                        "this version but NOT upgraded:\n"))
+    else:
+        instLog.write(_("\n\nThe following packages were available in "
+                        "this version but NOT installed:\n"))
+        
+    lines = []
+    for p in id.grpset.hdrlist.values():
+        if not p.isSelected():
+            lines.append("%s-%s-%s.%s.rpm\n" %
+                         (p.hdr[rpm.RPMTAG_NAME],
+                          p.hdr[rpm.RPMTAG_VERSION],
+                          p.hdr[rpm.RPMTAG_RELEASE],
+                          p.hdr[rpm.RPMTAG_ARCH]))
+    lines.sort()
+    for line in lines:
+        instLog.write(line)
+    
+
+    # XXX hack - we should really write a proper lvm "config".  but for now
+    # just vgscan if they have /sbin/lvm and some appearance of volumes
+    if (os.access(instPath + "/sbin/lvm", os.X_OK) and
+        os.access(instPath + "/dev/mapper", os.X_OK) and
+        len(os.listdir("/dev/mapper")) > 1):
+        rc = iutil.execWithRedirect("/sbin/lvm",
+                                    ["lvm", "vgscan", "-v"],
+                                    stdout = "/dev/tty5",
+                                    stderr = "/dev/tty5",
+                                    root = instPath,
+                                    searchPath = 1)
+
+    # write out info on install method used
+    try:
+	if id.methodstr is not None:
+	    if os.access (instPath + "/etc/sysconfig/installinfo", os.R_OK):
+		os.rename (instPath + "/etc/sysconfig/installinfo",
+			   instPath + "/etc/sysconfig/installinfo.rpmsave")
+
+	    f = open(instPath + "/etc/sysconfig/installinfo", "w+")
+	    f.write("INSTALLMETHOD=%s\n" % (string.split(id.methodstr, ':')[0],))
+
+	    try:
+		ii = open("/tmp/isoinfo", "r")
+		il = ii.readlines()
+		ii.close()
+		for line in il:
+		    f.write(line)
+	    except:
+		pass
+	    f.close()
+	else:
+	    log("methodstr not set for some reason")
+    except:
+	log("Failed to write out installinfo")
+        
+    w.pop ()
+
+    sys.stdout.flush()
+    
+    if flags.setupFilesystems:
+	syslog.stop()
+
+# FIXME: this is a huge gross hack.  hard coded list of files
+# created by anaconda so that we can not be killed by selinux
+def setFileCons(instPath, partitions):
+    import partRequests
+    
+    if flags.selinux:
+        log("setting SELinux contexts for anaconda created files")
+
+        files = ["/etc/rpm/platform", "/etc/rpm/macros",
+                 "/etc/lilo.conf.anaconda",
+                 "/etc/mtab", "/etc/fstab", "/etc/resolv.conf",
+                 "/etc/modprobe.conf", "/etc/modprobe.conf~",
+                 "/var/log/wtmp", "/var/run/utmp",
+                 "/dev/log", "/var/lib/rpm", "/", "/etc/raidtab",
+                 "/etc/mdadm.conf"]
+
+        vgs = []
+        for entry in partitions.requests:
+            if isinstance(entry, partRequests.VolumeGroupRequestSpec):
+                vgs.append("/dev/%s" %(entry.volumeGroupName,))
+
+        # ugh, this is ugly
+        for dir in ["/var/lib/rpm", "/etc/lvm", "/dev/mapper"] + vgs:
+            def addpath(x): return dir + "/" + x
+
+            if not os.path.isdir(instPath + dir):
+                continue
+            dirfiles = os.listdir(instPath + dir)
+            files.extend(map(addpath, dirfiles))
+            files.append(dir)
+
+        # blah, to work in a chroot, we need to actually be inside so the
+        # regexes will work
+        child = os.fork()
+        if (not child):
+            os.chroot(instPath)
+            for f in files:
+                if not os.access("%s" %(f,), os.R_OK):
+                    log("%s doesn't exist" %(f,))
+                    continue
+                ret = isys.resetFileContext(f)
+                log("set fc of %s to %s" %(f, ret))
+            os._exit(0)
+
+        try:
+            os.waitpid(child, 0)
+        except OSError, (num, msg):
+            pass
+            
+
+    return
+
+# XXX: large hack lies here
+def migrateMouseConfig(instPath, instLog):
+    if not os.access (instPath + "/usr/sbin/fix-mouse-psaux", os.X_OK):
+        return
+
+    argv = [ "/usr/sbin/fix-mouse-psaux" ]
+
+    logfile = os.open (instLog, os.O_APPEND)
+    iutil.execWithRedirect(argv[0], argv, root = instPath,
+			   stdout = logfile, stderr = logfile)
+    os.close(logfile)
+
+
+def migrateXinetd(instPath, instLog):
+    if not os.access (instPath + "/usr/sbin/inetdconvert", os.X_OK):
+	return
+
+    if not os.access (instPath + "/etc/inetd.conf.rpmsave", os.R_OK):
+	return
+
+    argv = [ "/usr/sbin/inetdconvert", "--convertremaining",
+	     "--inetdfile", "/etc/inetd.conf.rpmsave" ]
+
+    logfile = os.open (instLog, os.O_APPEND)
+    iutil.execWithRedirect(argv[0], argv, root = instPath,
+			   stdout = logfile, stderr = logfile)
+    os.close(logfile)
+
+def copyExtraModules(instPath, grpset, extraModules):
+    kernelVersions = grpset.kernelVersionList()
+    foundModule = 0
+
+    try:
+        f = open("/etc/arch")
+        arch = f.readline().strip()
+        del f
+    except IOError:
+        arch = os.uname()[2]
+
+    for (path, name) in extraModules:
+        if not path:
+            path = "/modules.cgz"
+	pattern = ""
+	names = ""
+	for (n, tag) in kernelVersions:
+            if tag == "up":
+                pkg = "kernel"
+            else:
+                pkg = "kernel-%s" %(tag,)
+            arch = grpset.hdrlist[pkg][rpm.RPMTAG_ARCH]
+            # version 1 path
+            pattern = pattern + " %s/%s/%s.ko " % (n, arch, name)
+            # version 0 path
+            pattern = pattern + " %s/%s.ko " % (n, name)
+            names = names + " %s.ko" % (name,)
+	command = ("cd %s/lib/modules; gunzip < %s | "
+                   "%s/bin/cpio --quiet -iumd %s" % 
+                   (instPath, path, instPath, pattern))
+	log("running: '%s'" % (command, ))
+	os.system(command)
+
+	for (n, tag) in kernelVersions:
+            if tag == "up":
+                pkg = "kernel"
+            else:
+                pkg = "kernel-%s" %(tag,)
+            
+	    toDir = "%s/lib/modules/%s/updates" % \
+		    (instPath, n)
+	    to = "%s/%s.ko" % (toDir, name)
+
+            if (os.path.isdir("%s/lib/modules/%s" %(instPath, n)) and not
+                os.path.isdir("%s/lib/modules/%s/updates" %(instPath, n))):
+                os.mkdir("%s/lib/modules/%s/updates" %(instPath, n))
+            if not os.path.isdir(toDir):
+                continue
+
+            arch = grpset.hdrlist[pkg][rpm.RPMTAG_ARCH]
+            for p in ("%s/%s.ko" %(arch, name), "%s.ko" %(name,)):
+                fromFile = "%s/lib/modules/%s/%s" % (instPath, n, p)
+
+                if (os.access(fromFile, os.R_OK)):
+                    log("moving %s to %s" % (fromFile, to))
+                    os.rename(fromFile, to)
+                    # the file might not have been owned by root in the cgz
+                    os.chown(to, 0, 0)
+                    foundModule = 1
+                else:
+                    log("missing DD module %s (this may be okay)" % 
+                        fromFile)
+
+    if foundModule == 1:
+        for (n, tag) in kernelVersions:
+            recreateInitrd(n, instPath)
+
+
+#Recreate initrd for use when driver disks add modules
+def recreateInitrd (kernelTag, instRoot):
+    log("recreating initrd for %s" % (kernelTag,))
+    iutil.execWithRedirect("/sbin/new-kernel-pkg",
+                           [ "/sbin/new-kernel-pkg", "--mkinitrd",
+                             "--depmod", "--install", kernelTag ],
+                           stdout = None, stderr = None,
+                           searchPath = 1, root = instRoot)
+
+    # get the path to the initrd
+    initrd = '%s/%s' %(instRoot, bootloader.makeInitrd("-%s" % (kernelTag,), None))
+    # check to see if it exists, and that we can write to it
+    if not os.access(initrd, os.W_OK):
+        # no initrd file, nothing left to do
+        return
+
+    # open the initrd file, append to it
+    log("Apending bootsplash to initrd for %s" % (kernelTag,))
+    f = open(initrd, 'a')
+    iutil.execWithRedirect('/sbin/splash',
+                           ('/sbin/splash', '-s', '-f',
+            '/usr/share/bootsplash/themes/FDL/config/bootsplash-1024x768.cfg'),
+                           stdout = f.fileno(), stderr = None,
+                           searchPath = 1, root = instRoot)
+
+# XXX Deprecated.  Is this ever called anymore?
+def depmodModules(comps, instPath):
+    kernelVersions = comps.kernelVersionList()
+
+    for (version, tag) in kernelVersions:
+	iutil.execWithRedirect ("/sbin/depmod",
+				[ "/sbin/depmod", "-a", version,
+                                  "-F", "/boot/System.map-" + version ],
+				root = instPath, stderr = '/dev/null')
+
+
+def betaNagScreen(intf, dir):
+    publicBetas = { "Red Hat Linux": "Red Hat Linux Public Beta",
+                    "Red Hat Enterprise Linux": "Red Hat Enterprise Linux Public Beta",
+                    "Fedora Core": "Fedora Core" }
+
+    
+    if dir == DISPATCH_BACK:
+	return DISPATCH_NOOP
+
+    fileagainst = None
+    for (key, val) in publicBetas.items():
+        if productName.startswith(key):
+            fileagainst = val
+    if fileagainst is None:
+        fileagainst = "%s Beta" %(productName,)
+    
+    while 1:
+	rc = intf.messageWindow( _("Warning! This is pre-release software!"),
+				 _("Thank you for downloading this "
+				   "pre-release of %s.\n\n"
+				   "This is not a final "
+				   "release and is not intended for use "
+				   "on production systems.  The purpose of "
+				   "this release is to collect feedback "
+				   "from testers, and it is not suitable "
+				   "for day to day usage.\n\n"
+				   "To report feedback, please visit:\n\n"
+				   "   %s\n\n"
+				   "and file a report against '%s'.\n")
+                                   %(productName, bugzillaUrl, fileagainst),
+				   type="custom", custom_icon="warning",
+				   custom_buttons=[_("_Exit"), _("_Install anyway")])
+
+	if not rc:
+            if flags.rootpath:
+                msg =  _("The installer will now exit...")
+                buttons = [_("_Back"), _("_Exit")]
+            else:
+                msg =  _("Your system will now be rebooted...")
+                buttons = [_("_Back"), _("_Reboot")]
+	    rc = intf.messageWindow( _("Rebooting System"),
+                                     msg,
+                                     type="custom", custom_icon="warning",
+                                     custom_buttons=buttons)
+	    if rc:
+		sys.exit(0)
+	else:
+	    break
+
+# FIXME: this is a kind of poor way to do this, but it will work for now
+def selectPackageConditionals(grpset, grp):
+    xmlgrp = grpset.compsxml.groups[grp.basename]
+
+    for package in xmlgrp.pkgConditionals.keys():
+        req = xmlgrp.pkgConditionals[package]
+        if not grpset.hdrlist.has_key(package):
+            log ("Missing %s which is in a conditional" %(package,))
+            continue
+        # add to the deps in the dependencies structure for the
+        # package.  this should take care of whenever we're
+        # selected
+        grpset.hdrlist[req].addDeps([package], main = 0)
+        if grpset.hdrlist[req].isSelected():
+            grpset.hdrlist[package].select()
+            grpset.hdrlist[package].usecount += grpset.hdrlist[req].usecount - 1
+            grp.selectDeps([package], uses = grpset.hdrlist[req].usecount)
+
+# Loop over all the selected groups and make sure all the conditionals are
+# met.
+def fixupConditionals(grpset):
+    for grp in grpset.groups:
+        if grpset.groups[grp].isSelected():
+            selectPackageConditionals(grpset, grpset.groups[grp])
+
+def selectLanguageSupportGroups(grpset, instLanguage):
+    if not grpset.groups.has_key("language-support"):
+        return
+
+    langs = instLanguage.getSupported()
+    for l in language.expandLangs (instLanguage.getDefault()):
+        langs.append(l)
+
+    grp = grpset.groups["language-support"]
+    for (pid, pdict) in grp.packages.items():
+        if pdict['meta'] != 1:
+            continue
+        if not grpset.groups.has_key(pid):
+            continue
+        group = grpset.groups[pid]
+
+        if group.langonly is not None and group.langonly in langs:
+            grp.selectPackage(pid)
+            grp.usecount = grp.usecount + 1
+            selectPackageConditionals(grpset, group)
+
+    if grp.usecount > 0:
+        grpset.groups["language-support"].select()
diff -Naur anaconda-10.2.1.5.orig/product.py~ anaconda-10.2.1.5/product.py~
--- anaconda-10.2.1.5.orig/product.py~	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-10.2.1.5/product.py~	2005-09-16 21:49:40.000000000 -0400
@@ -0,0 +1,44 @@
+#
+# product.py: product identification string
+#
+# Copyright 2003 Red Hat, Inc.
+#
+# This software may be freely redistributed under the terms of the GNU
+# library public license.
+#
+# You should have received a copy of the GNU Library Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+import os
+
+if os.access("/tmp/product/.buildstamp", os.R_OK):
+    path = "/tmp/product/.buildstamp"
+elif os.access("/.buildstamp", os.R_OK):
+    path = "/.buildstamp"
+else:
+    path = None
+    
+
+productName = "anaconda"
+productVersion = "bluesky"
+productPath = "Foresight"
+bugUrl = "http://bugs.foresightlinux.com"    
+
+if path is not None:
+    f = open(path, "r")
+    lines = f.readlines()
+    if len(lines) >= 3:
+        productName = lines[1][:-1]
+        productVersion = lines[2][:-1]
+    if len(lines) >= 4:
+	productPath = lines[3][:-1]
+    if len(lines) >= 5:
+        bugUrl = lines[4][:-1]
+
+# XXX hardcoded
+if 1 or productPath.lower().startswith("rpath"):
+    productPackagePath=productPath + "/changesets"
+else:
+    productPackagePath=productPath + "/RPMS"
+
diff -Naur anaconda-10.2.1.5.orig/scripts/mk-images anaconda-10.2.1.5/scripts/mk-images
--- anaconda-10.2.1.5.orig/scripts/mk-images	2005-09-09 15:04:26.000000000 -0400
+++ anaconda-10.2.1.5/scripts/mk-images	2005-09-16 21:54:07.000000000 -0400
@@ -629,7 +629,8 @@
     if [ $CONARY -eq 1 ]; then
         # XXX hard code for now
 	cat > $MBD_DIR/etc/conaryrc <<EOF
-installLabelPath conary.rpath.com@rpl:devel contrib.rpath.com@rpl:devel
+autoResolve     True
+installLabelPath foresight.rpath.org@fl:desktop conary.rpath.com@rpl:devel contrib.rpath.com@rpl:devel
 pinTroves kernel.*
 EOF
     fi
diff -Naur anaconda-10.2.1.5.orig/scripts/upd-instroot anaconda-10.2.1.5/scripts/upd-instroot
--- anaconda-10.2.1.5.orig/scripts/upd-instroot	2005-09-09 13:51:45.000000000 -0400
+++ anaconda-10.2.1.5/scripts/upd-instroot	2005-09-16 21:52:07.000000000 -0400
@@ -202,7 +202,7 @@
   	        gcc parted pyparted sed busybox:anaconda booty hdparm
   	        lvm2 rhpl libxml2 glib elfutils sqlite bogl krb5
   	        jfsutils conary pycrypto gmp urlgrabber db openssl pyxf86config
-  	        device-mapper pcmcia-cs mdadm"
+  	        device-mapper pcmcia-cs mdadm distro-release"
 
 # xpm is missing
 
diff -Naur anaconda-10.2.1.5.orig/scripts/upd-instroot~ anaconda-10.2.1.5/scripts/upd-instroot~
--- anaconda-10.2.1.5.orig/scripts/upd-instroot~	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-10.2.1.5/scripts/upd-instroot~	2005-09-16 21:49:40.000000000 -0400
@@ -0,0 +1,1361 @@
+#!/bin/bash
+
+ORIGDIR=`pwd`
+COMPONENT=""
+DEBUG=""
+
+if [ "$1" == "--debug" ]; then
+    DEBUG="--debug"
+    shift
+fi
+
+if [ "$1" == "--conary" ]; then
+    CONARY=1
+    shift
+else
+    CONARY=0
+fi
+
+if [ "$1" == "--install-label" ]; then
+    CONARYCFG="installLabelPath $2"
+    shift; shift
+fi
+
+if [ "$1" == "--arch" ]; then
+    ARCH=$2
+    shift; shift
+fi
+
+if [ "$1" == "--comp" ]; then
+    COMPONENT=$2
+    shift; shift
+fi
+
+if [ -z "$1" ]; then
+	echo "upd-instroot: updates instimage from a Red Hat RPMS directory or Conary repository"
+	echo "usage:        $0 --comp <comp> <packagedir> [templatedir] [instroot]"
+	echo "              $0 --conary <changesetdir> [templatedir] [instroot]"
+	exit 1
+fi
+
+if [ ! $CONARY ] && [ ! -d $1 ]; then
+	if [ -z "$ARCH" ]; then
+		echo "ARCH must be set" >&2
+		exit 1
+	fi
+	LATEST="latest --arch $ARCH"
+fi
+
+PACKAGEDIR=$1
+
+if [ -z "$ARCH" ]; then
+    if [ ! "$CONARY" ]; then
+	ARCH=`rpm --nodigest --nosignature -qp --qf "%{ARCH}" $PACKAGEDIR/anaconda-runtime*.rpm`
+    else
+	ARCH=i386
+    fi
+fi
+
+if [ $ARCH = x86_64 -o $ARCH = s390x ]; then
+    LIBDIR=lib64
+else
+    LIBDIR=lib
+fi
+
+NEEDGR=yes
+
+prunePackageList() {
+	PACKAGEPATH=$1
+	PACKAGES="$2"
+
+	if [ -n "$LATEST" ]; then
+	    $LATEST $PACKAGEPATH $PACKAGES
+	    if [ $? != 0 ]; then
+		$LATEST $PACKAGEPATH $PACKAGES >&2
+		kill -9 $$
+	    fi
+		
+	    return
+	fi
+
+	PATTERN=""
+	PACKAGEFILES=""
+	for PKG in $PACKAGES; do
+	    PATTERN="${PATTERN:+${PATTERN}|}(^$PKG )"
+	    PACKAGEFILES="$PACKAGEFILES $(ls $PACKAGEPATH/$PKG*{$ARCH,noarch}.rpm 2>/dev/null)"
+	done
+
+	# gtk+, enough said
+	PATTERN=$(echo $PATTERN | sed 's,[\+\*],\\&,g')
+
+	PACKAGEFILES=$(ls $PACKAGEFILES | sort -u)
+
+	rpm --nodigest --nosignature --qf "%{NAME} $PACKAGEPATH/%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}.rpm\n" \
+		-qp $PACKAGEFILES  | egrep "$PATTERN"  | sed 's/.* //' 
+}
+
+rpmExpandPackageSet() {
+    RPMS=$1
+    PKGDEST=$2
+    KEEPFILES=$3
+
+    [ -d $PKGDEST ] || die "ERROR: directory missing: $PKGDEST"
+    for n in $RPMS; do 
+	[ -n "$DEBUG" ] && echo -ne "\rExpanding packages..." $(basename $n)
+	if [ "$(rpm --nosignature --nodigest -qp --qf '%{NAME}' $n)" = "tzdata" ] ; then
+	    TZDATA=$n
+	fi 
+	rpm2cpio $n | (cd $PKGDEST; cpio -E $KEEPFILES --quiet -iumd)
+	[ -n "$DEBUG" ] && echo -ne "\rExpanding packages..." "$(basename $n | sed 's/./ /g')"
+    done
+    pushd $PKGDEST/$LIBDIR >/dev/null 2>&1
+    if [ -d obsolete/linuxthreads/ ]; then
+	for x in obsolete/linuxthreads/*-* ; do 
+	    lib_base=$(basename $x | cut -d- -f1)
+	    rm -f ./$lib_base[.-]*
+	    mv -f obsolete/linuxthreads/$lib_base[.-]* .
+	done
+	rmdir obsolete/linuxthreads obsolete
+    fi
+    popd >/dev/null 2>&1
+}
+
+die () {
+    echo "$@"
+    echo "Aborting instroot creation..."
+    exit 1
+}
+
+conaryExpandPackageSet() {
+    PKGS=$1
+    PKGDEST=$2
+    KEEPFILES=$3
+
+    expanddir=`mktemp -d /tmp/conaryexpand.XXXXXXXX`
+    # copy what we've extracted thus far over
+    tar cSpf - -C $PKGDEST . | tar xSpf - -C $expanddir
+    for n in $PKGS; do 
+	[ -n "$DEBUG" ] && echo -ne "\rExpanding packages..." $n
+	# check to see if we have an extracted changeset
+	csfile=$(echo $PACKAGEDIR/$n-*.ccs)
+	if [ "$csfile" != "$PACKAGEDIR/$n-*.ccs" ]; then
+	    n="$csfile"
+	fi
+	conary --config "$CONARYCFG" --quiet --no-deps --replace-files --root $expanddir update $n || echo "Error installing $n"
+	[ -n "$DEBUG" ] && echo -ne "\rExpanding packages..." "$(basename $n | sed 's/./ /g')"
+    done
+    (cd $expanddir; tar cSpf - `cat $KEEPFILES`) | (cd $PKGDEST; tar xSpf -)
+    rm -rf $expanddir
+}
+
+if [ -z "$2" ]; then
+    DEST=/tmp/upd-instroot
+else
+    DEST=$2
+fi
+
+if [ -z "$3" ]; then
+    DESTGR=/tmp/upd-instroot-gr
+else
+    DESTGR=$3
+fi
+
+rm -rf $DEST $DESTGR
+mkdir -p $DEST
+mkdir -p $DESTGR
+
+PACKAGES="glibc glibc-common setup openssl python newt slang libselinux
+	 libsepol libtermcap zlib ash e2fsprogs util-linux raidtools popt mdadm
+	 procps rpm rpm-libs XFree86 Xconfigurator anaconda tzdata
+	 anaconda-runtime kudzu hwdata bzip2 beecrypt
+	 bzip2-libs dosfstools pciutils reiserfs-utils parted sed
+	 busybox-anaconda rpm-python booty hdparm lvm2 beecrypt device-mapper
+	 rhpl pyxf86config libxml2 libxml2-python glib2 sqlite neon
+	 elfutils-libelf bogl-bterm bogl krb5-libs convertdb1 jfsutils
+ 	 xfsprogs xfsdump dmapi libacl libattr attr acl python-urlgrabber
+         policy policycoreutils pyparted xorg-x11 selinux-policy-targeted
+	 libstdc++ expat libgcc readline ncurses"
+
+if [ $ARCH = i386 -o $ARCH = x86_64 ]; then
+    PACKAGES="$PACKAGES kernel-pcmcia-cs kernel-utils"
+fi
+
+if [ $ARCH = ia64 ]; then
+    PACKAGES="$PACKAGES elilo"
+fi
+
+if [ $ARCH = s390 -o $ARCH = s390x ]; then
+    PACKAGES="$PACKAGES s390utils binutils libgcc tcp_wrappers
+              sed net-tools xinetd openssl openssh openssh-server coreutils
+              login initscripts XFree86-xauth bash portmap pam 
+              telnet-server login mount grep modutils gawk
+              XFree86-libs strace xorg-x11-xauth xorg-x11-libs"
+fi
+
+if [ $ARCH = ppc -o $ARCH = ppc64 ]; then
+    PACKAGES="$PACKAGES kernel-pcmcia-cs pdisk yaboot hfsutils"
+fi
+
+CONARYPACKAGES="glibc tzdata setup python newt slang libtermcap libelf
+  	        termcap zlib ash e2fsprogs util-linux raidtools popt
+  	        procps anaconda kudzu hwdata bzip2 dosfstools pciutils
+  	        gcc parted pyparted sed busybox:anaconda booty hdparm
+  	        lvm2 rhpl libxml2 glib elfutils sqlite bogl krb5
+  	        jfsutils conary pycrypto gmp urlgrabber db openssl pyxf86config
+  	        device-mapper pcmcia-cs mdadm"
+
+# xpm is missing
+
+# Some packages are listed twice, but that's okay
+#
+# The packages in this list are needed for the graphical installer to run
+# 
+# Extra stuff we want for rescue mode should go in PACKAGESRESCUE
+#
+PACKAGESGR="anaconda XFree86-libs libpng XFree86-75dpi-fonts
+           XFree86-ISO8859-2-75dpi-fonts gtk2 libglade2
+           XFree86-ISO8859-9-75dpi-fonts  
+           XFree86-100dpi-fonts fonts-ISO8859-2 fonts-ISO8859-9
+           XFree86-xfs e2fsprogs coreutils glibc glibc-common
+           popt specspo util-linux rpm rpm-libs tzdata
+           procps bash cpio gpm pygtk2-libglade
+           XFree86 Xconfigurator pygtk2 gdk-pixbuf 
+           XFree86-KOI8-R XFree86-KOI8-R-75dpi-fonts pam 
+           reiserfs-utils atk pango freetype gnome-python2-canvas 
+           libgnomecanvas libart_lgpl libgcc libacl libattr libstdc++ expat
+           anaconda-images anaconda-help XFree86-base-fonts
+           ttfonts-ko taipeifonts XFree86-ISO8859-15-75dpi-fonts rhpl
+           system-config-keyboard Xft fontconfig gtk2-engines gnome-themes
+           ttfonts-ja ttfonts-zh_TW bitmap-fonts-cjk urw-fonts fonts-arabic
+           comps-extras XFree86-libs-data convertdb1 fonts-bengali
+           vnc-server libjpeg tcp_wrappers system-config-date
+           xfsprogs xfsdump dmapi attr acl policy policycoreutils
+           selinux-policy-targeted ttfonts-zh_CN redhat-artwork audit-libs
+           xorg-x11-libs xorg-x11-ISO8859-2-75dpi-fonts
+           xorg-x11-ISO8859-9-75dpi-fonts xorg-x11-100dpi-fonts
+           xorg-x11-xfs xorg-x11 xorg-x11-KOI8-R xorg-x11-KOI8-R-75dpi-fonts
+           xorg-x11-base-fonts xorg-x11-ISO8859-15-75dpi-fonts
+           fonts-xorg-ISO8859-2-75dpi fonts-xorg-ISO8859-15-75dpi
+           fonts-xorg-ISO8859-9-75dpi fonts-xorg-100dpi
+           fonts-xorg-KOI8-R fonts-xorg-KOI8-R-75dpi fonts-xorg-base
+           xorg-x11-base xorg-x11-ISO8859-15-75dpi bogl-bterm
+           xorg-x11-libs-data xorg-x11-xfs prelink redhat-logos fedora-logos
+           ttfonts-ta ttfonts-bn ttfonts-gu ttfonts-hi ttfonts-pa bogl-devel
+           fonts-japanese fonts-chinese fonts-korean fonts-indic 
+           fonts-gujarati fonts-hindi fonts-punjabi fonts-tamil synaptics
+           distro-release"
+
+CONARYPACKAGESGR="anaconda bash ncurses glibc readline libpng gtk
+                 esound audiofile libgnome e2fsprogs coreutils
+                 readline popt util-linux tzdata procps ncurses bash
+                 cpio gpm gnome-python pygtk pam atk pango freetype
+                 libgnomecanvas libart_lgpl gcc expat anaconda-images
+                 anaconda-help ttfonts-ko taipeifonts rhpl
+                 system-config-keyboard fontconfig distro-artwork
+                 ttfonts-ja ttfonts-zh_TW bitmap-fonts-cjk urw-fonts
+                 fonts-arabic fonts-bengali libjpeg tcp_wrappers
+                 system-config-date xfsprogs xfsdump dmapi attr acl
+                 xorg-x11-xfs xorg-x11 xorg-x11-fonts reiserfsprogs
+                 libglade gtk-engines bogl distro-release"
+
+#
+# stuff ONLY included for rescue mode
+#
+# these packages are combined with the PACKAGES and PACKAGESGR for big stage 2
+#
+PACKAGESRESCUE="bzip2 bzip2-libs dump
+                findutils ftp gzip iputils joe krb5-libs less man
+                modutils mtools mt-st mtr net-tools open 
+                openssh openssh-clients pciutils rsh traceroute tar"
+
+if [ $ARCH = i386 ]; then
+    PACKAGESRESCUE="$PACKAGESRESCUE"
+fi
+
+# turn off options we dont want, ie. set package list to something harmless
+if [ -z "$NEEDGR" ]; then
+    PACKAGESGR="bash"
+    PACKAGESRESCUE="bash"
+fi
+
+#
+# add bootloader for particular arch
+#
+if [ $ARCH = sparc ]; then
+    PACKAGESGR="$PACKAGESGR tilo silo"
+fi
+
+if [ $ARCH = i386 -o $ARCH = x86_64 ]; then
+    PACKAGESGR="$PACKAGESGR syslinux memtest86+" 
+    CONARYPACKAGESGR="$CONARYPACKAGESGR syslinux" 
+fi
+
+if [ $ARCH = alpha ]; then
+    PACKAGESGR="$PACKAGESGR aboot"
+fi
+
+if [ $ARCH = ia64 ]; then
+    PACKAGESGR="$PACKAGESGR elilo"
+fi
+
+if [ $ARCH = ppc ]; then
+    PACKAGESGR="$PACKAGESGR fbset yaboot ppc64-utils"
+fi
+
+#
+# KEEPFILE is all files to keep from the packages in PACKAGES
+#
+# This is what is present in http, ftp, and hard drive installs, and is
+# supposed to be a small image because these methods keep it in RAM.
+#
+# It also is the base on which the other install images build on top of,
+# so if something is needed by all images it should go here
+#
+KEEPFILE=/tmp/keepfile.$$
+
+cat > $KEEPFILE <<EOF
+boot/efi/EFI/redhat/elilo.efi
+bin/ash
+bin/fdisk*
+bin/mkfs*
+bin/sed
+etc/group
+etc/passwd
+etc/protocols
+etc/services
+etc/selinux/targeted/booleans
+etc/selinux/targeted/policy/policy.*
+etc/selinux/targeted/contexts/files/*
+etc/security/selinux/policy.*
+etc/security/selinux/file_contexts
+$LIBDIR/libc[-.]*
+$LIBDIR/libm[-.]*
+$LIBDIR/libpthread*
+$LIBDIR/librt[-.]*
+$LIBDIR/ld*.so*
+$LIBDIR/libblkid*
+$LIBDIR/libcom_err*
+$LIBDIR/libcrypt*
+$LIBDIR/libdevmapper*
+$LIBDIR/libdl*
+$LIBDIR/libe2p*
+$LIBDIR/libext2fs*
+$LIBDIR/libgcc*
+$LIBDIR/liblvm-10.so*
+$LIBDIR/libgcc_s*
+$LIBDIR/libnsl*
+$LIBDIR/libnss_dns*
+$LIBDIR/libnss_files*
+$LIBDIR/libresolv*
+$LIBDIR/libselinux*
+$LIBDIR/libsepol*
+$LIBDIR/libss*
+$LIBDIR/libtermcap*
+$LIBDIR/libhandle*
+$LIBDIR/libattr*
+$LIBDIR/libdm*
+$LIBDIR/libutil*
+$LIBDIR/libuuid*
+sbin/badblocks
+sbin/busybox*anaconda
+sbin/clock
+sbin/debugfs
+sbin/e2fsck
+sbin/e2fsadm
+sbin/e2label
+sbin/fsck.ext2
+sbin/fsck.ext3
+sbin/fsck.jfs
+sbin/fsck.xfs
+sbin/fdisk
+sbin/hdparm
+sbin/hwclock
+sbin/jfs_tune
+sbin/ldconfig
+sbin/lvm*
+sbin/mdadm
+sbin/mkdosfs
+sbin/mke2fs
+sbin/mkfs.ext2
+sbin/mkfs.ext3
+sbin/mkfs.jfs
+sbin/mkfs.xfs
+sbin/mkfs.msdos
+sbin/mkfs.vfat
+sbin/mkreiserfs
+sbin/mkraid
+sbin/mkswap
+sbin/parted
+sbin/pdisk
+sbin/probe
+sbin/resize2fs
+sbin/sfdisk
+sbin/tune2fs
+sbin/xfsdump
+sbin/xfsrestore
+sbin/xfs_repair
+usr/sbin/xfs_db
+usr/sbin/xfs_check
+usr/sbin/xfs_copy
+usr/X11R6/share/Xconfigurator/MonitorsDB
+usr/bin/python
+usr/bin/python?.?
+usr/bin/hmount
+usr/bin/humount
+usr/bin/hcopy
+usr/bin/hattrib
+usr/bin/hformat
+usr/lib/anaconda-runtime/*
+usr/lib/anaconda/*
+usr/lib/anaconda/installclasses/*
+usr/lib/anaconda/textw/*
+usr/$LIBDIR/bogl/font.bgf.gz
+usr/lib/booty/*
+usr/kerberos/$LIBDIR/libkrb5.so*
+usr/kerberos/$LIBDIR/libkrb5support.so*
+usr/kerberos/$LIBDIR/libk5crypto.so*
+usr/kerberos/$LIBDIR/libcom_err.so*
+usr/kerberos/$LIBDIR/libgssapi_krb5.so*
+usr/$LIBDIR/libkrb5.so*
+usr/$LIBDIR/libkrb5support.so*
+usr/$LIBDIR/libk5crypto.so*
+usr/$LIBDIR/libcom_err.so*
+usr/$LIBDIR/libgssapi_krb5.so*
+usr/$LIBDIR/gconv/ISO8859-1.so
+usr/$LIBDIR/gconv/gconv-modules
+usr/$LIBDIR/libbeecrypt*
+usr/$LIBDIR/libexpat*
+usr/$LIBDIR/libglib*
+usr/$LIBDIR/libgmodule*
+usr/$LIBDIR/libgobject*
+usr/$LIBDIR/libgthread*
+usr/$LIBDIR/libssl*
+usr/$LIBDIR/libcrypto*
+usr/$LIBDIR/libbz2*
+usr/$LIBDIR/libelf*
+usr/$LIBDIR/libgcc*
+usr/$LIBDIR/libncurses*
+usr/$LIBDIR/libnewt*
+usr/$LIBDIR/libparted*
+usr/$LIBDIR/libpopt*
+usr/$LIBDIR/libpython*
+usr/$LIBDIR/libneon*
+usr/$LIBDIR/libsqlite3*
+usr/$LIBDIR/librpm-*4.?.so*
+usr/$LIBDIR/librpmbuild-*4.?.so*
+usr/$LIBDIR/librpmdb*4.?.so*
+usr/$LIBDIR/librpmio*4.?.so*
+usr/$LIBDIR/libslang*
+usr/$LIBDIR/libsqlite*
+usr/$LIBDIR/libstdc++.so.6*
+usr/$LIBDIR/libxml2.so*
+usr/$LIBDIR/libz.*
+usr/$LIBDIR/libbogl.so*
+usr/$LIBDIR/libreadline*
+usr/$LIBDIR/python?.?/*
+usr/$LIBDIR/python?.?/site-packages/libxml2*
+usr/$LIBDIR/python?.?/site-packages/*kudzu*
+usr/$LIBDIR/python?.?/site-packages/rpmmodule.so
+usr/$LIBDIR/python?.?/site-packages/partedmodule.so
+usr/$LIBDIR/python?.?/site-packages/ixf86configmodule.so
+usr/$LIBDIR/python?.?/site-packages/xf86config.py
+usr/$LIBDIR/python?.?/site-packages/rhpl
+usr/lib/locale/*
+usr/lib/python?.?/site-packages/urlgrabber/*
+usr/lib/rpm/macros
+usr/lib/rpm/rpmpopt
+usr/lib/rpm/rpmrc
+usr/lib/yaboot/addnote
+usr/lib/yaboot/ofboot
+usr/lib/yaboot/yaboot
+usr/libexec/convertdb1
+usr/share/locale/*/LC_MESSAGES/anaconda.mo
+usr/share/locale/locale.alias
+usr/sbin/anaconda
+usr/sbin/ddcprobe
+usr/sbin/dmidecode
+usr/sbin/mkofboot
+usr/sbin/ofpath
+usr/sbin/ybin
+usr/sbin/load_policy
+usr/sbin/lvm
+usr/sbin/build-locale-archive
+usr/share/anaconda/locale-list
+usr/share/anaconda/anaconda.conf
+usr/share/terminfo/b/bterm
+usr/share/terminfo/l/linux
+usr/share/terminfo/v/vt100
+usr/share/terminfo/v/vt100-nav
+usr/share/hwdata/pcitable
+usr/share/hwdata/pci.ids
+usr/share/hwdata/Cards
+usr/share/hwdata/MonitorsDB
+usr/share/rhpl/extramodes
+usr/share/rhpl/vesamodes
+usr/share/zoneinfo/Africa
+usr/share/zoneinfo/America
+usr/share/zoneinfo/Antarctica
+usr/share/zoneinfo/Arctic
+usr/share/zoneinfo/Asia
+usr/share/zoneinfo/Atlantic
+usr/share/zoneinfo/Australia
+usr/share/zoneinfo/Canada
+usr/share/zoneinfo/Europe
+usr/share/zoneinfo/Indian
+usr/share/zoneinfo/Japan
+usr/share/zoneinfo/Mideast
+usr/share/zoneinfo/Pacific
+usr/share/zoneinfo/US
+EOF
+
+if [ $CONARY -eq 1 ]; then
+    cat >> $KEEPFILE <<EOF
+$LIBDIR/libdb*
+usr/$LIBDIR/libstdc++.so.5*
+usr/$LIBDIR/python?.?/site-packagesconary/*
+usr/bin/conary
+usr/bin/conary-wrapper
+etc/conary/*
+EOF
+fi
+
+if [ $ARCH = s390 -o $ARCH = s390x ]; then
+    cat >> $KEEPFILE <<EOF
+usr/share/terminfo/a/ansi
+usr/share/terminfo/d/dumb
+usr/share/terminfo/k/kterm
+usr/share/terminfo/s/screen
+usr/share/terminfo/v/vt100
+usr/share/terminfo/v/vt100-nav
+usr/share/terminfo/v/vt102
+usr/share/terminfo/x/xterm
+usr/share/terminfo/x/xterm-color
+usr/bin/strace
+usr/bin/ldd
+usr/sbin/chroot
+usr/sbin/sshd
+usr/sbin/glibc_post_upgrade
+usr/sbin/in.telnetd
+usr/sbin/xinetd
+sbin/cmsfslst
+sbin/cmsfscat
+sbin/busybox.anaconda
+sbin/ifconfig
+sbin/route
+sbin/portmap
+sbin/fdasd
+sbin/dasdfmt
+sbin/swapon
+sbin/swapoff
+sbin/mkswap
+bin/bash
+bin/dd
+bin/gawk
+bin/mount
+bin/umount
+bin/mknod
+bin/sleep
+bin/login
+bin/cat
+bin/chmod
+bin/sort
+$LIBDIR/libpam.so*
+$LIBDIR/libdl.so*
+$LIBDIR/libdl-*.so*
+usr/$LIBDIR/libz.so*
+$LIBDIR/libnsl.so*
+$LIBDIR/libnsl-*.so*
+$LIBDIR/libnss*
+$LIBDIR/libutil.so*
+$LIBDIR/libutil-*.so*
+$LIBDIR/libcrypt*
+$LIBDIR/libc.so*
+$LIBDIR/libc-*so*
+lib/ld*.so*
+$LIBDIR/ld*.so*
+$LIBDIR/libresolv.so*
+$LIBDIR/libresolv-*.so*
+$LIBDIR/libvtoc*.so*
+lib/modules/ibm/*
+etc/xinetd.conf
+etc/pam.d/sshd
+etc/pam.d/other
+etc/security/limits.conf
+etc/security/pam_env.conf
+lib/security
+$LIBDIR/security/pam_*
+usr/$LIBDIR/libwrap.so*
+usr/X11R6/$LIBDIR/libXmuu.so*
+usr/X11R6/$LIBDIR/libX11.so*
+usr/X11R6/$LIBDIR/libXext.so*
+usr/X11R6/$LIBDIR/libXxf86misc.so*
+usr/X11R6/bin/xauth
+EOF
+fi
+      
+#
+# KEEPFILEGR is all files to keep from the packages in PACKAGESGR
+#
+# This defines the files in addition to KEEPFILE that make up the install
+# images for NFS and CD/DVD based installs.  This image is not loaded into
+# memory so it can be considerably larger.
+#
+# The rescue mode of anaconda uses these files as well as those defined
+# by KEEPFILERESCUE below.  The total size of this image should be
+# under the size of the miniature CD used for the rescue CD (around 68MB).
+#
+KEEPFILEGR=/tmp/keepfilegr.$$
+cp $KEEPFILE $KEEPFILEGR
+cat >> $KEEPFILEGR <<EOF
+boot/efi/EFI/redhat/elilo.efi
+boot/memtest86*
+bin/bash
+bin/cat
+bin/chmod
+bin/cp
+bin/cpio
+bin/dd
+bin/df
+bin/du
+bin/ln
+bin/ls
+bin/mkdir
+bin/mv
+bin/ps
+bin/rm
+bin/rpm
+bin/touch
+boot/*.b
+boot/bootlx
+etc/fb.modes
+etc/gtk-2.0/gtkrc*
+etc/im_palette.pal
+etc/imrc
+etc/man.config
+etc/pango/*
+etc/fonts/*
+etc/prelink.conf
+etc/rpm/macros.prelink
+$LIBDIR/libacl*
+$LIBDIR/libattr*
+$LIBDIR/libaudit*.so*
+$LIBDIR/libgcc*
+$LIBDIR/libnss_dns*
+$LIBDIR/libpam*
+$LIBDIR/libproc*
+sbin/addRamDisk
+sbin/addSystemMap
+sbin/debugfs
+sbin/e2fsck
+sbin/e2label
+sbin/reiserfsck
+sbin/fsck
+sbin/fsck.ext2
+sbin/fsck.ext3
+sbin/fsck.jfs
+sbin/fsck.reiserfs
+sbin/parted
+sbin/silo
+sbin/tune2fs
+usr/X11R6/bin/XFree86
+usr/X11R6/bin/Xorg
+usr/X11R6/bin/setxkbmap
+usr/X11R6/bin/xsetroot
+usr/X11R6/lib/X11/XKeysymDB
+usr/X11R6/lib/X11/fonts/misc/6x13*
+usr/X11R6/lib/X11/fonts/misc/fonts*
+usr/X11R6/lib/X11/fonts/misc/cursor*
+usr/X11R6/lib/X11/fonts/misc/olcursor*
+usr/X11R6/lib/X11/fonts/Type1/l047013t*
+usr/X11R6/lib/X11/fonts/Type1/*
+usr/X11R6/lib/X11/locale/*
+usr/X11R6/lib/X11/rgb*
+usr/X11R6/lib/X11/xkb/*
+usr/X11R6/lib/X11/xserver/SecurityPolicy
+usr/X11R6/$LIBDIR/libICE*
+usr/X11R6/$LIBDIR/libSM*
+usr/X11R6/$LIBDIR/libXaw.so*
+usr/X11R6/$LIBDIR/libX11*
+usr/X11R6/$LIBDIR/libXcursor*
+usr/X11R6/$LIBDIR/libXext*
+usr/X11R6/$LIBDIR/libXfixes*
+usr/X11R6/$LIBDIR/libXft*
+usr/X11R6/$LIBDIR/libXi*
+usr/X11R6/$LIBDIR/libxkbfile*
+usr/X11R6/$LIBDIR/libXmu*
+usr/X11R6/$LIBDIR/libXpm*
+usr/X11R6/$LIBDIR/libXrandr*
+usr/X11R6/$LIBDIR/libXrender*
+usr/X11R6/$LIBDIR/libXt*
+usr/X11R6/$LIBDIR/libXxf86misc*
+usr/X11R6/$LIBDIR/modules/*
+usr/X11R6/$LIBDIR/modules/input/*
+usr/X11R6/share/Xconfigurator/pixmaps/*
+usr/bin/chattr*
+usr/bin/fc-cache
+usr/bin/gtk-query*
+usr/bin/gdk-pixbuf-query-loaders*
+usr/bin/head
+usr/bin/lsattr*
+usr/bin/maketilo
+usr/bin/mini-wm
+usr/bin/pango*
+usr/bin/syslinux
+usr/bin/mkzimage
+usr/bin/tac
+usr/bin/tail
+usr/bin/tilo
+usr/bin/uniq
+usr/bin/Xvnc
+usr/bin/vncconfig
+usr/bin/vncpasswd
+usr/bin/reduce-font
+usr/bin/bdftobogl
+usr/lib/anaconda/iw
+usr/lib/bogl/font.bdf.gz
+usr/$LIBDIR/gconv/*
+usr/$LIBDIR/gdk-pixbuf/loaders/*png*
+usr/$LIBDIR/gdk-pixbuf/loaders/*la*
+usr/$LIBDIR/gtk-2.0/*/engines/libclearlooks.so
+usr/$LIBDIR/gtk-2.0/*/loaders/*png*
+usr/$LIBDIR/gtk-2.0/*/loaders/*la*
+usr/$LIBDIR/gtk-2.0/immodules/
+usr/$LIBDIR/libImlib*
+usr/$LIBDIR/libXft*
+usr/$LIBDIR/libart*
+usr/$LIBDIR/libatk*
+usr/$LIBDIR/libaudio*
+usr/$LIBDIR/libesd*
+usr/$LIBDIR/libfontconfig*
+usr/$LIBDIR/libfreetype*
+usr/$LIBDIR/libgdk*
+usr/$LIBDIR/libglade*
+usr/$LIBDIR/libgnomecanvas*
+usr/$LIBDIR/libgnomeui*
+usr/$LIBDIR/libgpm*
+usr/$LIBDIR/libgtk*
+usr/$LIBDIR/libjpeg*
+usr/$LIBDIR/libpango*
+usr/$LIBDIR/libpng.so.3*
+usr/$LIBDIR/libpng12.so*
+usr/$LIBDIR/libstdc++.so.*
+usr/$LIBDIR/libwrap*
+usr/$LIBDIR/pango/*
+usr/$LIBDIR/python?.?/site-packages/gtk*/gtk/*
+usr/$LIBDIR/rpm/rpmpopt
+usr/lib/syslinux/*
+usr/lib/yaboot/*
+usr/sbin/chroot
+usr/sbin/ddcprobe
+usr/sbin/fbset
+usr/sbin/prelink
+usr/sbin/smartctl
+usr/share/anaconda/*
+usr/share/icons/default/*
+usr/share/icons/gnome/cursors/*
+usr/share/icons/gnome/*/stock/*
+usr/share/icons/gnome/index.theme
+usr/share/icons/Bluecurve/cursors/*
+usr/share/icons/Bluecurve/*/stock/*
+usr/share/icons/Bluecurve/index.theme
+usr/share/fonts/default/Type1/n019003l*
+usr/share/fonts/default/Type1/n019004l*
+usr/share/fonts/default/Type1/n019023l*
+usr/share/fonts/default/Type1/n019024l*
+usr/share/fonts/default/Type1/n021003l*
+usr/share/fonts/default/Type1/n021004l*
+usr/share/fonts/default/Type1/n021023l*
+usr/share/fonts/default/Type1/n021024l*
+usr/share/fonts/korean/TrueType/dotum.ttf
+usr/share/fonts/japanese/TrueType/kochi-gothic-subst.ttf
+usr/share/fonts/chinese/TrueType/gbsn00lp.ttf
+usr/share/fonts/chinese/TrueType/bsmi00lp.ttf
+usr/share/fonts/bengali/MuktiNarrow.ttf
+usr/share/fonts/arabic/KacstFarsi.ttf
+usr/share/fonts/arabic/KacstQura.ttf
+usr/share/fonts/tamil/lohit_ta.ttf
+usr/share/fonts/gujarati/lohit_gu.ttf
+usr/share/fonts/bengali/lohit_bn.ttf
+usr/share/fonts/hindi/lohit_hi.ttf
+usr/share/fonts/panjabi/lohit_pa.ttf
+usr/share/fonts/punjabi/lohit_pa.ttf
+usr/share/locale/*/LC_MESSAGES/anaconda.mo
+usr/share/locale/*/LC_MESSAGES/system-config-date.mo
+usr/share/locale/*/LC_MESSAGES/redhat-dist.mo
+usr/share/locale/*/LC_MESSAGES/system-config-keyboard.mo
+usr/share/locale/*/LC_MESSAGES/gtk20.mo
+usr/share/locale/*/LC_MESSAGES/libc.mo
+usr/share/locale/*/LC_MESSAGES/rhpl.mo
+usr/share/locale/*/LC_MESSAGES/parted.mo
+usr/share/pixmaps/comps/*.png
+usr/share/pixmaps/gnome-default-dlg.png
+usr/share/pixmaps/gnome-error.png
+usr/share/pixmaps/gnome-info.png
+usr/share/pixmaps/gnome-question.png
+usr/share/pixmaps/gnome-warning.png
+usr/share/pixmaps/no.xpm
+usr/share/pixmaps/yes.xpm
+usr/share/ppc64-utils/zImage.lds
+usr/share/system-config-keyboard/*
+usr/share/terminfo/l/linux
+usr/share/terminfo/x/xterm
+usr/share/terminfo/v/vt100
+usr/share/terminfo/v/vt100-nav
+usr/share/themes/Clearlooks/gtk-2.0/*
+usr/share/themes/Clearlooks/index.theme
+usr/share/vte/termcap/xterm
+usr/share/zoneinfo/zone.tab
+EOF
+
+# sparc needs 100dpi fonts as well, otherwise
+# things look ugly
+
+if [ $ARCH = sparc ]; then
+    cat >> $KEEPFILEGR <<-EOF
+usr/X11R6/lib/X11/fonts/100dpi/cour*
+usr/X11R6/lib/X11/fonts/100dpi/helv*
+usr/X11R6/lib/X11/fonts/100dpi/tim*
+usr/X11R6/lib/X11/fonts/100dpi/fonts*
+usr/share/fonts/ISO8859-2/100dpi/cour*
+usr/share/fonts/ISO8859-2/100dpi/helv*
+usr/share/fonts/ISO8859-2/100dpi/tim*
+usr/share/fonts/ISO8859-2/100dpi/fonts*
+EOF
+fi
+
+#
+# KEEPFILERESCUE is all files to keep from the packages in PACKAGESRESCUE
+#
+# This defines the files in addition to KEEPFILE and KEEPFILEGR that make up 
+# the install images for NFS and CD/DVD based rescue mode installs.  This 
+# image is not loaded into memory so it can be considerably larger.
+#
+# NOTE: hd, ftp, and http rescue mode use and image based on KEEPFILE since
+#       it has to be much smaller due to memory usage.
+#
+KEEPFILERESCUE=/tmp/keepfilerescue.$$
+cat > $KEEPFILERESCUE <<EOF
+bin/gunzip
+bin/gzip
+bin/mt
+bin/ping
+bin/sync
+bin/tar
+bin/zcat
+etc/joe/*
+sbin/arp
+sbin/depmod
+sbin/dump
+sbin/ifconfig
+sbin/insmod
+sbin/lsmod
+sbin/lspci
+sbin/modinfo
+sbin/modprobe
+sbin/netstat
+sbin/restore
+sbin/rrestore
+sbin/rmmod
+sbin/route
+usr/bin/bunzip2
+usr/bin/bzcat
+usr/bin/bzip2
+usr/bin/emacs
+usr/bin/find
+usr/bin/ftp
+usr/bin/jmacs
+usr/bin/joe
+usr/bin/jpico
+usr/bin/less
+usr/bin/mattrib
+usr/bin/mbadblocks
+usr/bin/mcd
+usr/bin/mcopy
+usr/bin/mdel
+usr/bin/mdeltree
+usr/bin/mdir
+usr/bin/mdu
+usr/bin/mformat
+usr/bin/minfo
+usr/bin/mlabel
+usr/bin/mmd
+usr/bin/mmount
+usr/bin/mmove
+usr/bin/mpartition
+usr/bin/mrd
+usr/bin/mread
+usr/bin/mren
+usr/bin/mshowfat
+usr/bin/mtools
+usr/bin/mtype
+usr/bin/mzip
+usr/bin/open
+usr/bin/rcp
+usr/bin/rlogin
+usr/bin/rsh
+usr/bin/scp
+usr/bin/sftp
+usr/bin/shred
+usr/bin/ssh
+usr/bin/termidx
+usr/bin/xargs
+usr/kerberos/$LIBDIR/libgssapi*
+usr/kerberos/$LIBDIR/libkrb5*
+usr/kerberos/$LIBDIR/libk5crypto*
+usr/kerberos/$LIBDIR/libcom_err*
+usr/sbin/mtr
+usr/sbin/traceroute
+EOF
+
+echo "Assembling package list..."
+if [ ! $CONARY -eq 1 ]; then
+    RPMS=$(prunePackageList $PACKAGEDIR "$PACKAGES")
+    [ -n "$DEBUG" ] && echo "RPMS are $RPMS"
+    RPMSGR=$(prunePackageList $PACKAGEDIR "$PACKAGESGR $PACKAGESRESCUE")
+    [ -n "$DEBUG" ] && echo "RPMSGR are $RPMSGR"
+fi
+
+rm -rf $DEST; mkdir -p $DEST/usr/sbin $DEST/sbin
+rm -rf $DESTGR; mkdir -p $DESTGR/usr/sbin $DESTGR/sbin $DESTGR/var/lib $DESTGR/boot
+ln -s /tmp $DESTGR/var/lib/xkb 
+
+#
+# concat KEEPFILEGR and KEEPFILERESCUE lists
+#
+cat $KEEPFILERESCUE >> $KEEPFILEGR
+
+#
+# filter paths in keepfile lists for use by cpio
+#
+if [ ! $CONARY -eq 1 ]; then
+    for file in $KEEPFILE $KEEPFILEGR; do
+	cat $file | awk '{print $1 "\n./" $1}' | sort | uniq > $file-
+	mv -f $file- $file
+    done
+else
+    for file in $KEEPFILE $KEEPFILEGR; do
+	cat $file | sort | uniq > $file-
+	mv -f $file- $file
+    done
+fi
+
+if [ $CONARY -eq 1 ]; then
+    echo "Expanding text packages..."
+    conaryExpandPackageSet "$CONARYPACKAGES" $DEST $KEEPFILE
+
+    (cd $DEST; tar cSpf - .) | (cd $DESTGR; tar xSpf -)
+    echo "Expanding graphical packages..."
+    conaryExpandPackageSet "$CONARYPACKAGESGR" $DESTGR $KEEPFILEGR
+else
+    echo "Expanding text packages..."
+    rpmExpandPackageSet "$RPMS" $DEST $KEEPFILE
+
+    (cd $DEST; tar cSpf - .) | (cd $DESTGR; tar xSpf -)
+
+    echo "Expanding graphical packages..."
+    rpmExpandPackageSet "$RPMSGR" $DESTGR $KEEPFILEGR
+
+    echo "retrieving timezones"
+    TZDIR=/tmp/glibc-timezone-$$
+    mkdir -p $TZDIR/usr/share/zoneinfo
+    rpm2cpio $TZDATA | (cd $TZDIR; cpio --quiet -iumd usr/share/zoneinfo ./usr/share/zoneinfo ./usr/share/zoneinfo/* usr/share/zoneinfo/*)
+    [ $? = 0 ] || die "ERROR: Unable to expand timezone data ($TZDATA)"
+    (cd $TZDIR; tar cSpf - $TIMEZONES) | (cd $DEST; tar xSpf -)
+    (cd $TZDIR; tar cSpf - $TIMEZONES) | (cd $DESTGR; tar xSpf -)
+fi
+
+chown -R root:root $DEST $DESTGR
+chmod -R a+rX-w $DEST $DESTGR
+if [ $ARCH = s390 -o $ARCH = s390x ]; then
+    for i in $DEST $DESTGR; do
+	mv $i/bin/sed $i/bin/sed_save
+	mv $i/bin/sort $i/bin/sort_save
+    done
+fi
+
+# change mtimes to 0 (to match what happens on the cramfs)
+for p in $DEST $DESTGR; do
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+	runroot $COMPONENT --onlyone --arch $ARCH "cd $p\; usr/lib/anaconda-runtime/fixmtime.py $DEBUG $p"
+    else
+	$p/usr/lib/anaconda-runtime/fixmtime.py $DEBUG $p
+    fi
+done
+
+# Remove locales unused during the install
+cat $DESTGR/usr/lib/anaconda/lang-table* | awk '
+{ gsub("-", "", $4);
+  print $4;
+  print gensub(/\..*$/,"","",$4);
+  print gensub(/_.*$/,"","",$4);
+  if (split ($4, a, ".") > 1) {
+    print gensub(/\..*$/,tolower("." a[2]),"",$4);
+  };
+  gsub("-", "", $7);
+  print $7;
+  print gensub(/\..*$/,"","",$7);
+  print gensub(/_.*$/,"","",$7);
+  if (split ($7, a, ".") > 1) {
+    print gensub(/\..*$/,tolower("." a[2]),"",$7);
+  };
+}
+' | LC_ALL=C sort -u > $DESTGR/locales
+for p in lib share; do (
+cd $DESTGR/usr/$p/locale && {
+ls | grep -v locale.alias | LC_ALL=C sort > $DESTGR/locales.list
+LC_ALL=C comm -13 $DESTGR/locales $DESTGR/locales.list | xargs rm -rf
+}
+); done
+rm -f $DESTGR/locales $DESTGR/locales.list
+
+# now, create a locale archive and nuke the locale dirs since 
+# that ends up taking less space
+for p in $DEST $DESTGR; do
+    echo "Building locale archive"
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+    	runroot $COMPONENT --onlyone --arch $ARCH "/usr/sbin/chroot $p /usr/sbin/build-locale-archive"
+    else
+	/usr/sbin/chroot $p /usr/sbin/build-locale-archive
+    fi
+#    mv $p/usr/lib/locale/locale-archive $p/usr/lib/locale-archive
+#    rm -rf $p/usr/lib/locale/*
+#    rm -f $p/usr/sbin/build-locale-archive
+#    mv $p/usr/lib/locale-archive $p/usr/lib/locale/locale-archive 
+done
+
+# Remove unneeded XFree86 modules
+rm -rf $DESTGR/usr/X11R6/$LIBDIR/modules/dri
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/libscanpci.a
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/libxf1bpp.a
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/fonts/libspeedo.a
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/drivers/linux/v4l_drv.o
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/extensions/libdri.a
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/extensions/libxtrap.a
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/extensions/librecord.a
+
+rm -f $DESTGR/usr/X11R6/$LIBDIR/modules/extensions/lib{GLcore,glx,pex5}*
+
+# fixup joe links
+ln -fs jpicorc $DESTGR/etc/joe/picorc
+ln -fs jpicorc $DESTGR/etc/joe/jnanorc
+ln -fs jmacsrc $DESTGR/etc/joe/emacsrc
+ln -fs jmacs $DESTGR/usr/bin/emacs
+ln -fs jpico $DESTGR/usr/bin/pico
+ln -fs jpico $DESTGR/usr/bin/nano
+
+echo "Creating nsswitch.conf"
+cat > $DEST/etc/nsswitch.conf <<EOF
+# munged nsswitch.conf with just what anaconda needs
+# created by upd-instroot
+#
+passwd:     files
+shadow:     files
+group:      files
+hosts:      files dns
+ethers:     files
+netmasks:   files
+networks:   files
+protocols:  files
+rpc:        files
+services:   files
+netgroup:   files
+automount:  files
+aliases:    files
+EOF
+
+cp $DEST/etc/nsswitch.conf $DESTGR/etc/nsswitch.conf
+
+# fixup man.config to point into /mnt/sysimage for rescue
+echo "Fixing up /etc/man.config to point into /mnt/sysimage"
+if [ -n "$NEEDGR" ]; then
+    mv $DESTGR/etc/man.config $DESTGR/etc/man.config-old
+    cat $DESTGR/etc/man.config-old | sed 's^/usr/bin^/mnt/sysimage/usr/bin^' | sed 's^/bin/cat^/mnt/sysimage/usr/bin/cat^'  > $DESTGR/etc/man.config
+    rm -f $DESTGR/etc/man.config-old
+fi
+
+echo "Creating bogl font..."
+OLDLANG=$LANG
+export LANG=en_US.UTF-8
+zcat $DESTGR/usr/lib/bogl/font.bdf.gz > $DESTGR/usr/lib/bogl/font.bdf
+(cat $DESTGR/usr/lib/anaconda-runtime/loader/unicode-linedraw-chars.txt ; for i in $(find $DESTGR/usr/share/locale -name '*.mo'); do msgunfmt $i 2>/dev/null | msgconv -t utf-8 -o - - ; done) | $DESTGR/usr/bin/reduce-font $DESTGR/usr/lib/bogl/font.bdf > $DESTGR/usr/lib/anaconda-runtime/loader/font-reduced.bdf
+$DESTGR/usr/bin/bdftobogl -b $DESTGR/usr/lib/anaconda-runtime/loader/font-reduced.bdf > $DESTGR/usr/lib/anaconda-runtime/loader/font.bgf
+rm -f $DESTGR/usr/lib/anaconda-runtime/loader/font-reduced.bdf $DESTGR/usr/lib/bogl/font.bdf $DESTGR/usr/bin/reduce-font $DESTGR/usr/bin/bdftobogl $DESTGR/usr/lib/bogl/font.bdf.gz
+gzip -9 -f $DESTGR/usr/lib/anaconda-runtime/loader/font.bgf
+export LANG=$OLDLANG
+
+echo "Running mkfontdir..."
+if [ -n "$NEEDGR" ]; then
+    /usr/X11R6/bin/mkfontdir $DESTGR/usr/X11R6/lib/X11/fonts/* 
+    rm -f $DESTGR/usr/X11R6/bin/mkfontdir
+fi
+
+echo "Getting pango modules"
+if [ -n "$NEEDGR" ]; then
+    # sick sick sick hack for pango-querymodules being -32 or -64
+    mv $DESTGR/usr/bin/pango-querymodules* $DESTGR/usr/bin/pango-querymodules
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+    	runroot $COMPONENT --onlyone --arch $ARCH "LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/pango-querymodules 2> $DESTGR/etc/pango/pango.modules"
+    else
+	LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/pango-querymodules > $DESTGR/etc/pango/pango.modules
+    fi
+    rm -f $DESTGR/usr/bin/pango-querymodules
+    # more sick hackery since it doesn't fall back to this like owen thought
+    cat > $DESTGR/etc/pango/pangorc <<EOF
+[Pango]
+ModuleFiles=/etc/pango/pango.modules
+EOF
+fi
+
+if [ $CONARY -eq 1 ]; then
+    host=`/usr/share/libtool/config.guess`
+else
+    host=`rpm --nodigest --nosignature -qp --qf "%{POSTIN}\n" $PACKAGEDIR/gtk2*.$ARCH.rpm |grep update-gdk-pixbuf |awk {'print $2;'}`
+fi
+
+case "$host" in
+  *linux) canonhost="$host-gnu"
+  ;;
+  *) canonhost=$host
+  ;;
+esac
+ 
+# autoconf uses powerpc not ppc
+HOSTTRIPLET=`echo $canonhost | sed "s/^ppc/powerpc/"`
+
+# conary does not use /etc/gtk-2.0/$host yet
+if [ $CONARY -eq 1 ]; then
+    HOSTTRIPLET=""
+    # hack in clearlooks
+    if [ ! -f "$DESTGR/etc/gtk-2.0/gtkrc" ]; then
+	mkdir -p $DESTGR/etc/gtk-2.0/
+	cat > "$DESTGR/etc/gtk-2.0/gtkrc" <<EOF
+gtk-theme-name = "Clearlooks"
+gtk-icon-theme-name = "Clearlooks"
+EOF
+    fi
+fi
+
+mkdir -p $DESTGR/etc/gtk-2.0/$HOSTTRIPLET
+
+if [ -n "$NEEDGR" ]; then
+    echo "Getting gtk2 input method modules"
+    mkdir -p $DESTGR/etc/gtk-2.0/
+
+    mv $DESTGR/usr/bin/gtk-query-immodules-2.0* $DESTGR/usr/bin/gtk-query-immodules-2.0
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+	runroot $COMPONENT --onlyone --arch $ARCH "LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/gtk-query-immodules-2.0 2> $DESTGR/etc/gtk-2.0/$HOSTTRIPLET/gtk.immodules"
+    else
+	LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/gtk-query-immodules-2.0 > $DESTGR/etc/gtk-2.0/$HOSTTRIPLET/gtk.immodules
+    fi
+    rm -f $DESTGR/usr/bin/gtk-query-immodules-2.0
+
+    echo "Getting gtk2 gdk-pixbuf loaders"
+    mv $DESTGR/usr/bin/gdk-pixbuf-query-loaders* $DESTGR/usr/bin/gdk-pixbuf-query-loaders
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+	runroot $COMPONENT --onlyone --arch $ARCH "LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/gdk-pixbuf-query-loaders 2> $DESTGR/etc/gtk-2.0/$HOSTTRIPLET/gdk-pixbuf.loaders"
+    else
+	LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/gdk-pixbuf-query-loaders > $DESTGR/etc/gtk-2.0/$HOSTTRIPLET/gdk-pixbuf.loaders
+    fi
+    rm -f $DESTGR/usr/bin/gdk-pixbuf-query-loaders
+fi
+
+rm -f $KEEPFILE $KEEPFILEGR $KEEPFILERESCUE
+
+for p in $DEST $DESTGR; do
+	echo "Scrubbing trees..." "$p"
+	cp $p/usr/lib/anaconda/raidstart-stub $p/usr/bin/raidstart
+	cp $p/usr/lib/anaconda/raidstop-stub $p/usr/bin/raidstop
+	cp $p/usr/lib/anaconda/losetup-stub $p/usr/bin/losetup
+	cp $p/usr/lib/anaconda/pump-stub $p/usr/bin/pump
+	cp $p/usr/lib/anaconda/list-harddrives-stub $p/usr/bin/list-harddrives
+	cp $p/usr/lib/anaconda/kudzu-probe-stub $p/usr/bin/kudzu-probe
+	cp $p/usr/lib/anaconda/loadkeys-stub $p/usr/bin/loadkeys
+	cp $p/usr/lib/anaconda/mknod-stub $p/usr/bin/mknod
+	cp $p/usr/lib/anaconda/rescue-startx-stub $p/usr/bin/rescue-startx
+	mv $p/usr/sbin/anaconda $p/usr/bin/anaconda
+	mv $p/usr/lib/anaconda-runtime/lib* $p/usr/$LIBDIR
+
+	# we only want the libunicode-lite stuff on the minimal image
+	if [ $p = $DESTGR ]; then
+	    rm -f $p/usr/$LIBDIR/libunicode-lite*
+	fi
+
+	find $p -type d | xargs chmod 755
+
+	if [ -f $p/bin/bash ]; then
+	    rm -f $p/bin/ash
+	    ln -s bash $p/bin/sh
+	else
+	    ln -sf busybox $p/bin/sh
+	fi
+
+	[ -d $p/bin ] || die "ERROR: directory missing: $p/bin"
+	[ -d $p/sbin ] || die "ERROR: directory missing: $p/sbin"
+	(cd $p/bin; find) | (cd $p/bin; /bin/cpio --quiet -pdmu $p/usr/bin)
+	(cd $p/sbin; find) | (cd $p/sbin; /bin/cpio --quiet -pdmu $p/usr/sbin)
+	rm -rf $p/bin
+	rm -rf $p/sbin
+
+	# copy bootloader files for sparc
+	if [ $ARCH = sparc -a $p = $DESTGR ]; then
+	    mkdir -p $p/usr/lib/anaconda-runtime/boot
+	    [ -d $p/boot ] || die "ERROR: directory missing: $p/boot"
+	    (cd $p/boot; find -name "*.b") | (cd $p/boot; /bin/cpio --quiet -pdmu $p/usr/lib/anaconda-runtime/boot)
+        fi
+
+	# copy bootloader file for alpha
+	if [ $ARCH = alpha -a $p = $DESTGR ]; then
+	    mkdir -p $p/usr/lib/anaconda-runtime/boot
+	    cp -af $p/boot/bootlx $p/usr/lib/anaconda-runtime/boot
+        fi
+	
+	# copy bootloader files for ia64
+	if [ $ARCH = ia64 -a $p = $DESTGR ]; then
+	    mkdir -p $p/usr/lib/anaconda-runtime/boot
+	    cp -af $p/boot/efi/EFI/redhat//* $p/usr/lib/anaconda-runtime/boot
+	fi    
+
+	# copy bootloader files for i386/x86_64
+	if [ $ARCH = i386 -o $ARCH = x86_64 ]; then
+	    if [ $p = $DESTGR ]; then
+		mkdir -p $p/usr/lib/anaconda-runtime/boot
+		cp -af $p/boot/memtest* $p/usr/lib/anaconda-runtime/boot
+	    fi
+	fi
+
+	rm -rf $p/boot $p/home $p/root $p/tmp
+
+	find $p -name "*.a" | grep -v "usr/X11R6/$LIBDIR/modules" | xargs rm -rf
+	find $p -name "lib*.la" |grep -v "usr/$LIBDIR/gtk-2.0" | xargs rm -rf
+	for f in newt popt rpm rpmio; do
+	    rm -f $p/usr/$LIBDIR/lib$f.so
+	done
+
+	# nuke some python stuff we don't need
+        for d in idle distutils bsddb lib-old hotshot doctest.py pydoc.py site-packages/japanese site-packages/japanese.pth ; do
+	    rm -rf $p/$d
+	done
+
+	if [ "$ARCH" != "s390" -a "$ARCH" != "s390x" ]; then
+	   (cd $p/lib && rm -f libnss_files.so.1 libnss_dns.so.1)
+	fi
+
+	if [ -d $DEST/usr/share/zoneinfo ]; then
+	    (cd $DEST/usr/share/zoneinfo; find . -type f -or -type l | 
+		grep '^./[A-Z]' | sort | sed 's/^..//' | 
+		gzip -9) > $p/usr/lib/timezones.gz
+	else
+	    echo "ERROR: unable to explode tzdata for small images"
+	fi
+
+	if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+            runroot $COMPONENT --onlyone --arch $ARCH "cd $p\; usr/lib/anaconda-runtime/scrubtree $DEBUG $p"
+	else
+	    $p/usr/lib/anaconda-runtime/scrubtree $p
+	fi
+done
+
+echo "Compressing .mo files in stage2 images..."
+if [ -d $DEST/usr/share/locale ]; then
+    for i in `find $DEST/usr/share/locale -name anaconda.mo`; do
+	gzip -9 $i
+	mv -f $i.gz $i
+    done
+fi
+
+echo "Creating fontconfig cache"
+if [ -n "$NEEDGR" ]; then
+    if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+	runroot $COMPONENT --onlyone --arch $ARCH "LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/fc-cache"
+    else
+	LD_LIBRARY_PATH=/usr/X11R6/$LIBDIR:$LD_LIBRARY_PATH /usr/sbin/chroot $DESTGR /usr/bin/fc-cache
+    fi
+    rm -f $DESTGR/usr/bin/fc-cache
+fi
+
+echo "Creating debug dir"
+for p in $DEST $DESTGR ; do
+    mkdir -p $p/usr/lib/debug
+done
+
+if [ $ARCH = "alpha" ]; then
+    rm -rf $DEST/usr/share/locale
+    rm -rf $DEST/usr/$LIBDIR/locale
+fi
+
+echo "Patching python library..."
+
+# always use passive mode for ftp installs
+cd $DEST/usr/$LIBDIR/python2.4
+patch -p0 > /dev/null <<EOF
+--- urllib.py.orig	Thu Oct 25 17:05:06 2001
++++ urllib.py	Thu Oct 25 17:05:34 2001
+@@ -453,6 +453,7 @@
+         path, attrs = splitattr(path)
+         path = unquote(path)
+         dirs = path.split('/')
++        dirs[0] = '/' + dirs[0]
+         dirs, file = dirs[:-1], dirs[-1]
+         if dirs and not dirs[0]: dirs = dirs[1:]
+         if dirs and not dirs[0]: dirs[0] = '/'
+@@ -707,6 +708,7 @@
+         self.ftp = ftplib.FTP()
+         self.ftp.connect(self.host, self.port)
+         self.ftp.login(self.user, self.passwd)
++        self.ftp.set_pasv(1)
+         for dir in self.dirs:
+             self.ftp.cwd(dir)
+EOF
+cd -
+
+echo -n -e "Removing unused python files in hdimage... "
+
+if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+    runroot $COMPONENT --onlyone --arch $ARCH "cd $DEST\; usr/lib/anaconda-runtime/pythondeps $DEST"
+else
+    $DEST/usr/lib/anaconda-runtime/pythondeps $DEST
+fi
+echo "done."
+
+for p in $DEST $DESTGR; do
+	find $p -name "*.py" | while read fn; do
+	    rm -f ${fn}o
+	    rm -f ${fn}c
+	    ln -sf /dev/null ${fn}c
+	done
+done
+
+# do some stripping of debugging symbols
+if [ -x /usr/bin/runroot -a -n "$COMPONENT" ]; then
+    runroot $COMPONENT --onlyone --arch $ARCH "\"find $DEST -type f -name '*.so' -exec strip -g '{}' ';'\""
+    runroot $COMPONENT --onlyone --arch $ARCH "\"find $DESTGR -type f -name '*.so' -exec strip -g '{}' ';'\""
+else
+    find $DEST -type f -name '*.so' |xargs strip -g
+    find $DESTGR -type f -name '*.so' |xargs strip -g
+fi
+
+# some python stuff we don't need for stage2
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/distutils/
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/lib-dynload/japanese
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/encodings/
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/compiler/
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/email/
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/curses/
+rm -f $DESTGR/usr/$LIBDIR/python?.?/site-packages/pydoc.py
+
+# this is only for the minimal second stage
+echo "Cleaning ramdisk install images..."
+rm -rf $DEST/usr/lib/anaconda-runtime
+
+if [ "$ARCH" != "s390" -a "$ARCH" != "s390x" ]; then
+   if [ $NEEDGR ]; then
+       # Xserver needs a place to put the compiled xkb maps.
+       rm -rf $DESTGR/usr/X11R6/lib/X11/xkb/compiled
+       ln -s /tmp $DESTGR/usr/X11R6/lib/X11/xkb/compiled
+   fi
+
+   if [ -n "$NEEDGR" ]; then
+    cd $ORIGDIR
+    $DESTGR/usr/lib/anaconda-runtime/checkcards.py $DESTGR/usr/share/hwdata/pcitable $DESTGR/usr/share/hwdata/Cards
+   fi
+fi
diff -Naur anaconda-10.2.1.5.orig/scripts/upd-instroot.rej anaconda-10.2.1.5/scripts/upd-instroot.rej
--- anaconda-10.2.1.5.orig/scripts/upd-instroot.rej	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-10.2.1.5/scripts/upd-instroot.rej	2005-09-16 21:49:40.000000000 -0400
@@ -0,0 +1,17 @@
+***************
+*** 197,203 ****
+    	        gcc parted pyparted sed busybox:anaconda booty hdparm
+    	        lvm2 rhpl libxml2 glib elfutils sqlite bogl krb5
+    	        jfsutils conary urlgrabber db openssl pyxf86config
+-   	        device-mapper pcmcia-cs mdadm"
+  
+  # xpm is missing
+  
+--- 197,203 ----
+    	        gcc parted pyparted sed busybox:anaconda booty hdparm
+    	        lvm2 rhpl libxml2 glib elfutils sqlite bogl krb5
+    	        jfsutils conary urlgrabber db openssl pyxf86config
++   	        device-mapper pcmcia-cs mdadm distro-release" 
+  
+  # xpm is missing
+  
