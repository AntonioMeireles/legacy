diff -ruN gnome-volume-manager-old/src/manager.c gnome-volume-manager/src/manager.c
--- gnome-volume-manager-old/src/manager.c	2004-11-18 15:05:30.129197000 +0100
+++ gnome-volume-manager/src/manager.c	2004-11-18 15:05:30.417214796 +0100
@@ -51,6 +51,7 @@
 
 static struct gvm_configuration config;
 static LibHalContext *hal_ctx;
+static DBusConnection *dbus_ctx;
 
 /** List of UDI's for volumes mounted by g-v-m that we need to apply policy to*/
 static GSList *mounted_volumes_policy_queue = NULL;
@@ -58,6 +59,9 @@
 /** List of UDI's of all volumes mounted during the lifetime of the program */
 static GSList *all_mounted_volumes = NULL;
 
+static LibHalFunctions * gvm_return_hal_functions ();
+static LibHalContext * gvm_do_hal_init (LibHalFunctions *functions);
+
 /*
  * gvm_load_config - synchronize gconf => config structure
  */
@@ -904,6 +908,58 @@
 {
 }
 
+/** Invoked by GLib in response to a D-BUS disconnect event.
+ *
+ * @param  data                 Context pointer
+ */
+static gboolean
+gvm_reconnect_to_hal (gpointer data __attribute__((__unused__)))
+{
+	static unsigned int retries = 0;
+
+	g_message ("Trying a reconnect ...");
+	hal_ctx = gvm_do_hal_init (gvm_return_hal_functions ());
+	if (hal_ctx != NULL) {
+		g_message ("Reconnected OK.");
+		retries = 0;
+		return FALSE;
+	}
+
+	/* Retry later if it failed. */
+	if (retries++ < 100)
+		return TRUE;
+
+	/* Too many retries; clean up and bail. */
+	hal_shutdown (hal_ctx);
+	gtk_main_quit ();
+	return FALSE;
+}
+
+/** Invoked by D-BUS to filter messages.
+ *
+ * @param  connection  D-BUS connection
+ * @param  message     D-BUS message
+ * @param  user_data   Context pointer
+ */
+static DBusHandlerResult
+gvm_do_filter_dbus_msg (DBusConnection *connection __attribute__((__unused__)),
+                        DBusMessage *message,
+                        void *user_data __attribute__((__unused__)))
+{
+	if (dbus_message_is_signal (message,
+	                            DBUS_INTERFACE_ORG_FREEDESKTOP_LOCAL,
+	                            "Disconnected")) {
+		g_timeout_add(500, gvm_reconnect_to_hal, NULL);
+		hal_shutdown (hal_ctx);
+		hal_ctx = NULL;
+		dbus_connection_unref (dbus_ctx);
+		dbus_ctx = NULL;
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+	else
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
 /** Invoked by libhal for integration with our mainloop. 
  *
  *  @param  ctx                 LibHal context
@@ -913,7 +969,12 @@
 hal_mainloop_integration (LibHalContext *ctx __attribute__((__unused__)),
 			  DBusConnection * dbus_connection)
 {
+	dbus_connection_set_exit_on_disconnect (dbus_connection, FALSE);
 	dbus_connection_setup_with_g_main (dbus_connection, NULL);
+
+	dbus_ctx = dbus_connection;
+	dbus_connection_add_filter (dbus_connection, gvm_do_filter_dbus_msg,
+	                            NULL, NULL);
 }
 
 /** Internal HAL initialization function
@@ -1037,7 +1098,12 @@
 	char *device_file;
 	char *udi;
 
-	dbg ("unmounting all volumes that we saw mounted in our life\n");
+  if (ctx == NULL) {
+    dbg("No hal connection! can't unmount volumes");
+    return;
+  } else {
+	  dbg ("unmounting all volumes that we saw mounted in our life\n");
+  }
 
 	for (i = all_mounted_volumes; i != NULL; i = g_slist_next (i)) {
 
@@ -1109,17 +1175,23 @@
 	gtk_main_quit ();
 }
 
+static LibHalFunctions *
+gvm_return_hal_functions ()
+{
+	static LibHalFunctions hf = { hal_mainloop_integration,
+	                              hal_device_added,
+	                              hal_device_removed,
+	                              hal_device_new_capability,
+	                              hal_device_lost_capability,
+	                              hal_property_modified,
+	                              hal_device_condition };
+	return &hf;
+}
+
 int
 main (int argc, char *argv[])
 {
 	GnomeClient *client;
-	LibHalFunctions hal_functions = { hal_mainloop_integration,
-					  hal_device_added,
-					  hal_device_removed,
-					  hal_device_new_capability,
-					  hal_device_lost_capability,
-					  hal_property_modified,
-					  hal_device_condition };
 
 	gnome_program_init (PACKAGE, VERSION, LIBGNOMEUI_MODULE,
 			    argc, argv, GNOME_PARAM_NONE);
@@ -1140,7 +1212,7 @@
 	gtk_signal_connect (GTK_OBJECT (client), "die",
 			    GTK_SIGNAL_FUNC (gvm_die), NULL);
 
-	hal_ctx = gvm_do_hal_init (&hal_functions);
+	hal_ctx = gvm_do_hal_init (gvm_return_hal_functions ());
 	if (!hal_ctx)
 		return 1;
 
