diff -ruN gnome-volume-manager-1.5.15-old/src/manager.c gnome-volume-manager-1.5.15/src/manager.c
--- gnome-volume-manager-1.5.15-old/src/manager.c	2006-05-09 14:07:25.000000000 +0200
+++ gnome-volume-manager-1.5.15/src/manager.c	2006-05-09 14:08:40.000000000 +0200
@@ -85,6 +85,14 @@
 /* Timeout for the callback to do statfs () on mounted volumes */
 static guint statfs_id = 0;
 
+struct ALSADevice {
+    const char* udi;
+    int card;
+    const char *id;
+};
+
+/** List of known ALSADevices */
+static GSList *audio_devices = NULL;
 
 typedef struct {
         gboolean notified;
@@ -2497,6 +2505,22 @@
 }
 
 static gboolean
+alsa_device_added (const char *udi, const char *capability __attribute__((__unused__)))
+{
+    if (!strcmp (libhal_device_get_property_string (hal_ctx, udi, "alsa.type",
+                    NULL), "playback")) {
+        /* Remember that this is an audio device */
+        struct ALSADevice* c = (struct ALSADevice*) g_malloc (sizeof (struct ALSADevice));
+        c->udi = g_strdup(udi);
+        c->card = libhal_device_get_property_int (hal_ctx, udi, "alsa.card", NULL);
+        c->id = libhal_device_get_property_string (hal_ctx, udi, "alsa.card_id", NULL);
+        audio_devices = g_slist_append (audio_devices, c);
+    }
+
+    return TRUE;
+}
+
+static gboolean
 printer_device_added (const char *udi, const char *capability __attribute__((__unused__)))
 {
 	if (config.autoprinter)
@@ -2510,6 +2534,7 @@
 	const char *capability;
 	DeviceAddedHandler handler;
 } devices[] = {
+ 	{ "alsa",                  alsa_device_added         },
 	{ "block",                 block_device_added        },
 	{ "camera",                camera_device_added       },
 	/*{ "input",                 input_device_added        },*/ /* we don't handle generic input devices (yet?) */
@@ -2562,6 +2587,67 @@
 	libhal_free_string_array (capabilities);
 }
 
+/* Return the default ALSA device configured in ~/.asoundrc, or NULL if it
+ * cannot be determined. The returned string has to be free'd.
+ *
+ */
+static const char*
+alsa_default_device() {
+    gint exit_status;
+    char* card = NULL;
+    char* argv[] = {"asoundconf", "get", "defaults.pcm.card", NULL};
+    int i;
+    gboolean result;
+
+    result = g_spawn_sync (NULL, argv, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL,
+            &card, NULL, &exit_status, NULL);
+    if (!result || !WIFEXITED(exit_status) || WEXITSTATUS(exit_status) || !card || !*card) {
+	dbg("alsa_default_device: asoundconf failed, returning NULL\n");
+        g_free(card);
+        return NULL;
+    }
+
+    /* strip off whitespace */
+    for (i = strlen (card)-1; i >= 0; --i) {
+	if (isspace (card[i]))
+	    card[i] = 0;
+	else
+	    break;
+    }
+
+    dbg("alsa_default_device: default card '%s'\n", card);
+    return card;
+}
+
+/** Invoked when an audio device is removed.
+  *
+  */
+static void
+gvm_delete_alsa_playback (struct ALSADevice *c)
+{
+    char cardstr[20];
+    gboolean is_default;
+
+    dbg ("removing ALSA playback card %i (%s)\n", c->card, c->id);
+    snprintf(cardstr, sizeof (cardstr), "%i", c->card);
+
+    const char* def = alsa_default_device();
+    is_default = def && (!strcmp (def, c->id) || !strcmp (def, cardstr));
+    g_free (def);
+    if (is_default) {
+	dbg ("gvm_delete_alsa_playback: Current default device has been removed, adapting ALSA configuration\n");
+        char* argv[] = {"/usr/bin/asoundconf", "reset-default-card", NULL};
+        gint exit_status;
+        if (!g_spawn_sync (NULL, argv, NULL, 0, NULL, NULL, NULL, NULL,
+                    &exit_status, NULL) || !WIFEXITED(exit_status)) {
+            warn ("Error executing asoundconf\n");
+	    return;
+        }
+        if (WEXITSTATUS(exit_status))
+            dbg ("asoundconf failed\n");
+    }
+}
+
 /** Invoked when a device is removed from the Global Device List. 
  *
  *  @param  ctx                 LibHal context
@@ -2575,6 +2661,19 @@
 	
 	dbg ("Device removed: %s\n", udi);
 	
+        /* Check whether we removed the current default audio device */
+        GSList* i = audio_devices;
+        for (; i; i = g_slist_next(i)) {
+            struct ALSADevice* d = i->data;
+            if (!strcmp(d->udi, udi)) {
+                gvm_delete_alsa_playback (d);
+                audio_devices = g_slist_delete_link (audio_devices, i);
+                g_free (d->udi);
+                g_free (d);
+                break;
+            }
+        }
+
 	if ((dialog = g_hash_table_lookup (dialogs, udi)))
 		gtk_dialog_response (dialog, GTK_RESPONSE_CANCEL);
 }
