diff -ruN gnome-volume-manager-1.3.2-old/configure.in gnome-volume-manager-1.3.2/configure.in
--- gnome-volume-manager-1.3.2-old/configure.in	2005-06-30 22:12:28.000000000 +0200
+++ gnome-volume-manager-1.3.2/configure.in	2005-07-04 17:22:41.991965136 +0200
@@ -90,7 +90,7 @@
 AC_PROG_INTLTOOL([0.27.2])
 AM_GLIB_GNU_GETTEXT
 
-PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.0 gtk+-2.0 >= 2.6.0)
+PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.0 gtk+-2.0 >= 2.6.0 libgksuui1.0 >= 1.0.0)
 AC_SUBST(GVM_CFLAGS)
 AC_SUBST(GVM_LIBS)
 
diff -ruN gnome-volume-manager-1.3.2-old/src/manager.c gnome-volume-manager-1.3.2/src/manager.c
--- gnome-volume-manager-1.3.2-old/src/manager.c	2005-07-04 17:22:12.281481000 +0200
+++ gnome-volume-manager-1.3.2/src/manager.c	2005-07-04 17:24:48.821684088 +0200
@@ -33,6 +33,8 @@
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <libhal.h>
+#include <libgksuui1.0/gksuui.h>
+#include <sys/wait.h>
 
 #include "gvm.h"
 
@@ -882,6 +884,139 @@
 	libhal_free_string (device);
 }
 
+/*
+ * gvm_device_mount_finished - called back when mount finished.
+ *
+ * This needs to close the pid, remove the FIFO (if given, that applies to
+ * encrypted devices) and display an error message if the mount failed.
+ */
+void
+gvm_device_mount_finished (GPid pid, gint status, const char* fifoname)
+{
+    g_spawn_close_pid (pid);
+
+    dbg ("gvm_device_mount_finished: mount process %i returned with %i\n", pid,
+            status);
+
+    if (fifoname)
+        unlink (fifoname);
+
+    if (!WIFEXITED(status)) {
+        warn ("pmount did not exit normally\n");
+        return;
+    }
+
+    /* if we have an encryption secret, we display an error message
+     * if the mount failed. */
+    if (WEXITSTATUS(status) && fifoname) {
+        GtkMessageDialog *dialog;
+        dialog = gtk_message_dialog_new (NULL, 0,
+                GTK_MESSAGE_ERROR,
+                GTK_BUTTONS_CLOSE,
+                _("Could not mount encrypted device. Did you supply a wrong passphrase?"));
+        gtk_widget_show (GTK_WIDGET(dialog));
+        g_signal_connect_swapped (dialog, "response",
+                G_CALLBACK (gtk_widget_destroy), dialog);
+    }
+}
+
+/*
+ * gvm_device_mount_encrypted_pwd_callback - Called from
+ * gvm_device_mount_encrypted after the password dialog finished. Use pmount
+ * to mount an encrypted given device.
+ */
+static void
+gvm_device_mount_encrypted_pwd_callback (GksuuiDialog* dialog, gint response,
+        char *udi)
+{
+    char *argv[5] = {"/usr/bin/pmount-hal", udi, "--passphrase", NULL, NULL};
+    GError *error = NULL;
+    char* fifoname = NULL;
+    FILE* fifo = NULL;
+    GPid mount_pid;
+    char* passphrase = NULL;
+
+    if (!udi) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: udi == NULL!\n");
+        return;
+    }
+    if (!dialog) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: dialog == NULL!\n");
+        return;
+    }
+
+    /* Check whether we got a passphrase */
+    if (response == GTK_RESPONSE_OK)
+        passphrase = gksuui_dialog_get_password (dialog);
+    gtk_widget_destroy (GTK_WIDGET (dialog));
+    if (!passphrase)
+        return;
+
+    /* Create a private temporary FIFO */
+    for (;;) {
+        fifoname = tmpnam(NULL);
+        if (!fifoname) {
+            warn ("gvm_device_mount_encrypted: cannot create a temporary name\n");
+            return;
+        }
+
+        int result = mkfifo (fifoname, 0700);
+        if (result == 0)
+            break;
+        if (errno != EEXIST) {
+            warn ("gvm_device_mount_encrypted: cannot create fifo: %s\n",
+                    strerror (errno));
+            return;
+        }
+    }
+    argv[3] = fifoname;
+
+    /* Call the mount process asynchronously */
+    if (!g_spawn_async (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
+                NULL, &mount_pid, &error)) {
+        warn ("gvm_device_mount_encrypted: could not execute pmount: %s\n",
+                error->message);
+        return;
+    }
+
+    /* When mounting finishes, call the clean up and error handling
+     * callback. */
+    g_child_watch_add (mount_pid, gvm_device_mount_finished, fifoname);
+
+    /* now the mount process runs, write the secret into the FIFO;
+     * this blocks until the pmount child opens the fifo */
+    fifo = fopen (fifoname, "w");
+    if (fifo)
+        fputs (passphrase, fifo);
+    else {
+        warn ("gvm_device_mount_encrypted: cannot open fifo: %s\n",
+                strerror (errno));
+        unlink (fifoname);
+    }
+    free (passphrase);
+    fclose (fifo);
+    free (udi);
+}
+
+/*
+ * gvm_device_mount_encrypted - create a passphrase dialog for an encrypted
+ * dialog and set up gvm_device_mount_encrypted_pwd_callback() as a callback.
+ *
+ * @return TRUE iff the mount was succesful
+ */
+static void
+gvm_device_mount_encrypted (const char *udi)
+{
+    GksuuiDialog *dialog = GKSUUI_DIALOG (gksuui_dialog_new());
+    gtk_window_set_title (GTK_WINDOW(dialog), _("Encrypted volume detected"));
+    gksuui_dialog_set_message (dialog,  _("A passphrase is required to decrypt this volume"));
+
+    g_signal_connect (dialog, "response", 
+            G_CALLBACK (gvm_device_mount_encrypted_pwd_callback), g_strdup (udi));
+
+    gtk_widget_show_all (GTK_WIDGET(dialog));
+}
+
 #ifndef ASSUME_SUBMOUNT
 /*
  * gvm_device_mount - mount the given device.
@@ -1165,6 +1300,14 @@
 		if (mountable) {
 			/* only mount if the block device has a sensible filesystem */
 			fsusage = libhal_device_get_property_string (ctx, udi, "volume.fsusage", &error);
+			/* check for encrypted device */
+			if (fsusage && !g_strcasecmp(fsusage, "crypto")) {
+			    dbg ("encrypted volume found on %s\n", udi);
+			    if (config.automount_drives)
+				gvm_device_mount_encrypted (udi);
+			    goto out;
+			}
+
 			if (!fsusage || strcmp (fsusage, "filesystem") != 0) {
 				dbg ("no sensible filesystem for %s\n", udi);
 				mountable = FALSE;
@@ -1528,10 +1671,11 @@
 		if (!libhal_device_property_exists (ctx, udi, "volume.fsusage", NULL))
 			continue;
 		prop = libhal_device_get_property_string (ctx, udi, "volume.fsusage", NULL);
-		if (!prop || strcmp (prop, "filesystem") != 0) {
+		if (!prop || (strcmp (prop, "filesystem") != 0 && strcmp(prop, "crypto") != 0)) {
 			libhal_free_string (prop);
 			continue;
 		}
+		gboolean is_encrypted = (prop[0] == 'c');
 		libhal_free_string (prop);
  
 		/* Check if configured policy disables mounting */
@@ -1551,7 +1695,10 @@
 		/* mount the device */
 		if (!(dev = libhal_device_get_property_string (ctx, udi, "block.device", &error))) {
 			dbg ("mount_all: mounting %s\n", dev);
-			gvm_device_mount (udi, dev, NULL);
+			if (is_encrypted)
+			    gvm_device_mount_encrypted (udi);
+			else
+			    gvm_device_mount (udi, dev, NULL);
 			libhal_free_string (dev);
 		} else {
 			warn ("mount_all: no device for udi=%s: %s", udi, error.message);
