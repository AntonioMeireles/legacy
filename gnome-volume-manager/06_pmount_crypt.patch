diff -ruN gnome-volume-manager-1.3.1-old/configure.in gnome-volume-manager-1.3.1/configure.in
--- gnome-volume-manager-1.3.1-old/configure.in	2005-03-31 18:27:06.000000000 +0200
+++ gnome-volume-manager-1.3.1/configure.in	2005-06-22 15:20:29.000000000 +0200
@@ -82,7 +82,7 @@
 AC_PROG_INTLTOOL([0.27.2])
 AM_GLIB_GNU_GETTEXT
 
-PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.0 gtk+-2.0 >= 2.6.0)
+PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.0 gtk+-2.0 >= 2.6.0 libgksuui1.0 >= 1.0.0)
 AC_SUBST(GVM_CFLAGS)
 AC_SUBST(GVM_LIBS)
 
diff -ruN gnome-volume-manager-1.3.1-old/src/manager.c gnome-volume-manager-1.3.1/src/manager.c
--- gnome-volume-manager-1.3.1-old/src/manager.c	2005-06-22 15:20:29.000000000 +0200
+++ gnome-volume-manager-1.3.1/src/manager.c	2005-06-22 15:32:46.000000000 +0200
@@ -22,6 +22,8 @@
 #include <dbus/dbus-glib.h>
 #include <libhal.h>
 #include <signal.h>
+#include <libgksuui1.0/gksuui.h>
+#include <sys/wait.h>
 
 #include "gvm.h"
 
@@ -486,6 +488,139 @@
 }
 
 /*
+ * gvm_device_mount_finished - called back when mount finished.
+ *
+ * This needs to close the pid, remove the FIFO (if given, that applies to
+ * encrypted devices) and display an error message if the mount failed.
+ */
+void
+gvm_device_mount_finished (GPid pid, gint status, const char* fifoname)
+{
+    g_spawn_close_pid (pid);
+
+    dbg ("gvm_device_mount_finished: mount process %i returned with %i\n", pid,
+            status);
+
+    if (fifoname)
+        unlink (fifoname);
+
+    if (!WIFEXITED(status)) {
+        warn (BIN_MOUNT " did not exit normally\n");
+        return;
+    }
+
+    /* if we have an encryption secret, we display an error message
+     * if the mount failed. */
+    if (WEXITSTATUS(status) && fifoname) {
+        GtkMessageDialog *dialog;
+        dialog = gtk_message_dialog_new (NULL, 0,
+                GTK_MESSAGE_ERROR,
+                GTK_BUTTONS_CLOSE,
+                _("Could not mount encrypted device. Did you supply a wrong passphrase?"));
+        gtk_widget_show (GTK_WIDGET(dialog));
+        g_signal_connect_swapped (dialog, "response",
+                G_CALLBACK (gtk_widget_destroy), dialog);
+    }
+}
+
+/*
+ * gvm_device_mount_encrypted_pwd_callback - Called from
+ * gvm_device_mount_encrypted after the password dialog finished. Use BIN_MOUNT
+ * to mount an encrypted given device.
+ */
+static void
+gvm_device_mount_encrypted_pwd_callback (GksuuiDialog* dialog, gint response,
+        char *udi)
+{
+    char *argv[5] = {BIN_MOUNT, udi, "--passphrase", NULL, NULL};
+    GError *error = NULL;
+    char* fifoname = NULL;
+    FILE* fifo = NULL;
+    GPid mount_pid;
+    char* passphrase = NULL;
+
+    if (!udi) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: udi == NULL!\n");
+        return;
+    }
+    if (!dialog) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: dialog == NULL!\n");
+        return;
+    }
+
+    /* Check whether we got a passphrase */
+    if (response == GTK_RESPONSE_OK)
+        passphrase = gksuui_dialog_get_password (dialog);
+    gtk_widget_destroy (GTK_WIDGET (dialog));
+    if (!passphrase)
+        return;
+
+    /* Create a private temporary FIFO */
+    for (;;) {
+        fifoname = tmpnam(NULL);
+        if (!fifoname) {
+            warn ("gvm_device_mount_encrypted: cannot create a temporary name\n");
+            return;
+        }
+
+        int result = mkfifo (fifoname, 0700);
+        if (result == 0)
+            break;
+        if (errno != EEXIST) {
+            warn ("gvm_device_mount_encrypted: cannot create fifo: %s\n",
+                    strerror (errno));
+            return;
+        }
+    }
+    argv[3] = fifoname;
+
+    /* Call the mount process asynchronously */
+    if (!g_spawn_async (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
+                NULL, &mount_pid, &error)) {
+        warn ("gvm_device_mount_encrypted: could not execute " BIN_MOUNT ": %s\n",
+                error->message);
+        return;
+    }
+
+    /* When mounting finishes, call the clean up and error handling
+     * callback. */
+    g_child_watch_add (mount_pid, gvm_device_mount_finished, fifoname);
+
+    /* now the mount process runs, write the secret into the FIFO;
+     * this blocks until the pmount child opens the fifo */
+    fifo = fopen (fifoname, "w");
+    if (fifo)
+        fputs (passphrase, fifo);
+    else {
+        warn ("gvm_device_mount_encrypted: cannot open fifo: %s\n",
+                strerror (errno));
+        unlink (fifoname);
+    }
+    free (passphrase);
+    fclose (fifo);
+    free (udi);
+}
+
+/*
+ * gvm_device_mount_encrypted - create a passphrase dialog for an encrypted
+ * dialog and set up gvm_device_mount_encrypted_pwd_callback() as a callback.
+ *
+ * @return TRUE iff the mount was succesful
+ */
+static void
+gvm_device_mount_encrypted (const char *udi)
+{
+    GksuuiDialog *dialog = GKSUUI_DIALOG (gksuui_dialog_new());
+    gtk_window_set_title (GTK_WINDOW(dialog), _("Encrypted volume detected"));
+    gksuui_dialog_set_message (dialog,  _("A passphrase is required to decrypt this volume"));
+
+    g_signal_connect (dialog, "response", 
+            G_CALLBACK (gvm_device_mount_encrypted_pwd_callback), g_strdup (udi));
+
+    gtk_widget_show_all (GTK_WIDGET(dialog));
+}
+
+/*
  * gvm_device_mount - use BIN_MOUNT to mount the given device.
  *
  * @return TRUE iff the mount was succesful
@@ -496,6 +631,21 @@
 	char *argv[3];
 	GError *error = NULL;
 	gint exit_status;
+	gchar *fsusage = NULL;
+
+	if (libhal_device_property_exists (hal_ctx, udi, "volume.fsusage", NULL)) {
+		fsusage = 
+			libhal_device_get_property_string (hal_ctx, udi, "volume.fsusage", NULL);
+	}
+
+	/* Check for encrypted device */
+	if (fsusage && !g_strcasecmp(fsusage, "crypto")) {
+		dbg ("encrypted volume found\n");
+		gvm_device_mount_encrypted (udi);
+		libhal_free_string(fsusage);
+		return TRUE;
+	}
+	libhal_free_string(fsusage);
 
 	argv[0] = BIN_MOUNT;
 	argv[1] = udi;
@@ -1182,14 +1332,17 @@
 			continue;
 
 		/* only mount if the block device got a sensible filesystem */
-		if (!libhal_device_property_exists (ctx, udi, 
-						    "volume.fsusage",
-						    NULL) ||
-		    strcmp (libhal_device_get_property_string (ctx, udi, 
-							       "volume.fsusage",
-							       NULL), 
-			    "filesystem") != 0) 
+		if (libhal_device_property_exists (ctx, udi, "volume.fsusage", NULL)) {
+			gchar *fsusage = 
+				libhal_device_get_property_string (ctx, udi, "volume.fsusage", NULL);
+			if(strcmp(fsusage, "filesystem") && strcmp(fsusage, "crypto")) {
+				libhal_free_string(fsusage);
+				continue;
+			}
+			libhal_free_string(fsusage);
+		} else {
 			continue;
+		}
 		drive_udi = libhal_device_get_property_string(ctx, udi, "info.parent", NULL);
   
 		do_mount = TRUE;
