diff -ruN gnome-volume-manager-1.5.7-old/src/manager.c gnome-volume-manager-1.5.7/src/manager.c
--- gnome-volume-manager-1.5.7-old/src/manager.c	2006-01-04 14:12:53.000000000 +0100
+++ gnome-volume-manager-1.5.7/src/manager.c	2006-01-04 14:12:58.000000000 +0100
@@ -552,6 +552,120 @@
 }
 
 /*
+ * multihead support
+ */
+
+#include <regex.h>
+
+static regex_t* usb_restrict_re = NULL;
+
+static void init_usb_restriction()
+{
+    regex_t re;
+    FILE *f;
+    regmatch_t m[3];
+    char restr[1024];
+    char line[4096];
+    char *busre, *portre;
+
+    /* get workstation */
+    char* display = getenv ("DISPLAY");
+    int workstation;
+
+    if (!display) {
+        dbg ("DISPLAY not set, not restricting USB ports\n");
+        return;
+    }
+    if (sscanf (display, ":%i.", &workstation) < 1 &&
+        sscanf (display, "%*[a-zA-Z0-9.-]:%i.", &workstation) < 1) {
+        dbg ("invalid DISPLAY variable, exiting\n");
+        exit (EXIT_SUCCESS);
+    }
+
+    f = fopen ("/etc/multiseat.conf", "r");
+    if (!f)
+        return;
+
+    /* generate key[index] = value regex */
+    snprintf (restr, sizeof(restr),
+            "^[[:space:]]*storage[[:space:]]*\\[[[:space:]]*%i[[:space:]]*\\][[:space:]]*=[[:space:]]*\"usb-([^-]*)-(.*)\"[[:space:]]*$",
+            workstation);
+    if (regcomp (&re, restr, REG_EXTENDED)) {
+        dbg ("init_usb_restriction: invalid regular expression\n");
+        exit (-99);
+    }
+
+    while (fgets (line, sizeof(line), f)) {
+        if (!regexec (&re, line, 3, m, 0)) {
+            line[m[2].rm_eo] = 0;
+            portre = (char*) malloc (m[2].rm_eo - m[2].rm_so + 1);
+            strcpy (portre, line+m[2].rm_so);
+            line[m[1].rm_eo] = 0;
+            busre = (char*) malloc (m[1].rm_eo - m[1].rm_so + 1);
+            strcpy (busre, line+m[1].rm_so);
+
+            snprintf (restr, sizeof (restr), "^/sys/.*/%s/.*-%s$", busre, portre);
+            dbg ("/etc/multiseat.conf: restricting to USB devices to bus /%s/ and port /%s/ -> sysfs path /%s/\n", 
+                    busre, portre, restr );
+
+            usb_restrict_re = (regex_t*) malloc (sizeof (regex_t));
+            if (regcomp (usb_restrict_re, restr, REG_EXTENDED)) {
+                dbg ("init_usb_restriction: invalid regular expression in /etc/multiseat.conf\n");
+                exit (-99);
+            }
+
+            free (busre);
+            free (portre);
+            break;
+        }
+    }
+
+    if (!usb_restrict_re) {
+        dbg ("init_usb_restriction: no matching storage configuration in /etc/multiseat.conf, exiting\n");
+        exit (EXIT_SUCCESS);
+    }
+
+    fclose (f);
+}
+
+static int
+pass_usb_restriction (const char* udi)
+{
+    char *dev, *parent, *value;
+    int match = 0;
+
+    if (!usb_restrict_re)
+        return 1;
+
+    dev = g_strdup (udi);
+
+    while (dev) {
+        if (libhal_device_property_exists (hal_ctx, dev, "usb_device.linux.sysfs_path", NULL)) {
+            value = libhal_device_get_property_string (hal_ctx, dev, "usb_device.linux.sysfs_path", NULL);
+            if (!value)
+                return 0;
+
+            dbg("Checking whether kernel device name %s matches USB restriction\n",
+                value);
+
+            match = !regexec (usb_restrict_re, value, 0, NULL, 0);
+            libhal_free_string (value);
+            break;
+        }
+        if (libhal_device_property_exists (hal_ctx, dev, "info.parent", NULL)) {
+            parent = libhal_device_get_property_string (hal_ctx, dev, "info.parent", NULL);
+            libhal_free_string (dev);
+            dev = parent;
+        } else
+            dev = NULL;
+    }
+
+    if (dev)
+        libhal_free_string (dev);
+    return match;
+}
+
+/*
  * gvm_load_config - synchronize gconf => config structure
  */
 static void
@@ -1784,6 +1898,12 @@
 	}
 	
 	if (mountable) {
+			/* Check multiseat configuration */
+			if (!pass_usb_restriction (udi)) {
+			    dbg ("%s is restricted by /etc/multiseat.conf, not mounting\n", udi);
+			    goto out;
+			}
+
 		/* only mount if the block device has a sensible filesystem */
 		fsusage = libhal_device_get_property_string (hal_ctx, udi, "volume.fsusage", &error);
                 if (fsusage && !g_strcasecmp(fsusage, "crypto")) {
@@ -2461,6 +2581,8 @@
 		
 		return 1;
 	}
+
+	init_usb_restriction();
 	
 	g_signal_connect (client, "die", G_CALLBACK (gvm_die), NULL);
 	
