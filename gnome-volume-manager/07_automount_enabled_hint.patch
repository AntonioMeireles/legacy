diff -ruN gnome-volume-manager-1.3.2-old/src/manager.c gnome-volume-manager-1.3.2/src/manager.c
--- gnome-volume-manager-1.3.2-old/src/manager.c	2005-07-04 16:51:55.233715000 +0200
+++ gnome-volume-manager-1.3.2/src/manager.c	2005-07-04 16:52:29.355527760 +0200
@@ -1134,6 +1134,31 @@
 	libhal_free_string (media_type);
 }
 
+/** Return the value of storage.automount_enabled_hint. First check the given
+ * volume's parent (which is the drive), then the volume itself. Default to
+ * true if the property is not set on either node.
+ */
+static gboolean
+gvm_get_automount_enabled_hint (const char* udi)
+{
+    gchar *parent;
+    gboolean ret = TRUE;
+
+    parent = libhal_device_get_property_string(hal_ctx, udi, "info.parent", NULL);
+    if (libhal_device_property_exists (hal_ctx, parent,
+		"storage.automount_enabled_hint", NULL)) {
+	ret = libhal_device_get_property_bool (hal_ctx, parent,
+		    "storage.automount_enabled_hint", NULL);
+    }
+    if (libhal_device_property_exists (hal_ctx, udi,
+		"storage.automount_enabled_hint", NULL)) {
+	ret = libhal_device_get_property_bool (hal_ctx, udi,
+		    "storage.automount_enabled_hint", NULL);
+    }
+    libhal_free_string (parent);
+    return ret;
+}
+
 /** Invoked when a device is added to the Global Device List. 
  *
  *  @param  ctx                 LibHal context
@@ -1190,7 +1215,10 @@
 		
 #ifndef ASSUME_SUBMOUNT
 		if (config.automount_drives && mountable) {
-			gvm_device_mount (udi, device, NULL);
+			if (!gvm_get_automount_enabled_hint (udi))
+			    gvm_device_mount (udi, device, NULL);
+			else
+			    dbg("%s has storage.automount_enabled_hint == false, not mounting\n", udi);
 			mounted_volumes_policy_queue = g_slist_append (mounted_volumes_policy_queue, g_strdup (udi));
 		}
 #else
