diff -Nur gnome-volume-manager-2.15.0/configure.in gnome-volume-manager-2.15.0/configure.in
--- gnome-volume-manager-2.15.0/configure.in	2006-07-31 22:06:09.000000000 +0200
+++ gnome-volume-manager-2.15.0/configure.in	2006-08-02 11:19:20.000000000 +0200
@@ -98,7 +98,7 @@
 AC_SUBST(GVM_CONSOLE_AUTH_DIR)
 AC_DEFINE_UNQUOTED(GVM_CONSOLE_AUTH_DIR, "$GVM_CONSOLE_AUTH_DIR", [Directory to check for console ownership])
 
-PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.4 gtk+-2.0 >= 2.6.0)
+PKG_CHECK_MODULES(GVM, libgnomeui-2.0 dbus-glib-1 >= 0.31 hal >= 0.5.4 gtk+-2.0 >= 2.6.0 libgksuui1.0 >= 1.0.0)
 AC_SUBST(GVM_CFLAGS)
 AC_SUBST(GVM_LIBS)
 
diff -Nur gnome-volume-manager-2.15.0/src/manager.c gnome-volume-manager-2.15.0/src/manager.c
--- gnome-volume-manager-2.15.0/src/manager.c	2006-07-31 22:37:36.000000000 +0200
+++ gnome-volume-manager-2.15.0/src/manager.c	2006-08-02 11:19:49.000000000 +0200
@@ -26,6 +26,7 @@
 #include <signal.h>
 #include <unistd.h>
 #include <utmp.h>
+#include <mntent.h>
 
 #include <locale.h>
 
@@ -46,6 +47,8 @@
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <libhal.h>
+#include <libgksuui1.0/gksuui.h>
+#include <sys/wait.h>
 
 #include "gvm.h"
 
@@ -1716,6 +1719,157 @@
 	return iocharset;
 }
 
+/*
+ * gvm_device_mount_finished - called back when mount finished.
+ *
+ * This needs to close the pid, remove the FIFO (if given, that applies to
+ * encrypted devices) and display an error message if the mount failed.
+ */
+void
+gvm_device_mount_finished (GPid pid, gint status, const char* fifoname)
+{
+    g_spawn_close_pid (pid);
+
+    dbg ("gvm_device_mount_finished: mount process %i returned with %i\n", pid,
+            status);
+
+    if (fifoname)
+        unlink (fifoname);
+
+    if (!WIFEXITED(status)) {
+        warn ("pmount did not exit normally\n");
+        return;
+    }
+
+    /* if we have an encryption secret, we display an error message
+     * if the mount failed. */
+    if (WEXITSTATUS(status) && fifoname) {
+        GtkMessageDialog *dialog;
+        dialog = gtk_message_dialog_new (NULL, 0,
+                GTK_MESSAGE_ERROR,
+                GTK_BUTTONS_CLOSE,
+                _("Could not mount encrypted device. Did you supply a wrong passphrase?"));
+        gtk_widget_show (GTK_WIDGET(dialog));
+        g_signal_connect_swapped (dialog, "response",
+                G_CALLBACK (gtk_widget_destroy), dialog);
+    }
+}
+
+/*
+ * gvm_device_mount_encrypted_pwd_callback - Called from
+ * gvm_device_mount_encrypted after the password dialog finished. Use pmount
+ * to mount an encrypted given device.
+ */
+static void
+gvm_device_mount_encrypted_pwd_callback (GksuuiDialog* dialog, gint response,
+        char *udi)
+{
+    char *argv[5] = {"/usr/bin/pmount-hal", udi, "--passphrase", NULL, NULL};
+    GError *error = NULL;
+    char* fifoname = NULL;
+    FILE* fifo = NULL;
+    GPid mount_pid;
+    char* passphrase = NULL;
+
+    if (!udi) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: udi == NULL!\n");
+        return;
+    }
+    if (!dialog) {
+        warn ("gvm_device_mount_encrypted_pwd_callback: dialog == NULL!\n");
+        return;
+    }
+
+    /* Check whether we got a passphrase */
+    if (response == GTK_RESPONSE_OK)
+        passphrase = gksuui_dialog_get_password (dialog);
+    gtk_widget_destroy (GTK_WIDGET (dialog));
+    if (!passphrase)
+        return;
+
+    /* Create a private temporary FIFO */
+    for (;;) {
+        fifoname = tmpnam(NULL);
+        if (!fifoname) {
+            warn ("gvm_device_mount_encrypted: cannot create a temporary name\n");
+            return;
+        }
+
+        int result = mkfifo (fifoname, 0700);
+        if (result == 0)
+            break;
+        if (errno != EEXIST) {
+            warn ("gvm_device_mount_encrypted: cannot create fifo: %s\n",
+                    strerror (errno));
+            return;
+        }
+    }
+    argv[3] = fifoname;
+
+    /* Call the mount process asynchronously */
+    if (!g_spawn_async (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
+                NULL, &mount_pid, &error)) {
+        warn ("gvm_device_mount_encrypted: could not execute pmount: %s\n",
+                error->message);
+        return;
+    }
+
+    /* When mounting finishes, call the clean up and error handling
+     * callback. */
+    g_child_watch_add (mount_pid, gvm_device_mount_finished, fifoname);
+
+    /* now the mount process runs, write the secret into the FIFO;
+     * this blocks until the pmount child opens the fifo */
+    fifo = fopen (fifoname, "w");
+    if (fifo)
+        fputs (passphrase, fifo);
+    else {
+        warn ("gvm_device_mount_encrypted: cannot open fifo: %s\n",
+                strerror (errno));
+        unlink (fifoname);
+    }
+    free (passphrase);
+    fclose (fifo);
+    free (udi);
+}
+
+/*
+ * gvm_device_mount_encrypted - create a passphrase dialog for an encrypted
+ * dialog and set up gvm_device_mount_encrypted_pwd_callback() as a callback.
+ *
+ * @return TRUE iff the mount was succesful
+ */
+static void
+gvm_device_mount_encrypted (const char *udi)
+{
+    GksuuiDialog *dialog = GKSUUI_DIALOG (gksuui_dialog_new());
+    gtk_window_set_title (GTK_WINDOW(dialog), _("Encrypted volume detected"));
+
+    /* if cryptsetup is not available, tell user about it */
+    if (access ("/sbin/cryptsetup", X_OK) < 0) {
+	GtkWidget* dialog = gtk_message_dialog_new_with_markup (NULL, GTK_DIALOG_MODAL,
+		GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, 
+		_("This device contains an encrypted partition. Please install the package <b>cryptsetup</b> to access it."));
+	gtk_dialog_run (GTK_DIALOG (dialog));
+	gtk_widget_destroy (dialog);
+	return;
+    }
+
+    const char* device = libhal_device_get_property_string (hal_ctx, udi, "block.device", NULL);
+
+    if (device) {
+        char message[1000];
+        snprintf (message, sizeof(message), _("A passphrase is required to decrypt volume %s"), device);
+        gksuui_dialog_set_message (dialog, message);
+    } else
+        gksuui_dialog_set_message (dialog,  _("A passphrase is required to decrypt this volume"));
+
+    g_signal_connect (dialog, "response", 
+            G_CALLBACK (gvm_device_mount_encrypted_pwd_callback), g_strdup (udi));
+
+    gtk_widget_show_all (GTK_WIDGET(dialog));
+}
+
 
 /*
  * gvm_device_mount - mount the given device.
@@ -2265,6 +2419,9 @@
 	if (config.automount_drives && (mountable || crypto)) {
 		if (!gvm_udi_is_subfs_mount (udi)) {
 			if (!libhal_device_get_property_bool (hal_ctx, udi, "volume.ignore", NULL)) {
+			    if (crypto)
+				gvm_device_mount_encrypted (udi);
+			    else
 				gvm_device_mount (udi, TRUE);
 			} else {
 				dbg ("volume.ignore set to true on %s, not mounting\n", udi);
@@ -2803,6 +2960,73 @@
 	return ctx;
 }
 
+/*
+ * Check whether dev is an encrypted device handled by devmapper. If so, pass
+ * the underlying physical device major/minor and return TRUE.
+ * If not, or an error occurs, return FALSE.
+ * This uses the /usr/lib/eject/dmcrypt-get-device helper.
+ */
+gboolean hal_get_devmapper_device (const char* dev, int* major, int* minor)
+{
+    char cmd[1024];
+    char output[100];
+
+    const char* devmapper = "/dev/mapper/";
+    if (strncmp (dev, devmapper, strlen(devmapper)))
+        return FALSE;
+
+    if (strchr (dev, '\''))
+        return FALSE;
+    snprintf (cmd, sizeof(cmd), "/usr/lib/eject/dmcrypt-get-device '%s'", dev);
+    FILE* f = popen (cmd, "r");
+    fread (output, 1, sizeof(output), f);
+    if (pclose(f))
+        return FALSE;
+
+    return sscanf(output, "%i:%i", major, minor) == 2;
+}
+
+/** Check whether given UDI is a mounted encrypted device.
+ *
+ */
+static gboolean
+hal_is_encrypted_mounted_device (LibHalContext* ctx, const char* udi)
+{
+    const char* fsusage;
+    int major, minor, fsmajor, fsminor;
+    FILE* mounts;
+    struct mntent* m;
+    gboolean result = FALSE;
+
+    /* ensure we have a crypto block device and get major/minor */
+    fsusage  = libhal_device_get_property_string (ctx, udi, "volume.fsusage", NULL);
+    if (!fsusage || strcmp (fsusage, "crypto") != 0)
+	return FALSE;
+    if (!libhal_device_property_exists (ctx, udi, "block.major", NULL) ||
+	!libhal_device_property_exists (ctx, udi, "block.minor", NULL))
+	return FALSE;
+    major = libhal_device_get_property_int (ctx, udi, "block.major", NULL);
+    minor = libhal_device_get_property_int (ctx, udi, "block.minor", NULL);
+
+    /* walk through mounted devices, resolve devmapper devices, compare */
+    mounts = setmntent("/proc/mounts", "r");
+    if (!mounts) {
+	warn ("hal_is_encrypted_mounted_device(): Could not open /proc/mounts: %s\n", strerror (errno));
+	return FALSE;
+    }
+    while ((m = getmntent (mounts)) != NULL) {
+	if (hal_get_devmapper_device (m->mnt_fsname, &fsmajor, &fsminor) &&
+		fsmajor == major && fsminor == minor) {
+	    dbg ("hal_is_encrypted_mounted_device: UDI %s (device %s) is an encrypted mounted file system\n", 
+		udi, libhal_device_get_property_string (ctx, udi, "block.device", NULL));
+	    result = TRUE;
+	    break;
+	}
+    }
+    endmntent (mounts);
+    return result;
+}
+
 /** Attempt to mount all volumes; should be called on startup.
  *
  *  @param  ctx                 LibHal context
@@ -2839,7 +3063,8 @@
 		
 		/* don't attempt to mount already mounted volumes */
 		if (!libhal_device_property_exists (ctx, udi, "volume.is_mounted", NULL)
-		    || libhal_device_get_property_bool (ctx, udi, "volume.is_mounted", NULL)) {
+		    || libhal_device_get_property_bool (ctx, udi, "volume.is_mounted", NULL)
+		    || hal_is_encrypted_mounted_device (ctx, udi)) {
 #ifdef ENABLE_NOTIFY
 			statfs_mount_info_add (udi);
 #endif
@@ -2854,6 +3079,7 @@
 			libhal_free_string (prop);
 			continue;
 		}
+ 		gboolean is_encrypted = (prop[0] == 'c');
 		libhal_free_string (prop);
 		
 		/* check our mounting policy */
@@ -2877,7 +3103,10 @@
 		if ((dev = libhal_device_get_property_string (ctx, udi, "block.device", &error))) {
 			dbg ("mount_all: mounting %s\n", dev);
 			/* don't make the mount program put up error dialogs */
-			gvm_device_mount (udi, FALSE);
+ 			if (is_encrypted)
+ 			    gvm_device_mount_encrypted (udi);
+ 			else
+ 			    gvm_device_mount (udi, FALSE);
 			libhal_free_string (dev);
 		} else {
 			warn ("mount_all: no device for udi=%s: %s", udi, error.message);
