diff -rNu qt-x11-free/apply_patches qt-copy/apply_patches
--- qt-x11-free/apply_patches	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/apply_patches	2005-12-08 20:05:15.286533000 +0300
@@ -0,0 +1,149 @@
+#! /usr/bin/env bash
+# Script to apply patches from qt-copy/patches/.
+# See README.qt-copy for details.
+#
+# Lubos Lunak <l.lunak@kde.org>
+# Oswald Buddenhagen <ossi@kde.org>
+#
+
+if ! test -d patches; then
+    echo "No patches directory found."
+    exit 1
+fi
+
+revert=false reverse=
+clever=false
+verbose=true silent=
+for i; do
+    case $i in
+        -r|-R|--reverse) revert=true; reverse=--reverse;;
+        -c|--clever) clever=true;;
+        -s|--silent|-q|--quiet) verbose=false; silent=--silent;;
+        *) echo "Unknown option '$i'." >&2; exit 1;;
+    esac
+done
+
+b=../.${PWD##*/}
+
+if $clever; then
+    if ! $revert; then
+        pdir=$b.patched
+        odir=$b.cvs
+    else
+        pdir=$b.cvs
+        odir=$b.patched
+    fi
+    $verbose && echo -n "Creating temporary copy ... "
+    tdir=$b.temp
+    test -d $tdir || { rm -rf $tdir.t; cp -al . $tdir.t && mv $tdir.t $tdir; } || exit
+    $verbose && echo "done."
+fi
+
+plist=.applied_patches
+wlist=$plist.work
+test -f $wlist -o ! -f $plist || cp $plist $wlist || exit
+patches=`cd patches/ >/dev/null && ls [0-9]*-* $reverse`
+applied=
+already=
+skipped=
+disabled=
+for file in $patches; do
+    # skip files that aren't *.diff or *.patch
+    test "${file%.patch}" = "$file" -a "${file%.diff}" = "$file" && continue
+    pnum=${file%%-*}
+    if ! $revert || ! test -f $plist; then
+        # skip those having 'applied: yes' in the header
+        if head -n 5 patches/$file | grep -iq '^[\t ]*applied[\t ]*:[\t ]*yes[\t ]*$'; then
+            already="$already $file\n"
+            continue;
+        fi
+        # skip disabled
+        if grep -q "^[\\t ]*$pnum[\\t ]*\$" patches/DISABLED; then
+            disabled="$disabled $file\n"
+            continue;
+        fi
+    fi
+    if test -f $plist; then
+        grep -q $pnum $wlist && listed=true || listed=false
+        if test $listed != $revert; then
+            skipped="$skipped $file\n"
+            continue;
+        fi
+    fi
+    $verbose && echo -e "\nApplying: $file"
+    if $clever; then
+        if ! patch -b -z .touched $silent $reverse -p0 < patches/$file; then
+            echo -e "\n\nPatch $file failed!"
+            while :; do
+                read -p "[A]bort, [c]ontinue, or [r]ollback all? " sel
+                case $sel in
+                    a) exit 1;;
+                    c) continue 2;;
+                    r)
+                        $verbose && echo -ne "Deleting working directory ... "
+                        rm -rf $PWD/*
+                        rm -f $wlist
+                        $verbose && echo -ne "done.\nSubstituting with temporary directory ... "
+                        mv $tdir/* $PWD
+                        rm -rf $tdir
+                        $verbose && echo "done."
+                        exit 2;;
+                esac
+            done
+        fi
+    else
+        if ! patch $silent $reverse -p0 < patches/$file; then
+            echo -e "\n\nPatch $file failed!"
+            while :; do
+                read -p "[A]bort or [c]ontinue? " sel
+                case $sel in
+                    a) exit 1;;
+                    c) continue 2;;
+                esac
+            done
+        fi
+    fi
+    if ! $revert; then
+        echo $pnum >> $wlist
+    elif test -f $wlist; then
+        grep -v $pnum $wlist > $wlist.new
+        mv $wlist.new $wlist
+    fi
+    applied="$applied $file\n"
+done
+touch $wlist
+mv $wlist $plist
+
+$verbose && echo -e "\n\n\nDone.\n
+Applied patches:\n$applied
+Previously applied patches:\n$skipped
+Disabled patches:\n$disabled
+Already merged patches:\n$already"
+
+if $clever; then
+    $verbose && echo -n "Creating backup ... "
+    test -f $odir/.cleanme && rm -rf $odir
+    for j in $(find -name \*.touched); do
+        rj=${j%.touched}
+        if ! test -f "$odir/$rj"; then
+            mkdir -p "$odir/${rj%/*}" || exit
+            ln "$tdir/$rj" "$odir/$rj" || exit
+        fi
+        rm "$j"
+    done
+    $verbose && echo -ne "done.\nDeleting temporary directory ... "
+    mv $tdir $tdir.t && rm -rf $tdir.t
+    if test -d $pdir; then
+        $verbose && echo -ne "done.\nRestoring previous backup ... "
+        for j in $(find $pdir -type f); do
+            rj=${j#"$pdir/"}
+            cmp -s "$j" "$rj" && { mv "$j" "$rj" || exit; }
+        done
+        $verbose && echo -ne "done.\nCleaning previous backup ... "
+        find $pdir -type d | sort -r | xargs -r rmdir 2> /dev/null
+        touch $pdir/.cleanme 2> /dev/null
+    fi
+    $verbose && echo "done."
+fi
+
+exit 0
diff -rNu qt-x11-free/doc/commercialeditions.doc qt-copy/doc/commercialeditions.doc
--- qt-x11-free/doc/commercialeditions.doc	2007-02-02 17:01:01.000000000 +0300
+++ qt-copy/doc/commercialeditions.doc	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/commercialeditions.doc   3.3.8   edited Jan 11 14:46 $
+** $Id: commercialeditions.doc 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Documentation on the commercial editions
 **
diff -rNu qt-x11-free/doc/html/archivesearch-example.html qt-copy/doc/html/archivesearch-example.html
--- qt-x11-free/doc/html/archivesearch-example.html	2007-02-02 17:28:18.000000000 +0300
+++ qt-copy/doc/html/archivesearch-example.html	2007-02-22 23:30:42.021290000 +0300
@@ -39,7 +39,7 @@
 <p> <hr>
 <p> The implementation of the HTTP requests (archivedialog.ui.h):
 <p> <pre>/****************************************************************************
-** $Id: qt/archivedialog.ui.h   3.3.8   edited Jan 29 15:54 $
+** $Id: archivesearch-example.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
@@ -146,7 +146,7 @@
 <p> <hr>
 <p> Main (main.cpp):
 <p> <pre>/****************************************************************************
-** $Id: qt/main.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: archivesearch-example.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/doc/html/qaxbase-h.html qt-copy/doc/html/qaxbase-h.html
--- qt-x11-free/doc/html/qaxbase-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxbase-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxbase.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxbase-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxBase class
 **
diff -rNu qt-x11-free/doc/html/qaxbindable-h.html qt-copy/doc/html/qaxbindable-h.html
--- qt-x11-free/doc/html/qaxbindable-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxbindable-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxbindable.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxbindable-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxBindable class
 **
diff -rNu qt-x11-free/doc/html/qaxfactory-h.html qt-copy/doc/html/qaxfactory-h.html
--- qt-x11-free/doc/html/qaxfactory-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxfactory-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxfactory.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxfactory-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxFactory class
 **
diff -rNu qt-x11-free/doc/html/qaxobject-h.html qt-copy/doc/html/qaxobject-h.html
--- qt-x11-free/doc/html/qaxobject-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxobject-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxobject.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxobject-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxObject class
 **
diff -rNu qt-x11-free/doc/html/qaxscript-h.html qt-copy/doc/html/qaxscript-h.html
--- qt-x11-free/doc/html/qaxscript-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxscript-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxscript.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxscript-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxScriptEngine, QAxScript and QAxScriptManager classes
 **
diff -rNu qt-x11-free/doc/html/qaxwidget-h.html qt-copy/doc/html/qaxwidget-h.html
--- qt-x11-free/doc/html/qaxwidget-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qaxwidget-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qaxwidget.h   3.3.8   edited Jan 11 14:46 $
+** $Id: qaxwidget-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QAxWidget class
 **
diff -rNu qt-x11-free/doc/html/qlocale-h.html qt-copy/doc/html/qlocale-h.html
--- qt-x11-free/doc/html/qlocale-h.html	2007-02-02 17:28:08.000000000 +0300
+++ qt-copy/doc/html/qlocale-h.html	2007-02-22 23:30:42.021290000 +0300
@@ -35,7 +35,7 @@
 <hr>
 <pre>
 /****************************************************************************
-** $Id: qt/qlocale.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale-h.html 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QLocale class
 **
diff -rNu qt-x11-free/doc/qtmac-as-native.doc qt-copy/doc/qtmac-as-native.doc
--- qt-x11-free/doc/qtmac-as-native.doc	2007-02-02 17:01:01.000000000 +0300
+++ qt-copy/doc/qtmac-as-native.doc	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qtmac-as-native.doc   3.3.8   edited Jan 11 14:46 $
+** $Id: qtmac-as-native.doc 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Qt/Mac documentation
 **
diff -rNu qt-x11-free/examples/helpsystem/main.cpp qt-copy/examples/helpsystem/main.cpp
--- qt-x11-free/examples/helpsystem/main.cpp	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/main.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/main.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: main.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/mainwindow.cpp qt-copy/examples/helpsystem/mainwindow.cpp
--- qt-x11-free/examples/helpsystem/mainwindow.cpp	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/mainwindow.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/mainwindow.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: mainwindow.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/mainwindow.h qt-copy/examples/helpsystem/mainwindow.h
--- qt-x11-free/examples/helpsystem/mainwindow.h	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/mainwindow.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/mainwindow.h   3.3.8   edited Jan 11 14:37 $
+** $Id: mainwindow.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/tooltip.cpp qt-copy/examples/helpsystem/tooltip.cpp
--- qt-x11-free/examples/helpsystem/tooltip.cpp	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/tooltip.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/tooltip.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: tooltip.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/tooltip.h qt-copy/examples/helpsystem/tooltip.h
--- qt-x11-free/examples/helpsystem/tooltip.h	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/tooltip.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/tooltip.h   3.3.8   edited Jan 11 14:37 $
+** $Id: tooltip.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/whatsthis.cpp qt-copy/examples/helpsystem/whatsthis.cpp
--- qt-x11-free/examples/helpsystem/whatsthis.cpp	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/whatsthis.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/whatsthis.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: whatsthis.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/helpsystem/whatsthis.h qt-copy/examples/helpsystem/whatsthis.h
--- qt-x11-free/examples/helpsystem/whatsthis.h	2007-02-02 17:01:53.000000000 +0300
+++ qt-copy/examples/helpsystem/whatsthis.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/whatsthis.h   3.3.8   edited Jan 11 14:37 $
+** $Id: whatsthis.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/network/archivesearch/archivedialog.ui.h qt-copy/examples/network/archivesearch/archivedialog.ui.h
--- qt-x11-free/examples/network/archivesearch/archivedialog.ui.h	2007-02-02 17:01:55.000000000 +0300
+++ qt-copy/examples/network/archivesearch/archivedialog.ui.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/archivedialog.ui.h   3.3.8   edited Jan 29 15:54 $
+** $Id: archivedialog.ui.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/network/archivesearch/archivesearch.doc qt-copy/examples/network/archivesearch/archivesearch.doc
--- qt-x11-free/examples/network/archivesearch/archivesearch.doc	2007-02-02 17:01:55.000000000 +0300
+++ qt-copy/examples/network/archivesearch/archivesearch.doc	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 /*
-$Id: qt/archivesearch.doc   3.3.8   edited Jun 19 2003 $
+$Id: archivesearch.doc 459878 2005-09-12 10:00:31Z binner $
 */
      
 /*! \page archivesearch-example.html
diff -rNu qt-x11-free/examples/network/archivesearch/main.cpp qt-copy/examples/network/archivesearch/main.cpp
--- qt-x11-free/examples/network/archivesearch/main.cpp	2007-02-02 17:01:55.000000000 +0300
+++ qt-copy/examples/network/archivesearch/main.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/main.cpp   3.3.8   edited Jan 11 14:37 $
+** $Id: main.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Copyright (C) 1992-2007 Trolltech ASA.  All rights reserved.
 **
diff -rNu qt-x11-free/examples/qwerty/ANSI_X3.110-1983.txt qt-copy/examples/qwerty/ANSI_X3.110-1983.txt
--- qt-x11-free/examples/qwerty/ANSI_X3.110-1983.txt	2003-05-27 19:19:19.000000000 +0400
+++ qt-copy/examples/qwerty/ANSI_X3.110-1983.txt	2000-07-19 00:05:44.000000000 +0400
@@ -1,7 +1,7 @@
-ABCDE
-ÂaÃaÄaÈaÊañËcÁeÂeÃeÈeÁiÂiÃiÈióÄnÁoÂoÃoÄoÈoùÁuÂa
-?????
-?????
-?????
-??????
+ABCDE
+ÂaÃaÄaÈaÊañËcÁeÂeÃeÈeÁiÂiÃiÈióÄnÁoÂoÃoÄoÈoùÁuÂa
+?????
+?????
+?????
+??????
 ??????
\ No newline at end of file
diff -rNu qt-x11-free/examples/qwerty/eucJP.txt qt-copy/examples/qwerty/eucJP.txt
--- qt-x11-free/examples/qwerty/eucJP.txt	2003-05-27 19:19:19.000000000 +0400
+++ qt-copy/examples/qwerty/eucJP.txt	2000-07-19 00:05:44.000000000 +0400
@@ -1,7 +1,7 @@
-ABCDE
-¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢
-¤¢¤¤¤¦¤¨¤ª
-¤«¤­¤¯¤±¤³
-¤µ¤·¤¹¤»¤½
-§«§¸§µ§¬§¦§¯
+ABCDE
+¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢¢
+¤¢¤¤¤¦¤¨¤ª
+¤«¤­¤¯¤±¤³
+¤µ¤·¤¹¤»¤½
+§«§¸§µ§¬§¦§¯
 §Û§è§å§Ü§Ö§ß
\ No newline at end of file
diff -rNu qt-x11-free/examples/qwerty/IBM277.txt qt-copy/examples/qwerty/IBM277.txt
--- qt-x11-free/examples/qwerty/IBM277.txt	2003-05-27 19:19:19.000000000 +0400
+++ qt-copy/examples/qwerty/IBM277.txt	2000-07-19 00:05:44.000000000 +0400
@@ -1 +1,7 @@
-ÁÂÃÄÅ%EBFCÐÀHTQRSXUVWŒIÍÎËÏÌjÝE%?????%?????%?????%??????%??????
\ No newline at end of file
+ÁÂÃÄÅ
+%EBFCÐÀHTQRSXUVWŒIÍÎËÏÌjÝE
+%?????
+%?????
+%?????
+%??????
+%??????
\ No newline at end of file
diff -rNu qt-x11-free/examples/qwerty/koi8.txt qt-copy/examples/qwerty/koi8.txt
--- qt-x11-free/examples/qwerty/koi8.txt	2003-05-27 19:19:19.000000000 +0400
+++ qt-copy/examples/qwerty/koi8.txt	2000-07-19 00:05:44.000000000 +0400
@@ -1,7 +1,7 @@
-ABCDE
-¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
-¤¤¤¤¤
-¤¤¤¤¤
-¤¤¤¤¤
-êãõëåî
+ABCDE
+¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
+¤¤¤¤¤
+¤¤¤¤¤
+¤¤¤¤¤
+êãõëåî
 ÊÃÕËÅÎ
\ No newline at end of file
diff -rNu qt-x11-free/examples/qwerty/latin1.txt qt-copy/examples/qwerty/latin1.txt
--- qt-x11-free/examples/qwerty/latin1.txt	2003-05-27 19:19:19.000000000 +0400
+++ qt-copy/examples/qwerty/latin1.txt	2000-07-19 00:05:44.000000000 +0400
@@ -1,7 +1,7 @@
-ABCDE
-áâãäåæçèéêëìíîïðñòóôõöøùá
-?????
-?????
-?????
-??????
+ABCDE
+áâãäåæçèéêëìíîïðñòóôõöøùá
+?????
+?????
+?????
+??????
 ??????
\ No newline at end of file
Files qt-x11-free/examples/qwerty/msunicode.txt and qt-copy/examples/qwerty/msunicode.txt differ
diff -rNu qt-x11-free/include/private/qgl_x11_p.h qt-copy/include/private/qgl_x11_p.h
--- qt-x11-free/include/private/qgl_x11_p.h	2007-02-02 17:01:17.000000000 +0300
+++ qt-copy/include/private/qgl_x11_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qgl_x11_p.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qgl_x11_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Definitions needed for resolving GL/GLX symbols using dlopen()
 ** under X11.
diff -rNu qt-x11-free/include/private/qlocale_p.h qt-copy/include/private/qlocale_p.h
--- qt-x11-free/include/private/qlocale_p.h	2007-02-02 17:01:05.000000000 +0300
+++ qt-copy/include/private/qlocale_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qlocale_p.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QLocalePrivate class
 **
diff -rNu qt-x11-free/include/private/qsyntaxhighlighter_p.h qt-copy/include/private/qsyntaxhighlighter_p.h
--- qt-x11-free/include/private/qsyntaxhighlighter_p.h	2007-02-02 17:01:24.000000000 +0300
+++ qt-copy/include/private/qsyntaxhighlighter_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qsyntaxhighlighter_p.h   3.3.8   edited Jan 11 14:39 $
+** $Id: qsyntaxhighlighter_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Definition of the internal QSyntaxHighlighterInternal class
 **
diff -rNu qt-x11-free/include/qlocale.h qt-copy/include/qlocale.h
--- qt-x11-free/include/qlocale.h	2007-02-02 17:01:05.000000000 +0300
+++ qt-copy/include/qlocale.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qlocale.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QLocale class
 **
diff -rNu qt-x11-free/Makefile.cvs qt-copy/Makefile.cvs
--- qt-x11-free/Makefile.cvs	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/Makefile.cvs	2007-03-16 13:00:42.994337000 +0300
@@ -0,0 +1,9 @@
+all:
+	-cd include && headers=`ls q*.h 2>/dev/null` &&\
+	[ "x$$headers" != "x" ] && rm -f $$headers;
+	cd include && ln -f -s ../src/*/q*.h . && ln -f -s ../extensions/*/src/q*.h . && \
+	ln -f -s ../tools/designer/uilib/q*.h . &&\
+	ln -f -s ../tools/assistant/lib/q*.h . && rm -f q*_p.h && \
+	rm qtmultilineedit.h qttableview.h && \
+	cd private && rm -f q*.h && ln -f -s ../../src/*/q*_p.h .;
+	
diff -rNu qt-x11-free/mkspecs/aix-g++-64/qmake.conf qt-copy/mkspecs/aix-g++-64/qmake.conf
--- qt-x11-free/mkspecs/aix-g++-64/qmake.conf	2004-07-29 17:05:05.000000000 +0400
+++ qt-copy/mkspecs/aix-g++-64/qmake.conf	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 #
-# $Id$
+# $Id: qmake.conf 459878 2005-09-12 10:00:31Z binner $
 #
 # qmake configuration for aix-g++-64
 #
diff -rNu qt-x11-free/mkspecs/freebsd-icc/qmake.conf qt-copy/mkspecs/freebsd-icc/qmake.conf
--- qt-x11-free/mkspecs/freebsd-icc/qmake.conf	2007-02-02 17:01:44.000000000 +0300
+++ qt-copy/mkspecs/freebsd-icc/qmake.conf	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 #
-# $Id: qt/qmake.conf   3.3.8   edited Sep 19 2003 $
+# $Id: qmake.conf 459878 2005-09-12 10:00:31Z binner $
 #
 # qmake configuration for freebsd-icc
 #
diff -rNu qt-x11-free/mkspecs/linux-ecc-64/qmake.conf qt-copy/mkspecs/linux-ecc-64/qmake.conf
--- qt-x11-free/mkspecs/linux-ecc-64/qmake.conf	2007-02-02 17:01:45.000000000 +0300
+++ qt-copy/mkspecs/linux-ecc-64/qmake.conf	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 #
-# $Id: qt/qmake.conf   3.3.8   edited Sep 18 2003 $
+# $Id: qmake.conf 459878 2005-09-12 10:00:31Z binner $
 #
 # qmake configuration for linux-ecc-64
 #
diff -rNu qt-x11-free/mkspecs/linux-g++-64/qmake.conf qt-copy/mkspecs/linux-g++-64/qmake.conf
--- qt-x11-free/mkspecs/linux-g++-64/qmake.conf	2007-02-02 17:01:45.000000000 +0300
+++ qt-copy/mkspecs/linux-g++-64/qmake.conf	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 #
-# $Id: qt/qmake.conf   3.3.8   edited Aug 23 2005 $
+# $Id: qmake.conf 459878 2005-09-12 10:00:31Z binner $
 #
 # qmake configuration for linux-g++
 #
diff -rNu qt-x11-free/mkspecs/macx-xlc/qmake.conf qt-copy/mkspecs/macx-xlc/qmake.conf
--- qt-x11-free/mkspecs/macx-xlc/qmake.conf	2007-02-02 17:01:44.000000000 +0300
+++ qt-copy/mkspecs/macx-xlc/qmake.conf	2005-09-12 14:00:31.077571000 +0400
@@ -1,5 +1,5 @@
 #
-# $Id: qt/qmake.conf   3.3.8   edited Apr 29 2004 $
+# $Id: qmake.conf 459878 2005-09-12 10:00:31Z binner $
 #
 # qmake configuration for aix-xlc
 #
diff -rNu qt-x11-free/patches/0001-dnd_optimization.patch qt-copy/patches/0001-dnd_optimization.patch
--- qt-x11-free/patches/0001-dnd_optimization.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0001-dnd_optimization.patch	2007-02-23 02:58:09.901189000 +0300
@@ -0,0 +1,188 @@
+qt-bugs@ issue : 16115
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+See http://lists.kde.org/?t=104388858900001&r=1&w=2
+
+
+
+--- src/kernel/qdnd_x11.cpp
++++ src/kernel/qdnd_x11.cpp
+@@ -49,13 +49,15 @@
+ #include "qdragobject.h"
+ #include "qobjectlist.h"
+ #include "qcursor.h"
++#include "qbitmap.h"
++#include "qpainter.h"
+ 
+ #include "qt_x11_p.h"
+ 
+ // conflict resolution
+ 
+-// unused, may be used again later: const int XKeyPress = KeyPress;
+-// unused, may be used again later: const int XKeyRelease = KeyRelease;
++const int XKeyPress = KeyPress;
++const int XKeyRelease = KeyRelease;
+ #undef KeyPress
+ #undef KeyRelease
+ 
+@@ -253,20 +255,47 @@ class QShapedPixmapWidget : public QWidg
+ public:
+     QShapedPixmapWidget(int screen = -1) :
+ 	QWidget(QApplication::desktop()->screen( screen ),
+-		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM )
++		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM ), oldpmser( 0 ), oldbmser( 0 )
+     {
+     }
+ 
+-    void setPixmap(QPixmap pm)
++    void setPixmap(QPixmap pm, QPoint hot)
+     {
+-	if ( pm.mask() ) {
++	int bmser = pm.mask() ? pm.mask()->serialNumber() : 0;
++	if( oldpmser == pm.serialNumber() && oldbmser == bmser
++	    && oldhot == hot )
++	    return;
++	oldpmser = pm.serialNumber();
++	oldbmser = bmser;
++	oldhot = hot;
++	bool hotspot_in = !(hot.x() < 0 || hot.y() < 0 || hot.x() >= pm.width() || hot.y() >= pm.height());
++// if the pixmap has hotspot in its area, make a "hole" in it at that position
++// this will allow XTranslateCoordinates() to find directly the window below the cursor instead
++// of finding this pixmap, and therefore there won't be needed any (slow) search for the window
++// using findRealWindow()
++	if( hotspot_in ) {
++	    QBitmap mask = pm.mask() ? *pm.mask() : QBitmap( pm.width(), pm.height());
++	    if( !pm.mask())
++		mask.fill( Qt::color1 );
++	    QPainter p( &mask );
++	    p.setPen( Qt::color0 );
++	    p.drawPoint( hot.x(), hot.y());
++	    p.end();
++    	    pm.setMask( mask );
++    	    setMask( mask );
++	} else if ( pm.mask() ) {
+ 	    setMask( *pm.mask() );
+ 	} else {
+ 	    clearMask();
+ 	}
+ 	resize(pm.width(),pm.height());
+ 	setErasePixmap(pm);
++	erase();
+     }
++private:
++    int oldpmser;
++    int oldbmser;
++    QPoint oldhot;
+ };
+ 
+ static QShapedPixmapWidget * qt_xdnd_deco = 0;
+@@ -872,6 +901,45 @@ void QDragManager::timerEvent( QTimerEve
+ 	move( QCursor::pos() );
+ }
+ 
++static bool qt_xdnd_was_move = false;
++static bool qt_xdnd_found = false;
++// check whole incoming X queue for move events
++// checking whole queue is done by always returning False in the predicate
++// if there's another move event in the queue, and there's not a mouse button
++// or keyboard or ClientMessage event before it, the current move event
++// may be safely discarded
++// this helps avoiding being overloaded by being flooded from many events
++// from the XServer
++static
++Bool qt_xdnd_predicate( Display*, XEvent* ev, XPointer )
++{
++    if( qt_xdnd_found )
++	return False;
++    if( ev->type == MotionNotify )
++    {
++	qt_xdnd_was_move = true;
++	qt_xdnd_found = true;
++    }
++    if( ev->type == ButtonPress || ev->type == ButtonRelease
++	|| ev->type == XKeyPress || ev->type == XKeyRelease
++	|| ev->type == ClientMessage )
++    {
++	qt_xdnd_was_move = false;
++	qt_xdnd_found = true;
++    }
++    return False;
++}
++
++static
++bool qt_xdnd_another_movement()
++{
++    qt_xdnd_was_move = false;
++    qt_xdnd_found = false;
++    XEvent dummy;
++    XCheckIfEvent( qt_xdisplay(), &dummy, qt_xdnd_predicate, NULL );
++    return qt_xdnd_was_move;
++}
++
+ bool QDragManager::eventFilter( QObject * o, QEvent * e)
+ {
+     if ( beingCancelled ) {
+@@ -894,8 +962,10 @@ bool QDragManager::eventFilter( QObject 
+ 
+     if ( e->type() == QEvent::MouseMove ) {
+ 	QMouseEvent* me = (QMouseEvent *)e;
+-	updateMode(me->stateAfter());
+-	move( me->globalPos() );
++	if( !qt_xdnd_another_movement()) {
++	    updateMode(me->stateAfter());
++	    move( me->globalPos() );
++	}
+ 	return TRUE;
+     } else if ( e->type() == QEvent::MouseButtonRelease ) {
+ 	qApp->removeEventFilter( this );
+@@ -1136,7 +1206,7 @@ void QDragManager::move( const QPoint & 
+ 	    qt_xdnd_deco->grabMouse();
+ 	}
+     }
+-    updatePixmap();
++    updatePixmap( globalPos );
+ 
+     if ( qt_xdnd_source_sameanswer.contains( globalPos ) &&
+ 	 qt_xdnd_source_sameanswer.isValid() ) {
+@@ -1729,7 +1799,7 @@ bool QDragManager::drag( QDragObject * o
+     // qt_xdnd_source_object persists until we get an xdnd_finish message
+ }
+ 
+-void QDragManager::updatePixmap()
++void QDragManager::updatePixmap( const QPoint& cursorPos )
+ {
+     if ( qt_xdnd_deco ) {
+ 	QPixmap pm;
+@@ -1744,9 +1814,8 @@ void QDragManager::updatePixmap()
+ 		defaultPm = new QPixmap(default_pm);
+ 	    pm = *defaultPm;
+ 	}
+-	qt_xdnd_deco->setPixmap(pm);
+-	qt_xdnd_deco->move(QCursor::pos()-pm_hot);
+-	qt_xdnd_deco->repaint(FALSE);
++	qt_xdnd_deco->setPixmap(pm, pm_hot);
++	qt_xdnd_deco->move(cursorPos-pm_hot);
+ 	    //if ( willDrop ) {
+ 	    qt_xdnd_deco->show();
+ 	    //} else {
+@@ -1755,4 +1824,9 @@ void QDragManager::updatePixmap()
+     }
+ }
+ 
++void QDragManager::updatePixmap()
++{
++    updatePixmap( QCursor::pos());
++}
++
+ #endif // QT_NO_DRAGANDDROP
+--- src/kernel/qdragobject.h
++++ src/kernel/qdragobject.h
+@@ -245,6 +245,7 @@ private:
+     void move( const QPoint & );
+     void drop();
+     void updatePixmap();
++    void updatePixmap( const QPoint& cursorPos );
+ 
+ private:
+     QDragObject * object;
diff -rNu qt-x11-free/patches/0002-dnd_active_window_fix.patch qt-copy/patches/0002-dnd_active_window_fix.patch
--- qt-x11-free/patches/0002-dnd_active_window_fix.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0002-dnd_active_window_fix.patch	2003-07-01 14:56:46.000000000 +0400
@@ -0,0 +1,189 @@
+qt-bugs@ issue : 25122
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+ Hello,
+ 
+ for example: Open Konqueror window, showing some files. Start dragging one 
+ desktop icon. If you press/release Ctrl, there'll be a '+' attached to the 
+ icon, showing the DND operation. Now, while still doing DND, make the 
+ Konqueror window active (Alt+Tab with KDE-3.1.2+, hover over its taskbar 
+ entry, Ctrl+Fn to switch to a different virtual desktop, etc.). As soon as 
+ the app performing DND is not the active application, and the mouse is not 
+ moving, pressing/releasing Ctrl doesn't do anything, the state only updates 
+ when the mouse is moved.
+ 
+ This is caused by the fact that Qt has only pointer grab when doing DND, but 
+ doesn't have keyboard grab. I actually consider this a good thing, because 
+ the only keys important for DND are modifiers, and they come together with 
+ pointer events, and not having keyboard grab allows using keyboard shortcuts 
+ like Alt+Tab while DND. However, when the mouse is not moved, and only a 
+ modifier key is pressed/released, the app won't get any mouse event, and 
+ won't also get the keyboard event.
+
+ The attached patch changes Qt to explicitly check the modifiers state using 
+ XQueryPointer() if there's wasn't recently any mouse/keyboard event, which 
+ ensures the state is updated even in the situation described above.
+
+--- src/kernel/qapplication_x11.cpp.sav	2003-06-21 12:31:35.000000000 +0200
++++ src/kernel/qapplication_x11.cpp	2003-06-21 12:35:44.000000000 +0200
+@@ -4053,7 +4053,7 @@ void QApplication::closePopup( QWidget *
+ // Keyboard event translation
+ //
+ 
+-static int translateButtonState( int s )
++int qt_x11_translateButtonState( int s )
+ {
+     int bst = 0;
+     if ( s & Button1Mask )
+@@ -4119,7 +4119,7 @@ bool QETWidget::translateMouseEvent( con
+ 	pos.ry() = lastMotion.y;
+ 	globalPos.rx() = lastMotion.x_root;
+ 	globalPos.ry() = lastMotion.y_root;
+-	state = translateButtonState( lastMotion.state );
++	state = qt_x11_translateButtonState( lastMotion.state );
+ 	if ( qt_button_down && (state & (LeftButton |
+ 					 MidButton |
+ 					 RightButton ) ) == 0 )
+@@ -4143,7 +4143,7 @@ bool QETWidget::translateMouseEvent( con
+ 	pos.ry() = xevent->xcrossing.y;
+ 	globalPos.rx() = xevent->xcrossing.x_root;
+ 	globalPos.ry() = xevent->xcrossing.y_root;
+-	state = translateButtonState( xevent->xcrossing.state );
++	state = qt_x11_translateButtonState( xevent->xcrossing.state );
+ 	if ( qt_button_down && (state & (LeftButton |
+ 					 MidButton |
+ 					 RightButton ) ) == 0 )
+@@ -4155,7 +4155,7 @@ bool QETWidget::translateMouseEvent( con
+ 	pos.ry() = event->xbutton.y;
+ 	globalPos.rx() = event->xbutton.x_root;
+ 	globalPos.ry() = event->xbutton.y_root;
+-	state = translateButtonState( event->xbutton.state );
++	state = qt_x11_translateButtonState( event->xbutton.state );
+ 	switch ( event->xbutton.button ) {
+ 	case Button1: button = LeftButton; break;
+ 	case Button2: button = MidButton; break;
+@@ -4950,7 +4950,7 @@ bool QETWidget::translateKeyEventInterna
+     XKeyEvent xkeyevent = event->xkey;
+ 
+     // save the modifier state, we will use the keystate uint later by passing
+-    // it to translateButtonState
++    // it to qt_x11_translateButtonState
+     uint keystate = event->xkey.state;
+     // remove the modifiers where mode_switch exists... HPUX machines seem
+     // to have alt *AND* mode_switch both in Mod1Mask, which causes
+@@ -5064,7 +5064,7 @@ bool QETWidget::translateKeyEventInterna
+     }
+ #endif // !QT_NO_XIM
+ 
+-    state = translateButtonState( keystate );
++    state = qt_x11_translateButtonState( keystate );
+ 
+     static int directionKeyEvent = 0;
+     if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
+--- src/kernel/qdnd_x11.cpp.sav	2003-06-30 15:26:42.000000000 +0200
++++ src/kernel/qdnd_x11.cpp	2003-06-30 15:32:23.000000000 +0200
+@@ -114,6 +114,8 @@ Atom qt_xdnd_finished;
+ Atom qt_xdnd_type_list;
+ const int qt_xdnd_version = 4;
+ 
++extern int qt_x11_translateButtonState( int s );
++
+ // Actions
+ //
+ // The Xdnd spec allows for user-defined actions. This could be implemented
+@@ -198,6 +200,8 @@ static Atom qt_xdnd_source_current_time;
+ static int qt_xdnd_current_screen = -1;
+ // state of dragging... true if dragging, false if not
+ bool qt_xdnd_dragging = FALSE;
++// need to check state of keyboard modifiers
++static bool need_modifiers_check = FALSE;
+ 
+ // dict of payload data, sorted by type atom
+ static QIntDict<QByteArray> * qt_xdnd_target_data = 0;
+@@ -879,8 +883,20 @@ void qt_handle_xdnd_finished( QWidget *,
+ 
+ void QDragManager::timerEvent( QTimerEvent* e )
+ {
+-    if ( e->timerId() == heartbeat && qt_xdnd_source_sameanswer.isNull() )
+-	move( QCursor::pos() );
++    if ( e->timerId() == heartbeat ) {
++        if( need_modifiers_check ) {
++            Window root, child;
++            int root_x, root_y, win_x, win_y;
++            unsigned int mask;
++            XQueryPointer( qt_xdisplay(), qt_xrootwin( qt_xdnd_current_screen ),
++                &root, &child, &root_x, &root_y, &win_x, &win_y, &mask );
++            if( updateMode( (ButtonState)qt_x11_translateButtonState( mask )))
++                qt_xdnd_source_sameanswer = QRect(); // force move
++        }
++        need_modifiers_check = TRUE;
++        if( qt_xdnd_source_sameanswer.isNull() )
++	    move( QCursor::pos() );
++    }
+ }
+ 
+ static bool qt_xdnd_was_move = false;
+@@ -948,6 +964,7 @@ bool QDragManager::eventFilter( QObject 
+ 	    updateMode(me->stateAfter());
+ 	    move( me->globalPos() );
+ 	}
++        need_modifiers_check = FALSE;
+ 	return TRUE;
+     } else if ( e->type() == QEvent::MouseButtonRelease ) {
+ 	qApp->removeEventFilter( this );
+@@ -986,9 +1003,11 @@ bool QDragManager::eventFilter( QObject 
+ 	    beingCancelled = FALSE;
+ 	    qApp->exit_loop();
+ 	} else {
+-	    updateMode(ke->stateAfter());
+-	    qt_xdnd_source_sameanswer = QRect(); // force move
+-	    move( QCursor::pos() );
++	    if( updateMode(ke->stateAfter())) {
++	        qt_xdnd_source_sameanswer = QRect(); // force move
++	        move( QCursor::pos() );
++            }
++            need_modifiers_check = FALSE;
+ 	}
+ 	return TRUE; // Eat all key events
+     }
+@@ -1014,10 +1033,10 @@ bool QDragManager::eventFilter( QObject 
+ 
+ 
+ static Qt::ButtonState oldstate;
+-void QDragManager::updateMode( ButtonState newstate )
++bool QDragManager::updateMode( ButtonState newstate )
+ {
+     if ( newstate == oldstate )
+-	return;
++	return false;
+     const int both = ShiftButton|ControlButton;
+     if ( (newstate & both) == both ) {
+ 	global_requested_action = QDropEvent::Link;
+@@ -1041,6 +1060,7 @@ void QDragManager::updateMode( ButtonSta
+ 	}
+     }
+     oldstate = newstate;
++    return true;
+ }
+ 
+ 
+@@ -1707,6 +1727,7 @@ bool QDragManager::drag( QDragObject * o
+     qt_xdnd_source_sameanswer = QRect();
+     move(QCursor::pos());
+     heartbeat = startTimer(200);
++    need_modifiers_check = FALSE;
+ 
+ #ifndef QT_NO_CURSOR
+     qApp->setOverrideCursor( arrowCursor );
+--- src/kernel/qdragobject.h.sav	2003-05-19 22:34:43.000000000 +0200
++++ src/kernel/qdragobject.h	2001-01-01 01:01:00.000000000 +0100
+@@ -248,7 +248,7 @@ private:
+ 
+ private:
+     QDragObject * object;
+-    void updateMode( ButtonState newstate );
++    bool updateMode( ButtonState newstate );
+     void updateCursor();
+ 
+     QWidget * dragSource;
diff -rNu qt-x11-free/patches/0005-qpixmap_mitshm.patch qt-copy/patches/0005-qpixmap_mitshm.patch
--- qt-x11-free/patches/0005-qpixmap_mitshm.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0005-qpixmap_mitshm.patch	2007-02-23 16:06:42.061488000 +0300
@@ -0,0 +1,569 @@
+qt-bugs@ issue : 11790 (part of)
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+NOTE: Needs #define QT_MITSHM in the matching qplatformdefs.h file. This
+    patch does so only for linux-g++ and linux-g++-distcc platforms.
+
+MITSHM extension support for QPixmap<->QImage conversions.
+
+Hello,
+
+ the review and apply the attached patches that improve performance of 
+QImage->QPixmap conversions. They should be applied in order 
+'mitshm','more_local' and 'fast', but they're independent from each other 
+(well, besides merging problems).
+
+ Mitshm patch adds MITSHM extension support for both 
+QPixmap::convertFromImage() and QPixmap::convertToImage(). I've noticed there 
+was some MITSHM support already, turned off by default, but it was used only 
+for QPixmap::xForm() , and it used shared pixmaps (and I'd bet nobody uses 
+it). My patch adds shared ximages support for faster pixmap<->image 
+conversions. Since I don't understand the xForm() code much, and I didn't 
+want to do anything with it, I added three #define's:
+ - QT_MITSHM generally enabling MITSHM support, which should be set in 
+qplatformsdefs.h (or wherever you setup platform specific stuff), it can be 
+enabled at least on Linux
+ - QT_MITSHM_CONVERSIONS - this is for my new code
+ - QT_MITSHM_XFORM - this is for the xForm() code
+ There's one more #define, QT_MITSHM_RMID_IGNORES_REFCOUNT. Glibc 
+documentation of shmctl( ... IPC_RMID ) quite clearly says that the memory 
+segment is freed only after the refcount increased by shmat() and decreased 
+by shmdt() is 0. However, at least according to 
+http://bugs.kde.org/show_bug.cgi?id=27517 , this doesn't happen on other 
+platforms for some strange reason. Such platforms should have this #define if  
+you ever consider supporting MITSHM on them.
+
+ The lower limit for using MITSHM for the image is about 8KiB 
+(width*height*depth > 100*100*32 ). Also, BestOptim in such case doesn't keep 
+the ximage, as the shared ximage is always freed before the function returns 
+(I don't know if it's worth copying it).
+
+ The second patch ('more_local'), in short, does nothing. Besides improving 
+performance by about 10% by making variables more "local", making few of them 
+const, and also making some of them unsigned (this help gcc for some reason).
+
+ The last one, 'fast', moves some if's out of the loops, and handles some most 
+common case specially (15bpp, 16bpp and 32bpp ximage depths). 32bpp case, if 
+the endianess matches, is simply uses memcpy(), for the 15/16bpp depth, 
+variables are replaced directly by matching values, statements are a bit 
+reordered and merged when suitable, and again, in case endianess matches, 
+pixels are written simply as Q_INT16. Most probably it would also help to 
+process two pixels at once and write them as Q_INT32, but I didn't want to 
+complicate the code too much  (later >;)  ).
+
+ The last snippet of 'fast' handles case when xi->bytes_per_line is not equal 
+to width for 8bpp ximage. I'm not actually sure if that can ever happen, but 
+since I've already written it *shrug*.
+
+ The 'more_local' and 'fast' patches change only convertFromImage(), as I 
+don't think convertToImage() is that performance critical (but it's as 
+unoptimized as convertFromImage() was).
+
+ Maybe some numbers. The difference is of course mainly visible with larger 
+pixmaps. The two optimizations alone reduce the time to 50% for 32bpp, to 70% 
+for 16bpp. The MITSHM support, when other patches are already applied too, 
+for 32bpp images saves about 33%. Together, the total time is reduced to 
+about 40% for 32bpp. Imlib probably still beats that, but at least this 
+obsoletes KPixmapIO.
+
+
+--- src/kernel/qpixmap_x11.cpp
++++ src/kernel/qpixmap_x11.cpp
+@@ -37,7 +37,19 @@
+ 
+ // NOT REVISED
+ 
++#include "qplatformdefs.h"
++
++#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
++#undef QT_MITSHM
++#endif
++
++#ifdef QT_MITSHM
++
++// Use the MIT Shared Memory extension for pixmap<->image conversions
++#define QT_MITSHM_CONVERSIONS
++
+ // Uncomment the next line to enable the MIT Shared Memory extension
++// for QPixmap::xForm()
+ //
+ // WARNING:  This has some problems:
+ //
+@@ -45,14 +57,13 @@
+ //    2. Qt does not handle the ShmCompletion message, so you will
+ //        get strange effects if you xForm() repeatedly.
+ //
+-// #define QT_MITSHM
++// #define QT_MITSHM_XFORM
+ 
+-#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
+-#undef QT_MITSHM
++#else
++#undef QT_MITSHM_CONVERSIONS
++#undef QT_MITSHM_XFORM
+ #endif
+ 
+-#include "qplatformdefs.h"
+-
+ #include "qbitmap.h"
+ #include "qpaintdevicemetrics.h"
+ #include "qimage.h"
+@@ -91,7 +102,7 @@ inline static void qSafeXDestroyImage( X
+   MIT Shared Memory Extension support: makes xForm noticeably (~20%) faster.
+  *****************************************************************************/
+ 
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+ 
+ static bool	       xshminit = FALSE;
+ static XShmSegmentInfo xshminfo;
+@@ -173,8 +184,100 @@ static bool qt_create_mitshm_buffer( con
+ //     return FALSE;
+ // }
+ 
+-#endif // QT_MITSHM
++#endif // QT_MITSHM_XFORM
++
++#ifdef QT_MITSHM_CONVERSIONS
++
++static bool qt_mitshm_error = false;
++static int qt_mitshm_errorhandler( Display*, XErrorEvent* )
++{
++    qt_mitshm_error = true;
++    return 0;
++}
++
++static XImage* qt_XShmCreateImage( Display* dpy, Visual* visual, unsigned int depth,
++    int format, int /*offset*/, char* /*data*/, unsigned int width, unsigned int height,
++    int /*bitmap_pad*/, int /*bytes_per_line*/, XShmSegmentInfo* shminfo )
++{
++    if( width * height * depth < 100*100*32 )
++        return NULL;
++    static int shm_inited = -1;
++    if( shm_inited == -1 ) {
++        if( XShmQueryExtension( dpy ))
++            shm_inited = 1;
++        else
++            shm_inited = 0;
++    }
++    if( shm_inited == 0 )
++        return NULL;
++    XImage* xi = XShmCreateImage( dpy, visual, depth, format, NULL, shminfo, width,
++        height );
++    if( xi == NULL )
++        return NULL;
++    shminfo->shmid = shmget( IPC_PRIVATE, xi->bytes_per_line * xi->height,
++        IPC_CREAT|0600);
++    if( shminfo->shmid < 0 ) {
++        XDestroyImage( xi );
++        return NULL;
++    }
++    shminfo->readOnly = False;
++    shminfo->shmaddr = (char*)shmat( shminfo->shmid, 0, 0 );
++    if( shminfo->shmaddr == (char*)-1 ) {
++        XDestroyImage( xi );
++        shmctl( shminfo->shmid, IPC_RMID, 0 );
++        return NULL;
++    }
++    xi->data = shminfo->shmaddr;
++#ifndef QT_MITSHM_RMID_IGNORES_REFCOUNT
++    // mark as deleted to automatically free the memory in case
++    // of a crash (but this doesn't work e.g. on Solaris)
++    shmctl( shminfo->shmid, IPC_RMID, 0 );
++#endif
++    if( shm_inited == 1 ) { // first time
++        XErrorHandler old_h = XSetErrorHandler( qt_mitshm_errorhandler );
++        XShmAttach( dpy, shminfo );
++        shm_inited = 2;
++        XSync( dpy, False );
++        XSetErrorHandler( old_h );
++        if( qt_mitshm_error ) { // oops ... perhaps we are remote?
++            shm_inited = 0;
++            XDestroyImage( xi );
++            shmdt( shminfo->shmaddr );
++#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
++            shmctl( shminfo->shmid, IPC_RMID, 0 );
++#endif    
++            return NULL;
++        }
++    } else
++        XShmAttach( dpy, shminfo );
++    return xi;
++}
++
++static void qt_XShmDestroyImage( XImage* xi, XShmSegmentInfo* shminfo )
++{
++    XShmDetach( QPaintDevice::x11AppDisplay(), shminfo );
++    XDestroyImage( xi );
++    shmdt( shminfo->shmaddr );
++#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
++    shmctl( shminfo->shmid, IPC_RMID, 0 );
++#endif    
++}
++
++static XImage* qt_XShmGetImage( const QPixmap* pix, int format,
++    XShmSegmentInfo* shminfo )
++{
++    XImage* xi = qt_XShmCreateImage( pix->x11Display(), (Visual*)pix->x11Visual(),
++        pix->depth(), format, 0, 0, pix->width(), pix->height(), 32, 0, shminfo );
++    if( xi == NULL )
++        return NULL;
++    if( XShmGetImage( pix->x11Display(), pix->handle(), xi, 0, 0, AllPlanes ) == False ) {
++        qt_XShmDestroyImage( xi, shminfo );
++        return NULL;
++    }
++    return xi;
++}
+ 
++#endif // QT_MITSHM_CONVERSIONS
+ 
+ /*****************************************************************************
+   Internal functions
+@@ -627,9 +730,20 @@ QImage QPixmap::convertToImage() const
+ 	d = 32;					//   > 8  ==> 32
+ 
+     XImage *xi = (XImage *)data->ximage;	// any cached ximage?
+-    if ( !xi )					// fetch data from X server
++#ifdef QT_MITSHM_CONVERSIONS
++    bool mitshm_ximage = false;
++    XShmSegmentInfo shminfo;
++#endif
++    if ( !xi ) {				// fetch data from X server
++#ifdef QT_MITSHM_CONVERSIONS
++        xi = qt_XShmGetImage( this, mono ? XYPixmap : ZPixmap, &shminfo );
++        if( xi ) {
++            mitshm_ximage = true;
++        } else
++#endif
+ 	xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
+ 			mono ? XYPixmap : ZPixmap );
++    }
+     Q_CHECK_PTR( xi );
+     if (!xi)
+         return image; // null image
+@@ -640,15 +754,31 @@ QImage QPixmap::convertToImage() const
+ 		   QImage::LittleEndian : QImage::BigEndian;
+     }
+     image.create( w, h, d, 0, bitOrder );
+-    if ( image.isNull() )			// could not create image
++    if ( image.isNull() ) {			// could not create image
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage )
++            qt_XShmDestroyImage( xi, &shminfo );
++        else
++#endif
++        qSafeXDestroyImage( xi );
+ 	return image;
++    }
+ 
+     const QPixmap* msk = mask();
+     const QPixmap *alf = data->alphapm;
+ 
+     QImage alpha;
+     if (alf) {
+-	XImage *axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
++        XImage* axi;
++#ifdef QT_MITSHM_CONVERSIONS
++        bool mitshm_aximage = false;
++        XShmSegmentInfo ashminfo;
++        axi = qt_XShmGetImage( alf, ZPixmap, &ashminfo );
++        if( axi ) {
++            mitshm_aximage = true;
++        } else
++#endif
++            axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
+ 
+ 	if (axi) {
+ 	    image.setAlphaBuffer( TRUE );
+@@ -662,6 +792,11 @@ QImage QPixmap::convertToImage() const
+ 		src += axi->bytes_per_line;
+ 	    }
+ 
++#ifdef QT_MITSHM_CONVERSIONS
++            if( mitshm_aximage )
++                qt_XShmDestroyImage( axi, &ashminfo );
++            else
++#endif
+ 	    qSafeXDestroyImage( axi );
+ 	}
+     } else if (msk) {
+@@ -804,6 +939,12 @@ QImage QPixmap::convertToImage() const
+ 		  xi->bits_per_pixel );
+ #endif
+ 	image.reset();
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage )
++            qt_XShmDestroyImage( xi, &shminfo );
++        else
++#endif
++            qSafeXDestroyImage( xi );
+ 	return image;
+     }
+ 
+@@ -909,10 +1050,22 @@ QImage QPixmap::convertToImage() const
+ 	delete [] carr;
+     }
+     if ( data->optim != BestOptim ) {		// throw away image data
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage )
++            qt_XShmDestroyImage( xi, &shminfo );
++        else
++#endif
+ 	qSafeXDestroyImage( xi );
+ 	((QPixmap*)this)->data->ximage = 0;
+-    } else					// keep ximage data
++    } else {					// keep ximage data
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage ) { // copy the XImage?
++            qt_XShmDestroyImage( xi, &shminfo );
++            xi = 0;
++        }
++#endif
+ 	((QPixmap*)this)->data->ximage = xi;
++    }
+ 
+     return image;
+ }
+@@ -1085,6 +1238,11 @@ bool QPixmap::convertFromImage( const QI
+     bool    trucol = (visual->c_class == TrueColor || visual->c_class == DirectColor);
+     int	    nbytes = image.numBytes();
+     uchar  *newbits= 0;
++    int newbits_size = 0;
++#ifdef QT_MITSHM_CONVERSIONS
++    bool mitshm_ximage = false;
++    XShmSegmentInfo shminfo;
++#endif
+ 
+     if ( trucol ) {				// truecolor display
+ 	QRgb  pix[256];				// pixel translation table
+@@ -1113,10 +1271,18 @@ bool QPixmap::convertFromImage( const QI
+ 	    }
+ 	}
+ 
++#ifdef QT_MITSHM_CONVERSIONS
++	xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
++	if( xi != NULL ) {
++	    mitshm_ximage = true;
++	    newbits = (uchar*)xi->data;
++	}
++	else
++#endif
+ 	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+-	Q_CHECK_PTR( xi );
+         if (!xi)
+             return false;
++	if( newbits == NULL )
+ 	newbits = (uchar *)malloc( xi->bytes_per_line*h );
+ 	Q_CHECK_PTR( newbits );
+ 	if ( !newbits )				// no memory
+@@ -1323,6 +1489,7 @@ bool QPixmap::convertFromImage( const QI
+ 	}
+ 
+ 	newbits = (uchar *)malloc( nbytes );	// copy image into newbits
++        newbits_size = nbytes;
+ 	Q_CHECK_PTR( newbits );
+ 	if ( !newbits )				// no memory
+ 	    return FALSE;
+@@ -1440,11 +1607,18 @@ bool QPixmap::convertFromImage( const QI
+     }
+ 
+     if ( !xi ) {				// X image not created
++#ifdef QT_MITSHM_CONVERSIONS
++        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
++        if( xi != NULL )
++            mitshm_ximage = true;
++        else
++#endif
+ 	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+ 	if ( xi->bits_per_pixel == 16 ) {	// convert 8 bpp ==> 16 bpp
+ 	    ushort *p2;
+ 	    int	    p2inc = xi->bytes_per_line/sizeof(ushort);
+ 	    ushort *newerbits = (ushort *)malloc( xi->bytes_per_line * h );
++            newbits_size = xi->bytes_per_line * h;
+ 	    Q_CHECK_PTR( newerbits );
+ 	    if ( !newerbits )				// no memory
+ 		return FALSE;
+@@ -1462,6 +1636,14 @@ bool QPixmap::convertFromImage( const QI
+ 		      "(bpp=%d)", xi->bits_per_pixel );
+ #endif
+ 	}
++#ifdef QT_MITSHM_CONVERSIONS
++        if( newbits_size > 0 && mitshm_ximage ) { // need to copy to shared memory
++            memcpy( xi->data, newbits, newbits_size );
++            free( newbits );
++            newbits = (uchar*)xi->data;
++        }
++        else
++#endif
+ 	xi->data = (char *)newbits;
+     }
+ 
+@@ -1495,19 +1677,24 @@ bool QPixmap::convertFromImage( const QI
+ 
+     }
+ 
++#ifdef QT_MITSHM_CONVERSIONS
++    if( mitshm_ximage )
++        XShmPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE ),
++                      xi, 0, 0, 0, 0, w, h, False );
++    else
++#endif
+     XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
+ 	       xi, 0, 0, 0, 0, w, h );
+ 
+-    if ( data->optim != BestOptim ) {		// throw away image
+-	qSafeXDestroyImage( xi );
+-	data->ximage = 0;
+-    } else {					// keep ximage that we created
+-	data->ximage = xi;
+-    }
+     data->w = w;
+     data->h = h;
+     data->d = dd;
+ 
++    XImage* axi = NULL;
++#ifdef QT_MITSHM_CONVERSIONS
++    bool mitshm_aximage = false;
++    XShmSegmentInfo ashminfo;
++#endif
+     if ( image.hasAlphaBuffer() ) {
+ 	QBitmap m;
+ 	m = image.createAlphaMask( conversion_flags );
+@@ -1543,13 +1730,22 @@ bool QPixmap::convertFromImage( const QI
+ 	    data->alphapm->rendhd =
+ 		(HANDLE) XftDrawCreateAlpha( x11Display(), data->alphapm->hd, 8 );
+ 
+-	    XImage *axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
++#ifdef QT_MITSHM_CONVERSIONS
++	    axi = qt_XShmCreateImage( x11Display(), (Visual*)x11Visual(),
++		    8, ZPixmap, 0, 0, w, h, 8, 0, &ashminfo );
++	    if( axi != NULL )
++		mitshm_aximage = true;
++	    else
++#endif
++		axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
+ 				       8, ZPixmap, 0, 0, w, h, 8, 0);
+ 
+ 	    if (axi) {
++		if( axi->data==NULL ) {
+ 		// the data is deleted by qSafeXDestroyImage
+                 axi->data = (char *) malloc(h * axi->bytes_per_line);
+ 		Q_CHECK_PTR( axi->data );
++		}
+                 char *aptr = axi->data;
+ 
+                 if (image.depth() == 32) {
+@@ -1567,14 +1763,48 @@ bool QPixmap::convertFromImage( const QI
+                 }
+ 
+                 GC gc = XCreateGC(x11Display(), data->alphapm->hd, 0, 0);
++ #ifdef QT_MITSHM_CONVERSIONS
++		if( mitshm_aximage )
++		    XShmPutImage( dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h, False );
++		else
++#endif
+                 XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
+                 XFreeGC(x11Display(), gc);
+-		qSafeXDestroyImage(axi);
+ 	    }
+ 	}
+ #endif // QT_NO_XFTFREETYPE
+     }
+ 
++#ifdef QT_MITSHM_CONVERSIONS
++    if( mitshm_ximage || mitshm_aximage )
++        XSync( x11Display(), False ); // wait until processed
++#endif
++
++    if ( data->optim != BestOptim ) {       // throw away image
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage )
++            qt_XShmDestroyImage( xi, &shminfo );
++        else
++#endif
++     qSafeXDestroyImage( xi );
++     data->ximage = 0;
++    } else {      // keep ximage that we created
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_ximage ) { // copy the XImage?
++            qt_XShmDestroyImage( xi, &shminfo );
++            xi = 0;
++        }
++#endif
++     data->ximage = xi;
++    }
++    if( axi ) {
++#ifdef QT_MITSHM_CONVERSIONS
++        if( mitshm_aximage )
++            qt_XShmDestroyImage( axi, &ashminfo );
++        else
++#endif
++        qSafeXDestroyImage(axi);
++    }
+     return TRUE;
+ }
+ 
+@@ -1737,7 +1967,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+ 	return pm;
+     }
+ 
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+     static bool try_once = TRUE;
+     if (try_once) {
+ 	try_once = FALSE;
+@@ -1770,7 +2000,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+ 	dbpl = ((w*bpp+31)/32)*4;
+     dbytes = dbpl*h;
+ 
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+     if ( use_mitshm ) {
+ 	dptr = (uchar *)xshmimg->data;
+ 	uchar fillbyte = bpp == 8 ? white.pixel() : 0xff;
+@@ -1786,7 +2016,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+ 	    memset( dptr, Qt::white.pixel( x11Screen() ), dbytes );
+ 	else
+ 	    memset( dptr, 0xff, dbytes );
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+     }
+ #endif
+ 
+@@ -1817,7 +2047,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+     } else {
+ 	xbpl  = (w*bpp)/8;
+ 	p_inc = dbpl - xbpl;
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+ 	if ( use_mitshm )
+ 	    p_inc = xshmimg->bytes_per_line - xbpl;
+ #endif
+@@ -1854,7 +2084,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+ 	QPixmap pm( w, h );
+ 	pm.data->uninit = FALSE;
+ 	pm.x11SetScreen( x11Screen() );
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+ 	if ( use_mitshm ) {
+ 	    XCopyArea( dpy, xshmpm, pm.handle(), gc, 0, 0, w, h, 0, 0 );
+ 	} else {
+@@ -1863,7 +2093,7 @@ QPixmap QPixmap::xForm( const QWMatrix &
+ 			       ZPixmap, 0, (char *)dptr, w, h, 32, 0 );
+ 	    XPutImage( dpy, pm.handle(), gc, xi, 0, 0, 0, 0, w, h);
+ 	    qSafeXDestroyImage( xi );
+-#if defined(QT_MITSHM)
++#if defined(QT_MITSHM_XFORM)
+ 	}
+ #endif
+ 
+--- mkspecs/linux-g++/qplatformdefs.h
++++ mkspecs/linux-g++/qplatformdefs.h
+@@ -102,5 +102,6 @@
+ #define QT_VSNPRINTF		::vsnprintf
+ #endif
+ 
++#define QT_MITSHM
+ 
+ #endif // QPLATFORMDEFS_H
diff -rNu qt-x11-free/patches/0007-qpixmap_constants.patch qt-copy/patches/0007-qpixmap_constants.patch
--- qt-x11-free/patches/0007-qpixmap_constants.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0007-qpixmap_constants.patch	2007-02-23 02:54:28.146477000 +0300
@@ -0,0 +1,384 @@
+qt-bugs@ issue : 11790 (part of)
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+See 0005-qpixmap_mitshm.patch for details.
+
+
+--- src/kernel/qpixmap_x11.cpp
++++ src/kernel/qpixmap_x11.cpp
+@@ -1123,9 +1123,6 @@ bool QPixmap::convertFromImage( const QI
+ 	    return FALSE;
+ 	int    bppc = xi->bits_per_pixel;
+ 
+-	if ( bppc > 8 && xi->byte_order == LSBFirst )
+-	    bppc++;
+-
+ 	bool contig_bits = n_bits(red_mask) == rbits &&
+                            n_bits(green_mask) == gbits &&
+                            n_bits(blue_mask) == bbits;
+@@ -1174,32 +1171,70 @@ bool QPixmap::convertFromImage( const QI
+ 	    }
+ 	    init=TRUE;
+ 	}
++        
++        enum { BPP8, 
++               BPP16_8_3_M3, BPP16_7_2_M3, BPP16_MSB, BPP16_LSB,
++               BPP24_MSB, BPP24_LSB,
++               BPP32_16_8_0, BPP32_MSB, BPP32_LSB
++        } mode = BPP8;
+ 
+-	for ( uint y=0; y<h; y++ ) {
+-	    uchar* src = image.scanLine( y );
+-	    uchar* dst = newbits + xi->bytes_per_line*y;
+-	    QRgb* p = (QRgb *)src;
++	if ( bppc > 8 && xi->byte_order == LSBFirst )
++	    bppc++;
+ 
+-#define GET_RGB \
+-		int r = qRed  ( *p ); \
+-		int g = qGreen( *p ); \
+-		int b = qBlue ( *p++ ); \
+-		r = red_shift   > 0 \
+-		    ? r << red_shift   : r >> -red_shift; \
+-		g = green_shift > 0 \
+-		    ? g << green_shift : g >> -green_shift; \
+-		b = blue_shift  > 0 \
+-		    ? b << blue_shift  : b >> -blue_shift;
++        int wordsize;
++        bool bigendian;
++        qSysInfo( &wordsize, &bigendian );
++        bool same_msb_lsb = ( xi->byte_order == MSBFirst ) == ( bigendian );
++        
++        if( bppc == 8 ) // 8 bit
++            mode = BPP8;
++        else if( bppc == 16 || bppc == 17 ) { // 16 bit MSB/LSB
++            if( red_shift == 8 && green_shift == 3 && blue_shift == -3
++                && !d8 && same_msb_lsb )
++                mode = BPP16_8_3_M3;
++            else if( red_shift == 7 && green_shift == 2 && blue_shift == -3
++                && !d8 && same_msb_lsb )
++                mode = BPP16_7_2_M3;
++            else
++                mode = bppc == 17 ? BPP16_LSB : BPP16_MSB;
++        } else if( bppc == 24 || bppc == 25 ) { // 24 bit MSB/LSB
++            mode = bppc == 25 ? BPP24_LSB : BPP24_MSB;
++        } else if( bppc == 32 || bppc == 33 ) { // 32 bit MSB/LSB
++            if( red_shift == 16 && green_shift == 8 && blue_shift == 0
++                && !d8 && same_msb_lsb )
++                mode = BPP32_16_8_0;
++            else
++                mode = bppc == 33 ? BPP32_LSB : BPP32_MSB;
++        } else
++	    qFatal("Logic error 3");
+ 
+ #define GET_PIXEL \
+                 int pixel; \
+ 		if ( d8 ) pixel = pix[*src++]; \
+ 		else { \
+-		    GET_RGB \
+-		    pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask) \
++		    int r = qRed  ( *p ); \
++		    int g = qGreen( *p ); \
++		    int b = qBlue ( *p++ ); \
++		    r = red_shift   > 0 \
++		        ? r << red_shift   : r >> -red_shift; \
++		    g = green_shift > 0 \
++		        ? g << green_shift : g >> -green_shift; \
++		    b = blue_shift  > 0 \
++		        ? b << blue_shift  : b >> -blue_shift; \
++		    pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask) \
+ 			    | ~(blue_mask | green_mask | red_mask); \
+ 		}
+ 
++// optimized case - no d8 case, shift only once instead of twice, mask only once instead of twice,
++// use direct values instead of variables, and use only one statement
++// (*p >> 16), (*p >> 8 ) and (*p) are qRed(),qGreen() and qBlue() without masking
++// shifts have to be passed including the shift operator (e.g. '>>3'), because of the direction
++#define GET_PIXEL_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask) \
++                int pixel = ((( *p >> 16 ) red_shift ) & red_mask ) \
++                    | ((( *p >> 8 ) green_shift ) & green_mask ) \
++                    | ((( *p ) blue_shift ) & blue_mask ); \
++                ++p;
++
+ #define GET_PIXEL_DITHER_TC \
+ 		int r = qRed  ( *p ); \
+ 		int g = qGreen( *p ); \
+@@ -1220,91 +1255,177 @@ bool QPixmap::convertFromImage( const QI
+ 		    ? g << green_shift : g >> -green_shift; \
+ 		b = blue_shift  > 0 \
+ 		    ? b << blue_shift  : b >> -blue_shift; \
+-		int pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask);
++		int pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask);
+ 
+-	    if ( dither_tc ) {
+-		uint x;
+-		switch ( bppc ) {
+-		case 16:			// 16 bit MSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL_DITHER_TC
+-			*dst++ = (pixel >> 8);
+-			*dst++ = pixel;
+-		    }
++// again, optimized case
++// can't be optimized that much :(
++#define GET_PIXEL_DITHER_TC_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask, \
++                                rbits,gbits,bbits) \
++		const int thres = D[x%16][y%16]; \
++		int r = qRed  ( *p ); \
++		if ( r <= (255-(1<<(8-rbits))) && ((r<<rbits) & 255) \
++			> thres) \
++		    r += (1<<(8-rbits)); \
++		int g = qGreen( *p ); \
++		if ( g <= (255-(1<<(8-gbits))) && ((g<<gbits) & 255) \
++			> thres) \
++		    g += (1<<(8-gbits)); \
++		int b = qBlue ( *p++ ); \
++		if ( b <= (255-(1<<(8-bbits))) && ((b<<bbits) & 255) \
++			> thres) \
++		    b += (1<<(8-bbits)); \
++                int pixel = (( r red_shift ) & red_mask ) \
++                    | (( g green_shift ) & green_mask ) \
++                    | (( b blue_shift ) & blue_mask );
++
++#define CYCLE(body) \
++	for ( uint y=0; y<h; y++ ) { \
++	    uchar* src = image.scanLine( y ); \
++	    uchar* dst = newbits + xi->bytes_per_line*y; \
++	    QRgb* p = (QRgb *)src; \
++            body \
++        }
++
++        if ( dither_tc ) {
++	    switch ( mode ) {
++                case BPP16_8_3_M3:
++                    CYCLE(
++                        Q_INT16* dst16 = (Q_INT16*)dst;
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_DITHER_TC_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f,5,6,5)
++                            *dst16++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 17:			// 16 bit LSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL_DITHER_TC
+-			*dst++ = pixel;
+-			*dst++ = pixel >> 8;
+-		    }
++                case BPP16_7_2_M3:
++                    CYCLE(
++                        Q_INT16* dst16 = (Q_INT16*)dst;
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_DITHER_TC_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f,5,5,5)
++                            *dst16++ = pixel;
++		        }
++                    )
++		    break;
++		case BPP16_MSB:			// 16 bit MSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_DITHER_TC
++			    *dst++ = (pixel >> 8);
++			    *dst++ = pixel;
++		        }
++                    )
++		    break;
++		case BPP16_LSB:			// 16 bit LSB
++                    CYCLE(
++    		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_DITHER_TC
++			    *dst++ = pixel;
++			    *dst++ = pixel >> 8;
++		        }
++                    )
+ 		    break;
+ 		default:
+ 		    qFatal("Logic error");
+ 		}
+-	    } else {
+-		uint x;
+-		switch ( bppc ) {
+-		case 8:			// 8 bit
+-		    for ( x=0; x<w; x++ ) {
+-			int pixel = pix[*src++];
+-			*dst++ = pixel;
+-		    }
++	} else {
++	    switch ( mode ) {
++		case BPP8:			// 8 bit
++                    CYCLE(
++                    Q_UNUSED(p);
++		        for ( uint x=0; x<w; x++ ) {
++			    int pixel = pix[*src++];
++			    *dst++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 16:			// 16 bit MSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = (pixel >> 8);
+-			*dst++ = pixel;
+-		    }
++                case BPP16_8_3_M3:
++                    CYCLE(
++                        Q_INT16* dst16 = (Q_INT16*)dst;
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f)
++                            *dst16++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 17:			// 16 bit LSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = pixel;
+-			*dst++ = pixel >> 8;
+-		    }
++                case BPP16_7_2_M3:
++                    CYCLE(
++                        Q_INT16* dst16 = (Q_INT16*)dst;
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f)
++                            *dst16++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 24:			// 24 bit MSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = pixel >> 16;
+-			*dst++ = pixel >> 8;
+-			*dst++ = pixel;
+-		    }
++		case BPP16_MSB:			// 16 bit MSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = (pixel >> 8);
++			    *dst++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 25:			// 24 bit LSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = pixel;
+-			*dst++ = pixel >> 8;
+-			*dst++ = pixel >> 16;
+-		    }
++		case BPP16_LSB:			// 16 bit LSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = pixel;
++			    *dst++ = pixel >> 8;
++		        }
++                    )
+ 		    break;
+-		case 32:			// 32 bit MSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = pixel >> 24;
+-			*dst++ = pixel >> 16;
+-			*dst++ = pixel >> 8;
+-			*dst++ = pixel;
+-		    }
++		case BPP24_MSB:			// 24 bit MSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = pixel >> 16;
++			    *dst++ = pixel >> 8;
++			    *dst++ = pixel;
++		        }
++                    )
+ 		    break;
+-		case 33:			// 32 bit LSB
+-		    for ( x=0; x<w; x++ ) {
+-			GET_PIXEL
+-			*dst++ = pixel;
+-			*dst++ = pixel >> 8;
+-			*dst++ = pixel >> 16;
+-			*dst++ = pixel >> 24;
+-		    }
++		case BPP24_LSB:			// 24 bit LSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = pixel;
++			    *dst++ = pixel >> 8;
++			    *dst++ = pixel >> 16;
++		        }
++                    )
+ 		    break;
+-		default:
+-		    qFatal("Logic error 2");
+-		}
+-	    }
+-	}
+-	xi->data = (char *)newbits;
++                case BPP32_16_8_0:
++                    CYCLE(
++                        memcpy( dst, p, w * 4 );
++                    )
++                    break;
++		case BPP32_MSB:			// 32 bit MSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = pixel >> 24;
++			    *dst++ = pixel >> 16;
++			    *dst++ = pixel >> 8;
++			    *dst++ = pixel;
++		        }
++                    )
++		    break;
++		case BPP32_LSB:			// 32 bit LSB
++                    CYCLE(
++		        for ( uint x=0; x<w; x++ ) {
++			    GET_PIXEL
++			    *dst++ = pixel;
++			    *dst++ = pixel >> 8;
++			    *dst++ = pixel >> 16;
++			    *dst++ = pixel >> 24;
++		        }
++                    )
++  		    break;
++  		default:
++  		    qFatal("Logic error 2");
++  	    }
++  	}
++  	xi->data = (char *)newbits;
+     }
+ 
+     if ( d == 8 && !trucol ) {			// 8 bit pixmap
+@@ -1554,15 +1675,24 @@ bool QPixmap::convertFromImage( const QI
+ 
+                 if (image.depth() == 32) {
+                     const int *iptr = (const int *) image.bits();
+-                    int max = w * h;
+-                    while (max--)
+-                        *aptr++ = *iptr++ >> 24; // squirt
++                    if( axi->bytes_per_line == (int)w ) {
++                        int max = w * h;
++                        while (max--)
++                            *aptr++ = *iptr++ >> 24; // squirt
++                    } else {
++                        for (uint i = 0; i < h; ++i ) {
++                            for (uint j = 0; j < w; ++j )
++                                *aptr++ = *iptr++ >> 24; // squirt
++                            aptr += ( axi->bytes_per_line - w );
++                        }
++                    }
+                 } else if (image.depth() == 8) {
+                     const QRgb * const rgb = image.colorTable();
+                     for (uint y = 0; y < h; ++y) {
+                         const uchar *iptr = image.scanLine(y);
+                         for (uint x = 0; x < w; ++x)
+                             *aptr++ = qAlpha(rgb[*iptr++]);
++                        aptr += ( axi->bytes_per_line - w );
+                     }
+                 }
+ 
diff -rNu qt-x11-free/patches/0015-qiconview-finditem.patch qt-copy/patches/0015-qiconview-finditem.patch
--- qt-x11-free/patches/0015-qiconview-finditem.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0015-qiconview-finditem.patch	2003-07-01 18:27:46.000000000 +0400
@@ -0,0 +1,43 @@
+qt-bugs@ issue : 18886
+applied: no
+author: Pascal LÃ©tourneau <pletourn@globetrotter.net>
+
+QIconView::findItem() should always search all ItemContainer to find the best 
+match.
+
+Example:
+
+-----        -----
+|   |        |   |       ItemContainer
+--------------------------------------
+|   |        |   |       boundary
+|   | -----  |   |
+|   | |   |  |   |
+----- -----  -----
+item1 item2  item3
+
+Right now, the focus goes from item1 to item3 when you press Key_Right.
+
+[ Since the mail was sent, I added the diff 'contains -> intersects' ]
+
+Index: src/iconview/qiconview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/iconview/qiconview.cpp,v
+retrieving revision 1.47
+diff -u -3 -p -r1.47 qiconview.cpp
+--- src/iconview/qiconview.cpp	16 May 2003 13:02:38 -0000	1.47
++++ src/iconview/qiconview.cpp	30 May 2003 20:32:34 -0000
+@@ -5200,11 +5201,11 @@ QIconViewItem* QIconView::findItem( Dire
+ 	d->findContainers( dir, relativeTo, searchRect);
+ 
+     cList->first();
+-    while ( cList->current() && !centerMatch ) {
++    while ( cList->current() ) {
+ 	QPtrList<QIconViewItem> &list = (cList->current())->items;
+ 	for ( item = list.first(); item; item = list.next() ) {
+ 	    if ( neighbourItem( dir, relativeTo, item ) &&
+-		 searchRect.contains( item->rect().center() ) &&
++		 searchRect.intersects( item->rect() ) &&
+ 		 item != currentItem() ) {
+  		int ml = (relativeTo - item->rect().center()).manhattanLength();
+ 		if ( centerMatch ) {
diff -rNu qt-x11-free/patches/0016-qiconview-rebuildcontainer.patch qt-copy/patches/0016-qiconview-rebuildcontainer.patch
--- qt-x11-free/patches/0016-qiconview-rebuildcontainer.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0016-qiconview-rebuildcontainer.patch	2003-07-23 23:05:52.000000000 +0400
@@ -0,0 +1,34 @@
+qt-bugs@ issue : 18598
+applied: no
+author: Pascal LÃ©tourneau <pletourn@globetrotter.net>
+
+Sometimes QIconView doesn't paint the top of an icon.
+It's because this part of QIconView::rebuildContainers() is never reached.
+
+...
+if ( d->arrangement == LeftToRight ) {
+        if ( item->y() < c->rect.y() && c->p ) {
+                c = c->p;           <<<<<<<<<<<<<<<<<
+                continue;
+...
+
+
+Index: src/iconview/qiconview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/iconview/qiconview.cpp,v
+retrieving revision 1.47
+diff -u -3 -p -r1.47 qiconview.cpp
+--- src/iconview/qiconview.cpp	16 May 2003 13:02:38 -0000	1.47
++++ src/iconview/qiconview.cpp	30 May 2003 20:32:34 -0000
+@@ -6122,7 +6123,9 @@ void QIconView::rebuildContainers()
+ 	    item->d->container2 = 0;
+ 	    c->items.append( item );
+ 	    item = item->next;
+-	} else if ( c->rect.intersects( item->rect() ) ) {
++	} else if ( c->rect.intersects( item->rect() ) && (
++			( d->arrangement == LeftToRight && item->y() >= c->rect.y() ) ||
++			( d->arrangement == TopToBottom && item->x() >= c->rect.x() ) ) ) {
+ 	    item->d->container1 = c;
+ 	    c->items.append( item );
+ 	    c = c->n;
+
diff -rNu qt-x11-free/patches/0017-qiconview-ctrl_rubber.patch qt-copy/patches/0017-qiconview-ctrl_rubber.patch
--- qt-x11-free/patches/0017-qiconview-ctrl_rubber.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0017-qiconview-ctrl_rubber.patch	2003-07-23 23:04:03.000000000 +0400
@@ -0,0 +1,90 @@
+qt-bugs@ issue : 23919
+applied: no
+author: Pascal LÃ©tourneau <pletourn@globetrotter.net>
+
+This patch modifies the behavior of the rubber selection.
+Now Shift-rubber behaves like the old Ctrl-rubber.
+And now Ctrl-rubber toggles the state of the icons.
+This is more consistant with other iconview (Nautilus, Win Explorer, ...)
+and with Qt itself (Ctrl-click toggle the state of an icon).
+
+Index: src/iconview/qiconview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/iconview/qiconview.cpp,v
+retrieving revision 1.48
+diff -u -3 -p -r1.48 qiconview.cpp
+--- src/iconview/qiconview.cpp	23 Jun 2003 11:48:21 -0000	1.48
++++ src/iconview/qiconview.cpp	1 Jul 2003 16:36:17 -0000
+@@ -257,7 +257,8 @@ public:
+     uint dragging		:1;
+     uint drawActiveSelection	:1;
+     uint inMenuMode		:1;
+-
++    uint controlPressed         :1;
++
+     QIconViewToolTip *toolTip;
+     QPixmapCache maskCache;
+     QPtrDict<QIconViewItem> selectedItems;
+@@ -2726,6 +2727,7 @@ QIconView::QIconView( QWidget *parent, c
+     d->lastItem = 0;
+     d->count = 0;
+     d->mousePressed = FALSE;
++    d->controlPressed = FALSE;
+     d->selectionMode = Single;
+     d->currentItem = 0;
+     d->highlightedItem = 0;
+@@ -3288,9 +3290,18 @@ void QIconView::doAutoScroll()
+ 	    alreadyIntersected = TRUE;
+ 	    QIconViewItem *item = c->items.first();
+ 	    for ( ; item; item = c->items.next() ) {
+-		if ( d->selectedItems.find( item ) )
+-		    continue;
+-		if ( !item->intersects( nr ) ) {
++               if ( d->selectedItems.find( item ) ) {
++                   if ( item->intersects( nr ) && item->isSelected() && d->controlPressed ) {
++                       item->setSelected( FALSE );
++                       changed = TRUE;
++                       rr = rr.unite( item->rect() );
++                   } else if ( !item->intersects( nr ) && !item->isSelected() && d->controlPressed ) {
++                       item->setSelected( TRUE, TRUE );
++                       changed = TRUE;
++                       rr = rr.unite( item->rect() );
++                   } else
++                       continue;
++               } else if ( !item->intersects( nr ) ) {
+ 		    if ( item->isSelected() ) {
+ 			item->setSelected( FALSE );
+ 			changed = TRUE;
+@@ -4480,7 +4491,7 @@ void QIconView::contentsMousePressEventE
+ 	    }
+ 	}
+     } else if ( ( d->selectionMode != Single || e->button() == RightButton )
+-		&& !( e->state() & ControlButton ) )
++		&& !( e->state() & ControlButton ) && !( e->state() & ShiftButton ) )
+ 	selectAll( FALSE );
+ 
+     setCurrentItem( item );
+@@ -4491,12 +4502,11 @@ void QIconView::contentsMousePressEventE
+ 	    d->tmpCurrentItem = d->currentItem;
+ 	    d->currentItem = 0;
+ 	    repaintItem( d->tmpCurrentItem );
+-	    if ( d->rubber )
+-		delete d->rubber;
+-	    d->rubber = 0;
++	    delete d->rubber;
+ 	    d->rubber = new QRect( e->x(), e->y(), 0, 0 );
+ 	    d->selectedItems.clear();
+-	    if ( ( e->state() & ControlButton ) == ControlButton ) {
++	    if ( ( e->state() & ControlButton ) == ControlButton ||
++	         ( e->state() & ShiftButton ) == ShiftButton ) {
+ 		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
+ 		    if ( i->isSelected() )
+ 			d->selectedItems.insert( i, i );
+@@ -4504,6 +4514,7 @@ void QIconView::contentsMousePressEventE
+ 	}
+ 
+ 	d->mousePressed = TRUE;
++	d->controlPressed = ( ( e->state() & ControlButton ) == ControlButton );
+     }
+ 
+  emit_signals:
diff -rNu qt-x11-free/patches/0020-designer-deletetabs.patch qt-copy/patches/0020-designer-deletetabs.patch
--- qt-x11-free/patches/0020-designer-deletetabs.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0020-designer-deletetabs.patch	2003-07-17 20:26:03.000000000 +0400
@@ -0,0 +1,76 @@
+qt-bugs@ issue : N26525
+applied: no
+author: Thomas Zander <zander@kde.org>
+
+it is possible to remove all tabs from a QTabWidget in the 'object explorer'.
+
+After inserting a new tabWidget I normally get 2 tabs. Using
+the popup menu on the widget itself a delete is not present when there
+is just one tab left. In other words; I can't delete all tabs.
+
+The popup menu presented on the 'object explorer' toolbar does not do any
+checking on the amount of tabs present; it is possible to delete all tabs
+from there.
+
+To reproduce;
+    - Open new document.
+    - Insert QTabWidget.
+    - Press with RMB on the just inserted tabWidget and press 'delete page'
+    - Open the same popup again; notice the missing 'delete page' entry.
+
+    - go to the 'object explorer' toolbar and make sure it is on the
+      'objects' tab.
+    - Press with the RMB on the QTabWidget name.
+    - Press 'delete page' and the last page is deleted.
+
+Solution; on every show of the popup check if delete is possible and enable
+correctly.
+
+Index: tools/designer/designer/hierarchyview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/tools/tools/designer/designer/hierarchyview.cpp,v
+retrieving revision 1.20
+diff -u -3 -p -b -r1.20 hierarchyview.cpp
+--- tools/designer/designer/hierarchyview.cpp	23 Jun 2003 11:49:05 -0000	1.20
++++ tools/designer/designer/hierarchyview.cpp	12 Jul 2003 17:09:29 -0000
+@@ -599,6 +599,7 @@ void HierarchyList::showRMBMenu( QListVi
+ 		    formWindow->mainWindow()->setupTabWidgetHierarchyMenu(
+ 				  this, SLOT( addTabPage() ),
+ 				  SLOT( removeTabPage() ) );
++	    tabWidgetMenu->setItemEnabled(MainWindow::POPUP_REMOVE_PAGE_ID, ((QDesignerTabWidget*)w )->count() > 1);
+ 	    tabWidgetMenu->popup( p );
+ 	}
+     }
+Index: tools/designer/designer/mainwindow.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/tools/tools/designer/designer/mainwindow.cpp,v
+retrieving revision 1.33
+diff -u -3 -p -b -r1.33 mainwindow.cpp
+--- tools/designer/designer/mainwindow.cpp	23 Jun 2003 11:49:06 -0000	1.33
++++ tools/designer/designer/mainwindow.cpp	12 Jul 2003 17:09:31 -0000
+@@ -2419,8 +2419,8 @@ QPopupMenu *MainWindow::setupTabWidgetHi
+ {
+     QPopupMenu *menu = new QPopupMenu( parent );
+ 
+-    menu->insertItem( tr( "Add Page" ), parent, addSlot );
+-    menu->insertItem( tr( "Delete Page" ), parent, removeSlot );
++    menu->insertItem( tr( "Add Page" ), parent, addSlot, 0, POPUP_REMOVE_PAGE_ID+1 );
++    menu->insertItem( tr( "Delete Page" ), parent, removeSlot, 0, POPUP_REMOVE_PAGE_ID );
+     menu->insertSeparator();
+     actionEditCut->addTo( menu );
+     actionEditCopy->addTo( menu );
+Index: tools/designer/designer/mainwindow.h
+===================================================================
+RCS file: /home/kde/qt-copy/tools/tools/designer/designer/mainwindow.h,v
+retrieving revision 1.15
+diff -u -3 -p -b -r1.15 mainwindow.h
+--- tools/designer/designer/mainwindow.h	16 May 2003 13:03:27 -0000	1.15
++++ tools/designer/designer/mainwindow.h	12 Jul 2003 17:09:31 -0000
+@@ -107,6 +107,7 @@ public:
+ 
+     QPopupMenu *setupNormalHierarchyMenu( QWidget *parent );
+     QPopupMenu *setupTabWidgetHierarchyMenu( QWidget *parent, const char *addSlot, const char *removeSlot );
++    static const int POPUP_REMOVE_PAGE_ID = 1;
+ 
+     FormWindow *openFormWindow( const QString &fn, bool validFileName = TRUE, FormFile *ff = 0 );
+     bool isCustomWidgetUsed( MetaDataBase::CustomWidget *w );
diff -rNu qt-x11-free/patches/0032-fix_rotated_randr.diff qt-copy/patches/0032-fix_rotated_randr.diff
--- qt-x11-free/patches/0032-fix_rotated_randr.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0032-fix_rotated_randr.diff	2005-07-20 16:52:07.061790000 +0400
@@ -0,0 +1,21 @@
+qt-bugs@ issue : N34454
+bugs.kde.org number : 67101, 101516
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+This patch replaces the old #0032 patch.
+The real problem is https://bugs.freedesktop.org/show_bug.cgi?id=2965 ,
+so this patch is actually just a workaround.
+
+--- src/kernel/qapplication_x11.cpp.sav	2005-04-08 16:52:58.000000000 +0200
++++ src/kernel/qapplication_x11.cpp	2005-04-11 13:09:46.000000000 +0200
+@@ -3399,7 +3399,8 @@ int QApplication::x11ProcessEvent( XEven
+ #endif
+ 
+ #ifndef QT_NO_XRANDR
+-    if (event->type == xrandr_eventbase + RRScreenChangeNotify) {
++    if (event->type == xrandr_eventbase + RRScreenChangeNotify
++	|| ( event->type == ConfigureNotify && event->xconfigure.window == QPaintDevice::x11AppRootWindow())) {
+ 	// update Xlib internals with the latest screen configuration
+ 	XRRUpdateConfiguration(event);
+ 
diff -rNu qt-x11-free/patches/0035-qvaluelist-streaming-operator.patch qt-copy/patches/0035-qvaluelist-streaming-operator.patch
--- qt-x11-free/patches/0035-qvaluelist-streaming-operator.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0035-qvaluelist-streaming-operator.patch	2004-01-28 18:18:46.000000000 +0300
@@ -0,0 +1,27 @@
+qt-bugs@ issue: 40192
+applied: no
+author: Frerich Raabe <raabe@kde.org>
+
+This patch should fix QValueList's streaming operator>> for cases where
+the stream operates on a byte array smaller than a Q_UINT32 (for instance,
+QByteArray objects which are 0-3 bytes in size). It used to read one bogus
+item because the loop would get executed once even if reading the 'c'
+variable failed.
+
+--- src/tools/qvaluelist.h.orig	2004-01-27 21:10:52.000000000 +0000
++++ src/tools/qvaluelist.h	2004-01-27 21:11:35.000000000 +0000
+@@ -636,13 +636,11 @@
+     l.clear();
+     Q_UINT32 c;
+     s >> c;
+-    for( Q_UINT32 i = 0; i < c; ++i )
++    for( Q_UINT32 i = 0; i < c && !s.atEnd(); ++i )
+     {
+ 	T t;
+ 	s >> t;
+ 	l.append( t );
+-	if ( s.atEnd() )
+-	    break;
+     }
+     return s;
+ }
diff -rNu qt-x11-free/patches/0036-qprogressbar-optimization.patch qt-copy/patches/0036-qprogressbar-optimization.patch
--- qt-x11-free/patches/0036-qprogressbar-optimization.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0036-qprogressbar-optimization.patch	2004-01-30 16:18:37.000000000 +0300
@@ -0,0 +1,126 @@
+qt-bugs@ issue: 40356
+applied: no
+author: Frerich Raabe <raabe@kde.org>
+
+This optimization makes QProgressBar::setProgress() only repaint itself if
+stepping to the new progress would cause a graphical change. This means
+that for a width W and a total number of steps S, it will repaint itself
+'W' times (every 'S/W' steps) instead of 'S' times (every step) as it is right
+now.
+
+--- src/widgets/qprogressbar.h.orig	2004-01-30 11:10:24.000000000 +0000
++++ src/widgets/qprogressbar.h	2004-01-29 22:24:06.000000000 +0000
+@@ -61,6 +61,7 @@
+ public:
+     QProgressBar( QWidget* parent=0, const char* name=0, WFlags f=0 );
+     QProgressBar( int totalSteps, QWidget* parent=0, const char* name=0, WFlags f=0 );
++    virtual ~QProgressBar();
+ 
+     int		totalSteps() const;
+     int		progress()   const;
+@@ -91,6 +92,7 @@
+     virtual bool setIndicator( QString & progress_str, int progress,
+ 			       int totalSteps );
+     void styleChange( QStyle& );
++    bool	requireRepaint( int newProgress ) const;
+ 
+ private:
+     int		total_steps;
+--- src/widgets/qprogressbar.cpp.orig	2004-01-30 11:10:24.000000000 +0000
++++ src/widgets/qprogressbar.cpp	2004-01-30 11:13:03.000000000 +0000
+@@ -47,6 +47,14 @@
+ #endif
+ #include <limits.h>
+ 
++class QProgressBarPrivate
++{
++    public:
++	QProgressBarPrivate() : last_painted_progress( 0 ) { }
++
++    int last_painted_progress;
++};
++
+ /*!
+     \class QProgressBar qprogressbar.h
+     \brief The QProgressBar widget provides a horizontal progress bar.
+@@ -99,7 +107,7 @@
+       center_indicator( TRUE ),
+       auto_indicator( TRUE ),
+       percentage_visible( TRUE ),
+-      d( 0 )
++      d( new QProgressBarPrivate )
+ {
+     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
+     initFrame();
+@@ -130,12 +138,20 @@
+       center_indicator( TRUE ),
+       auto_indicator( TRUE ),
+       percentage_visible( TRUE ),
+-      d( 0 )
++      d( new QProgressBarPrivate )
+ {
+     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
+     initFrame();
+ }
+ 
++/*!
++    Destroys the object and frees any allocated ressources.
++*/
++
++QProgressBar::~QProgressBar()
++{
++    delete d;
++}
+ 
+ /*!
+     Reset the progress bar. The progress bar "rewinds" and shows no
+@@ -188,11 +204,16 @@
+ 	 progress < 0 || ( ( progress > total_steps ) && total_steps ) )
+ 	return;
+ 
++    const bool needRepaint = isVisible() && requireRepaint( progress );
++
+     progress_val = progress;
+ 
+     setIndicator( progress_str, progress_val, total_steps );
+ 
+-    repaint( FALSE );
++    if ( needRepaint ) {
++	repaint( FALSE );
++	d->last_painted_progress = progress;
++    }
+ 
+ #if defined(QT_ACCESSIBILITY_SUPPORT)
+     QAccessible::updateAccessibility( this, 0, QAccessible::ValueChanged );
+@@ -318,6 +339,31 @@
+     QFrame::styleChange( old );
+ }
+ 
++/*!
++    This method returns whether changing the progress to the \a newValue
++    would require a repaint of the progress bar. This allows efficient
++    repainting.
++*/
++bool QProgressBar::requireRepaint( int newProgress ) const
++{
++    if ( newProgress == progress_val ||
++	 newProgress == d->last_painted_progress ) {
++	return false;
++    }
++
++    const int width = contentsRect().width();
++    if ( width == 0 ) {
++	return false;
++    }
++
++    float progressPerPixel = 1.0;
++    if ( total_steps > width ) {
++	progressPerPixel = float( total_steps ) / float( width );
++    }
++
++    const int delta = d->last_painted_progress - newProgress;
++    return QABS( delta ) >= progressPerPixel;
++}
+ 
+ /*!
+     This method is called to generate the text displayed in the center
diff -rNu qt-x11-free/patches/0038-dragobject-dont-prefer-unknown.patch qt-copy/patches/0038-dragobject-dont-prefer-unknown.patch
--- qt-x11-free/patches/0038-dragobject-dont-prefer-unknown.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0038-dragobject-dont-prefer-unknown.patch	2004-03-04 13:17:52.000000000 +0300
@@ -0,0 +1,57 @@
+qt-bugs@ issue : 38642
+bugs.kde.org number : 71084
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+Hello,
+
+ start Mozilla, go e.g. to http://kde.org, start KWrite (or basically any Qt 
+app that accepts text drops), select 'Conquer your Desktop!', and try to 
+drag&drop it onto KWrite. The only text pasted should be 'm'.
+
+ I don't know much the related mimetype and encoding stuff, so I'm unsure 
+whose fault this actually is. The text drag is provided as a lot of 
+text/something targets, to list some text/_moz_htmlinfo, text/x-moz-url, 
+text/unicode and similar. The problem is, Kate uses QTextDrag::decode() with 
+no subtype specified, probably with the intention that as Kate is a text 
+editor, it can accept any text pasted. And since the first target provided by 
+mozilla is text/x-moz-url, (which moreover seems to be encoded as 16bit 
+unicode), the text dropped is completely wrong. You can easily see all 
+targets provided by Mozilla with see_mime.patch applied.
+
+ Solution #1: Say that Kate (any pretty much everybody else expecting text) 
+should say "plain" as the subtype. In such case, I suggest you drop the 
+QTextDrag::decode() variant with no subtype specified, and stress more the 
+fact that not specifying a subtype can result in a lot of rubbish. It's 
+simply too tempting to leave the subtype empty and try to accept anything.
+
+ Solution #2: When trying to accept anything, try to get useful data. Which 
+means either sorting the subtypes available somehow, checking only the ones 
+Qt knows.
+
+ To me, #1 seems to be a better choice, or possibly at least something like 
+the attached QTextDrag patch, which simply always tries first "plain" subtype 
+if none is specified. With this patch, Mozilla even works (that's irony, of 
+course, Mozilla still pastes the text/plain text as HTML, but at least now it 
+pastes something where it's easy to point at the offender).
+
+
+--- src/kernel/qdragobject.cpp.sav	2004-01-06 19:24:35.000000000 +0100
++++ src/kernel/qdragobject.cpp	2004-01-06 19:47:01.000000000 +0100
+@@ -844,6 +844,16 @@ bool QTextDrag::decode( const QMimeSourc
+ {
+     if(!e)
+ 	return FALSE;
++        
++    // when subtype is not specified, try text/plain first, otherwise this may read
++    // things like text/x-moz-url even though better targets are available
++    if( subtype.isNull()) {
++        QCString subtmp = "plain";
++        if( decode( e, str, subtmp )) {
++            subtype = subtmp;
++            return true;
++        }
++    }
+ 
+     if ( e->cacheType == QMimeSource::Text ) {
+ 	str = *e->cache.txt.str;
diff -rNu qt-x11-free/patches/0044-qscrollview-windowactivate-fix.diff qt-copy/patches/0044-qscrollview-windowactivate-fix.diff
--- qt-x11-free/patches/0044-qscrollview-windowactivate-fix.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0044-qscrollview-windowactivate-fix.diff	2004-04-05 14:50:24.000000000 +0400
@@ -0,0 +1,38 @@
+qt-bugs@ issue : N45716
+applied: no
+author: Enrico Ros <eros.kde@email.it>
+
+QScrollView unwanted repaint fix.
+
+This fixes the 'flashing' konqueror window on activation / deactivation by
+saving 1 unwanted repaint (when konqueror window has background).
+I tracked down to the problem to the internal QViewportWidget of the
+QScrollView class.
+
+When a window is activated the activation event is recursively propagated
+to all childs triggering the windowActivationChange() functions in the
+widget it passes by.
+What happens when the event gets to the Viewport?
+At this point the event has already been handled by windowActivationChange()
+of the parent widget (a QIconView for example) and has then been propagated
+to the Viewport that will handle it with the default
+QWidget::windowActivationChange implementation, maybe raising an unwanted
+update(); so here we stop the event.
+As an addition: if the parent reimplements the windowActivationChange()
+function, mainly to block the update, it won't be happy if the child will
+trigger the update. If the parent do not reimplement the function il will
+inherits the default implementation and there is no need for the viewport's
+one.
+
+--- src/widgets/qscrollview.cpp.orig	2004-03-29 10:17:04.000000000 +0000
++++ src/widgets/qscrollview.cpp	2004-03-30 16:40:07.599978320 +0000
+@@ -1551,6 +1551,9 @@
+         case QEvent::LayoutHint:
+             d->autoResizeHint(this);
+             break;
++        case QEvent::WindowActivate:
++        case QEvent::WindowDeactivate:
++            return TRUE;
+         default:
+             break;
+         }
diff -rNu qt-x11-free/patches/0046-qiconview-no-useless-scrollbar.diff qt-copy/patches/0046-qiconview-no-useless-scrollbar.diff
--- qt-x11-free/patches/0046-qiconview-no-useless-scrollbar.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0046-qiconview-no-useless-scrollbar.diff	2004-04-19 12:21:57.000000000 +0400
@@ -0,0 +1,150 @@
+qt-bugs@ issue: N46490
+bugs.kde.org number: 69589
+applied: no
+author: Benoit Walter <b.walter@free.fr>
+
+Remove unnecessary scrollbar that may appear.
+
+Test case (using konqueror icon view):
+- The first icons are being shown (no scrollbar yet)
+- When there is no space left, a vertical scrollbar is needed
+- The vertical scrollbar may cover the right edge of the icons
+(in the last column) => an horizontal scrollbar is needed :-(
+
+Solution:
+When using ScrollBarMode::Auto, prevent Qt from drawing icons on the
+scrollbar area (before the scrollbar is shown).
+
+Related to KDE bug #69589
+
+Index: qiconview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/iconview/qiconview.cpp,v
+retrieving revision 1.54
+diff -u -3 -p -r1.54 qiconview.cpp
+--- src/iconview/qiconview.cpp	2 Mar 2004 12:50:31 -0000	1.54
++++ src/iconview/qiconview.cpp	12 Apr 2004 10:07:28 -0000
+@@ -1060,7 +1060,7 @@ void QIconViewItem::setText( const QStri
+ 
+     if ( view ) {
+ 	if ( QRect( view->contentsX(), view->contentsY(),
+-		    view->visibleWidth(), view->visibleHeight() ).
++		    view->visibleWidthSB(), view->visibleHeightSB() ).
+ 	     intersects( oR ) )
+ 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+ 				   oR.width() + 2, oR.height() + 2, FALSE );
+@@ -1104,7 +1104,7 @@ void QIconViewItem::setPixmap( const QPi
+ 
+     if ( view ) {
+ 	if ( QRect( view->contentsX(), view->contentsY(),
+-		    view->visibleWidth(), view->visibleHeight() ).
++		    view->visibleWidthSB(), view->visibleHeightSB() ).
+ 	     intersects( oR ) )
+ 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+ 				   oR.width() + 2, oR.height() + 2, FALSE );
+@@ -1140,7 +1140,7 @@ void QIconViewItem::setPicture( const QP
+ 
+     if ( view ) {
+ 	if ( QRect( view->contentsX(), view->contentsY(),
+-		    view->visibleWidth(), view->visibleHeight() ).
++		    view->visibleWidthSB(), view->visibleHeightSB() ).
+ 	     intersects( oR ) )
+ 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+ 				   oR.width() + 2, oR.height() + 2, FALSE );
+@@ -1200,7 +1200,7 @@ void QIconViewItem::setPixmap( const QPi
+ 
+ 	    if ( view ) {
+ 		if ( QRect( view->contentsX(), view->contentsY(),
+-			    view->visibleWidth(), view->visibleHeight() ).
++			    view->visibleWidthSB(), view->visibleHeightSB() ).
+ 		     intersects( oR ) )
+ 		    view->repaintContents( oR.x() - 1, oR.y() - 1,
+ 					   oR.width() + 2, oR.height() + 2, FALSE );
+@@ -5448,8 +5448,8 @@ void QIconView::insertInGrid( QIconViewI
+ 	}
+ 	item->dirty = FALSE;
+     } else {
+-	QRegion r( QRect( 0, 0, QMAX( contentsWidth(), visibleWidth() ),
+-			  QMAX( contentsHeight(), visibleHeight() ) ) );
++	QRegion r( QRect( 0, 0, QMAX( contentsWidth(), visibleWidthSB() ),
++			  QMAX( contentsHeight(), visibleHeightSB() ) ) );
+ 
+ 	QIconViewItem *i = d->firstItem;
+ 	int y = -1;
+@@ -5707,7 +5707,7 @@ QIconViewItem *QIconView::makeRowLayout(
+ 	    QIconViewItem *item = begin;
+ 	    for (;;) {
+ 		x += d->spacing + item->width();
+-		if ( x > visibleWidth() && item != begin ) {
++		if ( x > visibleWidthSB() && item != begin ) {
+ 		    item = item->prev;
+ 		    break;
+ 		}
+@@ -5732,7 +5732,7 @@ QIconViewItem *QIconView::makeRowLayout(
+ 		int x;
+ 		if ( item == begin ) {
+ 		    if ( reverse )
+-			x = visibleWidth() - d->spacing - item->width();
++			x = visibleWidthSB() - d->spacing - item->width();
+ 		    else
+ 			x = d->spacing;
+ 		} else {
+@@ -5768,7 +5768,7 @@ QIconViewItem *QIconView::makeRowLayout(
+ 		    i += r;
+ 		    x = i * d->rastX + sp * d->spacing;
+ 		}
+-		if ( x > visibleWidth() && item != begin ) {
++		if ( x > visibleWidthSB() && item != begin ) {
+ 		    item = item->prev;
+ 		    break;
+ 		}
+@@ -5831,7 +5831,7 @@ QIconViewItem *QIconView::makeRowLayout(
+ 	    QIconViewItem *item = begin;
+ 	    for (;;) {
+ 		y += d->spacing + item->height();
+-		if ( y > visibleHeight() && item != begin ) {
++		if ( y > visibleHeightSB() && item != begin ) {
+ 		    item = item->prev;
+ 		    break;
+ 		}
+@@ -6378,4 +6378,24 @@ bool QIconView::isRenaming() const
+ #endif
+ }
+ 
++int QIconView::visibleWidthSB() const
++{
++    if ( vScrollBarMode() != Auto )
++        return visibleWidth();
++    
++    int offset = verticalScrollBar()->isVisible() ? 0
++        : style().pixelMetric( QStyle::PM_ScrollBarExtent, verticalScrollBar() );
++    return QMAX( 0, visibleWidth() - offset );
++}
++
++int QIconView::visibleHeightSB() const
++{
++    if ( hScrollBarMode() != Auto )
++        return visibleHeight();
++    
++    int offset = horizontalScrollBar()->isVisible() ? 0
++        : style().pixelMetric( QStyle::PM_ScrollBarExtent, horizontalScrollBar() );
++    return QMAX( 0, visibleHeight() - offset );
++}
++        
+ #endif // QT_NO_ICONVIEW
+Index: qiconview.h
+===================================================================
+RCS file: /home/kde/qt-copy/src/iconview/qiconview.h,v
+retrieving revision 1.35
+diff -u -3 -p -r1.35 qiconview.h
+--- src/iconview/qiconview.h	16 May 2003 13:02:38 -0000	1.35
++++ src/iconview/qiconview.h	12 Apr 2004 10:07:58 -0000
+@@ -496,6 +496,8 @@ private:
+ 			const QPoint &relativeTo,
+ 			const QIconViewItem *item ) const;
+     QBitmap mask( QPixmap *pix ) const;
++    int visibleWidthSB() const;
++    int visibleHeightSB() const;
+ 
+     QIconViewPrivate *d;
+ 
diff -rNu qt-x11-free/patches/0047-fix-kmenu-width.diff qt-copy/patches/0047-fix-kmenu-width.diff
--- qt-x11-free/patches/0047-fix-kmenu-width.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0047-fix-kmenu-width.diff	2004-08-11 18:51:49.000000000 +0400
@@ -0,0 +1,25 @@
+qt-bugs@ issue: N46882
+bugs.kde.org number: 77545
+applied: no
+author: Stephan Binner <binner@kde.org>
+
+Fix wrong K menu width for the case of enabled side pixmap and a menu title
+(like "Recently Used Applications") being longer than every other entry.
+
+Solution: Respect PanelKMenu::setMaximumSize() as up to Qt 3.2.3
+
+Index: src/widgets/qpopupmenu.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/widgets/qpopupmenu.cpp,v
+retrieving revision 1.60
+diff -u -3 -p -b -r1.60 qpopupmenu.cpp
+--- src/widgets/qpopupmenu.cpp	29 Apr 2004 22:31:28 -0000	1.60
++++ src/widgets/qpopupmenu.cpp	30 Apr 2004 01:11:59 -0000
+@@ -2531,7 +2531,7 @@ QSize QPopupMenu::sizeHint() const
+ 
+     QPopupMenu* that = (QPopupMenu*) this;
+     //We do not need a resize here, just the sizeHint..
+-    return that->updateSize(FALSE, FALSE).expandedTo( QApplication::globalStrut() );
++    return that->updateSize(FALSE).expandedTo( QApplication::globalStrut() );
+ }
+
diff -rNu qt-x11-free/patches/0048-qclipboard_hack_80072.patch qt-copy/patches/0048-qclipboard_hack_80072.patch
--- qt-x11-free/patches/0048-qclipboard_hack_80072.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0048-qclipboard_hack_80072.patch	2004-05-13 13:42:04.000000000 +0400
@@ -0,0 +1,48 @@
+qt-bugs@ issue : none, probably even won't be
+bugs.kde.org number : 80072
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+A crude hack for KDE #80072. No good idea how to fix it properly yet :(.
+
+--- src/kernel/qclipboard_x11.cpp.sav	2004-04-30 12:00:06.000000000 +0200
++++ src/kernel/qclipboard_x11.cpp	2004-05-09 21:18:10.269264304 +0200
+@@ -109,6 +109,7 @@ static int pending_timer_id = 0;
+ static bool pending_clipboard_changed = FALSE;
+ static bool pending_selection_changed = FALSE;
+ 
++Q_EXPORT bool qt_qclipboard_bailout_hack = false;
+ 
+ // event capture mechanism for qt_xclb_wait_for_event
+ static bool waiting_for_data = FALSE;
+@@ -453,6 +454,15 @@ static int qt_xclb_event_filter(XEvent *
+     return 0;
+ }
+ 
++static bool selection_request_pending = false;
++
++static Bool check_selection_request_pending( Display*, XEvent* e, XPointer )
++    {
++    if( e->type == SelectionRequest && e->xselectionrequest.owner == owner->winId())
++        selection_request_pending = true;
++    return False;
++    }
++
+ bool qt_xclb_wait_for_event( Display *dpy, Window win, int type, XEvent *event,
+ 			     int timeout )
+ {
+@@ -504,6 +514,14 @@ bool qt_xclb_wait_for_event( Display *dp
+     do {
+         if ( XCheckTypedWindowEvent(dpy,win,type,event) )
+ 	    return TRUE;
++        if( qt_qclipboard_bailout_hack ) {
++            XEvent dummy;
++            selection_request_pending = false;
++            if ( owner != NULL )
++                XCheckIfEvent(dpy,&dummy,check_selection_request_pending,NULL);
++            if( selection_request_pending )
++	        return TRUE;
++        }
+ 
+ 	now = QTime::currentTime();
+ 	if ( started > now )			// crossed midnight
diff -rNu qt-x11-free/patches/0049-qiconview-rubber_on_move.diff qt-copy/patches/0049-qiconview-rubber_on_move.diff
--- qt-x11-free/patches/0049-qiconview-rubber_on_move.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0049-qiconview-rubber_on_move.diff	2004-05-30 21:09:28.000000000 +0400
@@ -0,0 +1,114 @@
+qt-bugs@ issue : none 
+applied: no
+author: Enrico Ros <eros.kde@email.it>
+
+Unwanted toggling QIconViewItem focus on click.
+
+This fixes the 'flashing' icon when clicking repeatedly on a QIconView or
+derivates (ie KIconView, KonqIconViewWidget, the KDesktop and so on..).
+The current behavior considers that if not over an icon, the user is
+clicking down to perform icons selection (with the rubberband).
+This is not always true, since a click might be used to give focus to a 
+window or unselect some icons.
+
+How this is fixed: when clicking down the mouse a flag is set. If the pointer
+is moved on the iconview with the button held down, then (and only at that
+moment) the rubber is created. Now a selection operation (the one done with
+the rubber) begins when moving the mouse and not only when clicking on the
+empty space.
+
+--- src.orig/iconview/qiconview.cpp	2004-05-05 18:55:55.471057880 +0000
++++ src/iconview/qiconview.cpp	2004-05-30 18:24:16.311014024 +0000
+@@ -236,6 +236,7 @@
+     QPoint dragStartPos;
+     QFontMetrics *fm;
+     int minLeftBearing, minRightBearing;
++    int rubberStartX, rubberStartY;
+ 
+     uint mousePressed		:1;
+     uint cleared		:1;
+@@ -255,6 +256,7 @@
+     uint firstSizeHint : 1;
+     uint showTips		:1;
+     uint pressedSelected	:1;
++    uint canStartRubber		:1;
+     uint dragging		:1;
+     uint drawActiveSelection	:1;
+     uint inMenuMode		:1;
+@@ -2733,6 +2735,7 @@
+     d->currentItem = 0;
+     d->highlightedItem = 0;
+     d->rubber = 0;
++    d->canStartRubber = FALSE;
+     d->scrollTimer = 0;
+     d->startDragItem = 0;
+     d->tmpCurrentItem = 0;
+@@ -4501,29 +4504,20 @@
+ 
+     setCurrentItem( item );
+ 
++    d->canStartRubber = FALSE;
+     if ( e->button() == LeftButton ) {
+-	if ( !item && ( d->selectionMode == Multi ||
+-				  d->selectionMode == Extended ) ) {
+-	    d->tmpCurrentItem = d->currentItem;
+-	    d->currentItem = 0;
+-	    repaintItem( d->tmpCurrentItem );
+-	    delete d->rubber;
+-	    d->rubber = new QRect( e->x(), e->y(), 0, 0 );
+-	    d->selectedItems.clear();
+-	    if ( ( e->state() & ControlButton ) == ControlButton ||
+-	         ( e->state() & ShiftButton ) == ShiftButton ) {
+-		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
+-		    if ( i->isSelected() )
+-			d->selectedItems.insert( i, i );
+-	    }
++	if ( !item && ( d->selectionMode == Multi || d->selectionMode == Extended ) )
++	{
++	    d->canStartRubber = TRUE;
++	    d->rubberStartX = e->x();
++	    d->rubberStartY = e->y();
+ 	}
+-
+ 	d->mousePressed = TRUE;
+ 	d->controlPressed = ( ( e->state() & ControlButton ) == ControlButton );
+     }
+ 
+  emit_signals:
+-    if ( !d->rubber ) {
++    if ( !d->canStartRubber ) {
+ 	emit mouseButtonPressed( e->button(), item, e->globalPos() );
+ 	emit pressed( item );
+ 	emit pressed( item, e->globalPos() );
+@@ -4567,6 +4561,7 @@
+     d->mousePressed = FALSE;
+     d->startDragItem = 0;
+ 
++    d->canStartRubber = FALSE;
+     if ( d->rubber ) {
+ 	QPainter p;
+ 	p.begin( viewport() );
+@@ -4656,7 +4651,22 @@
+ 	    if ( d->tmpCurrentItem )
+ 		repaintItem( d->tmpCurrentItem );
+ 	}
+-    } else if ( d->mousePressed && !d->currentItem && d->rubber ) {
++    } else if ( d->mousePressed && ((!d->currentItem && d->rubber) || d->canStartRubber) ) {
++	if ( d->canStartRubber ) {
++	    d->canStartRubber = FALSE;
++	    d->tmpCurrentItem = d->currentItem;
++	    d->currentItem = 0;
++	    repaintItem( d->tmpCurrentItem );
++	    delete d->rubber;
++	    d->rubber = new QRect( d->rubberStartX, d->rubberStartY, 0, 0 );
++	    d->selectedItems.clear();
++	    if ( ( e->state() & ControlButton ) == ControlButton ||
++	         ( e->state() & ShiftButton ) == ShiftButton ) {
++		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
++		    if ( i->isSelected() )
++			d->selectedItems.insert( i, i );
++	    }
++	}
+ 	doAutoScroll();
+     }
+ }
diff -rNu qt-x11-free/patches/0056-khotkeys_input_84434.patch qt-copy/patches/0056-khotkeys_input_84434.patch
--- qt-x11-free/patches/0056-khotkeys_input_84434.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0056-khotkeys_input_84434.patch	2004-11-15 19:55:57.000000000 +0300
@@ -0,0 +1,21 @@
+qt-bugs@ issue : 58251
+bugs.kde.org number : 84434
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+Fixes keyboard input action in KHotKeys (see bug #84434).
+
+--- src/kernel/qapplication_x11.cpp.sav	2004-10-07 15:38:05.000000000 +0200
++++ src/kernel/qapplication_x11.cpp	2004-10-12 11:46:32.513137808 +0200
+@@ -5294,8 +5294,10 @@ static Bool qt_keypress_scanner(Display 
+     qt_auto_repeat_data *d = (qt_auto_repeat_data *) arg;
+     if (d->error ||
+         event->xkey.window  != d->window ||
+-        event->xkey.keycode != d->keycode)
++        event->xkey.keycode != d->keycode) {
++        d->error = TRUE;
+         return FALSE;
++    }
+ 
+     if (event->type == XKeyPress) {
+         d->error = (! d->release || event->xkey.time - d->timestamp > 10);
diff -rNu qt-x11-free/patches/0059-qpopup_has_mouse.patch qt-copy/patches/0059-qpopup_has_mouse.patch
--- qt-x11-free/patches/0059-qpopup_has_mouse.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0059-qpopup_has_mouse.patch	2004-11-15 19:55:57.000000000 +0300
@@ -0,0 +1,68 @@
+qt-bugs@ issue : 49417
+bugs.kde.org number : 58719
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+Hello,
+
+ please consider applying the two attached QPopupMenu patches fixing KDE bugs 
+ #58719 and #74778 (http://bugs.kde.org/show_bug.cgi?id=58719, 
+ http://bugs.kde.org/show_bug.cgi?id=74778), which complain about keyboard 
+ navigation in popup menus being very uncomfortable because of being affected 
+ by mouse position despite mouse not being used at all.
+ 
+ - hasmouse.patch - (#58719) - use keyboard to open and navigate in any popup 
+ menu and "accidentally" hit your mouse. Depending on the mouse cursor 
+ position either no popup entry is selected or the random popup entry 
+ happening to be at the cursor position becomes highlighted. The patch 
+ basically copies the 'hasmouse' code from QMenuBar which prevents the mouse 
+ having any effect on the popup if it's outside the popup geometry.
+
+ [ ... #74778 ... ] 
+ 
+--- src/widgets/qpopupmenu.cpp.sav	2004-05-25 21:58:23.000000000 +0200
++++ src/widgets/qpopupmenu.cpp	2004-05-25 22:02:19.520297888 +0200
+@@ -253,6 +253,7 @@ public:
+     } scroll;
+     QSize calcSize;
+     QRegion mouseMoveBuffer;
++    uint hasmouse : 1;
+ };
+ 
+ static QPopupMenu* active_popup_menu = 0;
+@@ -272,6 +273,7 @@ QPopupMenu::QPopupMenu( QWidget *parent,
+     d->scroll.scrollableSize = d->scroll.topScrollableIndex = 0;
+     d->scroll.scrollable = QPopupMenuPrivate::Scroll::ScrollNone;
+     d->scroll.scrolltimer = 0;
++    d->hasmouse = 0;
+     isPopupMenu	  = TRUE;
+ #ifndef QT_NO_ACCEL
+     autoaccel	  = 0;
+@@ -1740,6 +1742,11 @@ void QPopupMenu::mouseMoveEvent( QMouseE
+ 
+     int	 item = itemAtPos( e->pos() );
+     if ( item == -1 ) {				// no valid item
++        if( !d->hasmouse ) {
++            tryMenuBar( e );
++            return;
++        }
++        d->hasmouse = 0;
+ 	int lastActItem = actItem;
+ 	actItem = -1;
+ 	if ( lastActItem >= 0 )
+@@ -1751,6 +1758,7 @@ void QPopupMenu::mouseMoveEvent( QMouseE
+ 	}
+     } else {					// mouse on valid item
+ 	// but did not register mouse press
++        d->hasmouse = 1;
+ 	if ( (e->state() & Qt::MouseButtonMask) && !mouseBtDn )
+ 	    mouseBtDn = TRUE; // so mouseReleaseEvent will pop down
+ 
+@@ -2159,6 +2167,7 @@ void QPopupMenu::timerEvent( QTimerEvent
+ */
+ void QPopupMenu::leaveEvent( QEvent * )
+ {
++    d->hasmouse = 0;
+     if ( testWFlags( WStyle_Tool ) && style().styleHint(QStyle::SH_PopupMenu_MouseTracking, this) ) {
+ 	int lastActItem = actItem;
+ 	actItem = -1;
diff -rNu qt-x11-free/patches/0060-qpopup_ignore_mousepos.patch qt-copy/patches/0060-qpopup_ignore_mousepos.patch
--- qt-x11-free/patches/0060-qpopup_ignore_mousepos.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0060-qpopup_ignore_mousepos.patch	2004-11-15 19:55:57.000000000 +0300
@@ -0,0 +1,59 @@
+qt-bugs@ issue : 49417
+bugs.kde.org number : 74778
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+
+ Hello,
+ 
+  please consider applying the two attached QPopupMenu patches fixing KDE bugs 
+  #58719 and #74778 (http://bugs.kde.org/show_bug.cgi?id=58719, 
+  http://bugs.kde.org/show_bug.cgi?id=74778), which complain about keyboard 
+  navigation in popup menus being very uncomfortable because of being affected 
+  by mouse position despite mouse not being used at all.
+
+  [... #58719 ... ]
+  
+  - ignoremousepos.patch - (#74778) - use keyboard to open some popup which 
+  doesn't show up at mouse position (e.g. Alt+F3 with KWin or the context menu 
+  key with some file selected in Konqueror). If the mouse is positioned in the 
+  area where the popup shows, the random entry happening to be at the cursor 
+  position becomes highlighted.
+  The patch fixes this by ignoring mouse events that happen at mouse position 
+  which was current when the popup was shown, i.e. all mouse move events that 
+  actually aren't triggered by mouse move are ignored. I first wanted to ignore 
+  only the very first mouse move event (which should be caused by EnterNotify 
+  for the popup) but I realized that Qt's event handling causes the popup to 
+  possibly get more than just one initial move event, caused by LeaveNotify 
+  events for normal widgets being transformed to mouse move events for the 
+  popup, so I have no better idea how to solve this problem.
+   
+--- src/widgets/qpopupmenu.cpp.sav	2004-05-25 17:48:21.000000000 +0200
++++ src/widgets/qpopupmenu.cpp	2004-05-25 17:57:28.981809096 +0200
+@@ -254,6 +254,7 @@ public:
+     QSize calcSize;
+     QRegion mouseMoveBuffer;
+     uint hasmouse : 1;
++    QPoint ignoremousepos;
+ };
+ 
+ static QPopupMenu* active_popup_menu = 0;
+@@ -1354,6 +1355,7 @@ void QPopupMenu::show()
+     popupActive = -1;
+     if(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this))
+ 	d->mouseMoveBuffer = QRegion();
++    d->ignoremousepos = QCursor::pos();
+ }
+ 
+ /*!
+@@ -1701,6 +1703,11 @@ void QPopupMenu::mouseReleaseEvent( QMou
+ 
+ void QPopupMenu::mouseMoveEvent( QMouseEvent *e )
+ {
++    if( e->globalPos() == d->ignoremousepos ) {
++        return;
++    }
++    d->ignoremousepos = QPoint();
++
+     motion++;
+ 
+     if ( parentMenu && parentMenu->isPopupMenu ) {
diff -rNu qt-x11-free/patches/0061-qscrollview-propagate-horizontal-wheelevent.patch qt-copy/patches/0061-qscrollview-propagate-horizontal-wheelevent.patch
--- qt-x11-free/patches/0061-qscrollview-propagate-horizontal-wheelevent.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0061-qscrollview-propagate-horizontal-wheelevent.patch	2005-09-12 14:41:23.237411000 +0400
@@ -0,0 +1,23 @@
+qt-bugs@ issue : N64978
+applied: no
+author: Germain Garand <germain@ebooksfrance.org>
+
+In QScrollView, wheel events are forwarded to (viewport|contents)WheelEvent, but
+the horizontal/vertical status of the wheel event is not.
+
+Index: src/widgets/qscrollview.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/widgets/qscrollview.cpp,v
+retrieving revision 1.65
+diff -u -3 -p -r1.65 qscrollview.cpp
+--- src/widgets/qscrollview.cpp	29 Apr 2004 22:31:28 -0000	1.65
++++ src/widgets/qscrollview.cpp	25 Jan 2005 12:07:04 -0000
+@@ -1863,7 +1863,7 @@ void QScrollView::viewportWheelEvent( QW
+        the event itself.
+     */
+     QWheelEvent ce( viewportToContents(e->pos()),
+-        e->globalPos(), e->delta(), e->state());
++        e->globalPos(), e->delta(), e->state(), e->orientation());
+     contentsWheelEvent(&ce);
+     if ( ce.isAccepted() )
+         e->accept();
diff -rNu qt-x11-free/patches/0073-xinerama-aware-qpopup.patch qt-copy/patches/0073-xinerama-aware-qpopup.patch
--- qt-x11-free/patches/0073-xinerama-aware-qpopup.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0073-xinerama-aware-qpopup.patch	2007-02-23 02:58:09.901189000 +0300
@@ -0,0 +1,113 @@
+qt-bugs@ issue : none
+bugs.kde.org number : none
+applied: no
+author: Lubos Lunak <l.lunak@kde.org>
+Makes QPopupMenu aware of Xinerama (see e.g. https://bugzilla.novell.com/show_bug.cgi?id=216235).
+
+
+--- src/widgets/qpopupmenu.cpp
++++ src/widgets/qpopupmenu.cpp
+@@ -454,6 +454,15 @@ void QPopupMenu::frameChanged()
+     menuContentsChanged();
+ }
+ 
++QRect QPopupMenu::screenRect( const QPoint& pos )
++{
++    int screen_num = QApplication::desktop()->screenNumber( pos );
++#ifdef Q_WS_MAC
++    return QApplication::desktop()->availableGeometry( screen_num );
++#else
++    return QApplication::desktop()->screenGeometry( screen_num );
++#endif
++}
+ /*!
+     Displays the popup menu so that the item number \a indexAtPoint
+     will be at the specified \e global position \a pos. To translate a
+@@ -498,6 +507,15 @@ void QPopupMenu::popup( const QPoint &po
+     // point.
+ #endif
+ 
++    QRect screen = screenRect( geometry().center());
++    QRect screen2 = screenRect( QApplication::reverseLayout()
++        ? pos+QPoint(width(),0) : pos );
++    // if the widget is not in the screen given by the position, move it
++    // there, so that updateSize() uses the right size of the screen
++    if( screen != screen2 ) {
++        screen = screen2;
++        move( screen.x(), screen.y());
++    }
+     if(d->scroll.scrollable) {
+ 	d->scroll.scrollable = QPopupMenuPrivate::Scroll::ScrollNone;
+ 	d->scroll.topScrollableIndex = d->scroll.scrollableSize = 0;
+@@ -517,18 +535,6 @@ void QPopupMenu::popup( const QPoint &po
+ 	updateSize(TRUE);
+     }
+ 
+-    int screen_num;
+-    if (QApplication::desktop()->isVirtualDesktop())
+-	screen_num =
+-	    QApplication::desktop()->screenNumber( QApplication::reverseLayout() ?
+-						   pos+QPoint(width(),0) : pos );
+-    else
+-	screen_num = QApplication::desktop()->screenNumber( this );
+-#ifdef Q_WS_MAC
+-    QRect screen = QApplication::desktop()->availableGeometry( screen_num );
+-#else
+-    QRect screen = QApplication::desktop()->screenGeometry( screen_num );
+-#endif
+     int sw = screen.width();			// screen width
+     int sh = screen.height();			// screen height
+     int sx = screen.x();			// screen pos
+@@ -1056,7 +1062,7 @@ QSize QPopupMenu::updateSize(bool force_
+ 				   mi->iconSet()->pixmap( QIconSet::Small, QIconSet::Normal ).width() + 4 );
+ 	}
+ 
+-	int dh = QApplication::desktop()->height();
++	int dh = screenRect( geometry().center()).height();
+ 	ncols = 1;
+ 
+ 	for ( QMenuItemListIt it2( *mitems ); it2.current(); ++it2 ) {
+@@ -2297,9 +2303,9 @@ void QPopupMenu::subMenuTimer() {
+ 	bool right = FALSE;
+ 	if ( ( parentMenu && parentMenu->isPopupMenu &&
+ 	       ((QPopupMenu*)parentMenu)->geometry().x() < geometry().x() ) ||
+-	     p.x() < 0 )
++	     p.x() < screenRect( p ).left())
+ 	    right = TRUE;
+-	if ( right && (ps.width() > QApplication::desktop()->width() - mapToGlobal( r.topRight() ).x() ) )
++	if ( right && (ps.width() > screenRect( p ).right() - mapToGlobal( r.topRight() ).x() ) )
+ 	    right = FALSE;
+ 	if ( right )
+ 	    p.setX( mapToGlobal( r.topRight() ).x() );
+@@ -2310,7 +2316,7 @@ void QPopupMenu::subMenuTimer() {
+ 	bool left = FALSE;
+ 	if ( ( parentMenu && parentMenu->isPopupMenu &&
+ 	       ((QPopupMenu*)parentMenu)->geometry().x() > geometry().x() ) ||
+-	     p.x() + ps.width() > QApplication::desktop()->width() )
++	     p.x() + ps.width() > screenRect( p ).right() )
+ 	    left = TRUE;
+ 	if ( left && (ps.width() > mapToGlobal( r.topLeft() ).x() ) )
+ 	    left = FALSE;
+@@ -2318,8 +2324,8 @@ void QPopupMenu::subMenuTimer() {
+ 	    p.setX( mapToGlobal( r.topLeft() ).x() - ps.width() );
+     }
+     QRect pr = popup->itemGeometry(popup->count() - 1);
+-    if (p.y() + ps.height() > QApplication::desktop()->height() &&
+-	p.y() - ps.height() + (QCOORD) pr.height() >= 0)
++    if (p.y() + ps.height() > screenRect( p ).bottom() &&
++	p.y() - ps.height() + (QCOORD) pr.height() >= screenRect( p ).top())
+ 	p.setY( p.y() - ps.height() + (QCOORD) pr.height());
+ 
+     if ( style().styleHint(QStyle::SH_PopupMenu_SloppySubMenus, this )) {
+Index: src/widgets/qpopupmenu.h
+===================================================================
+--- src/widgets/qpopupmenu.h	(revision 636368)
++++ src/widgets/qpopupmenu.h	(working copy)
+@@ -152,6 +152,7 @@ private:
+ 
+     QSize	updateSize(bool force_recalc=FALSE, bool do_resize=TRUE);
+     void	updateRow( int row );
++    QRect       screenRect(const QPoint& pos);
+ #ifndef QT_NO_ACCEL
+     void	updateAccel( QWidget * );
+     void	enableAccel( bool );
diff -rNu qt-x11-free/patches/0076-fix-qprocess.diff qt-copy/patches/0076-fix-qprocess.diff
--- qt-x11-free/patches/0076-fix-qprocess.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0076-fix-qprocess.diff	2007-03-15 19:53:49.423304000 +0300
@@ -0,0 +1,19 @@
+qt-bugs@ issue : none
+bugs.kde.org number : none
+applied: no
+author: from trolltech
+
+Fixes a regression in QProgress::writeToStdin()
+
+
+--- src/kernel/qprocess.cpp
++++ src/kernel/qprocess.cpp
+@@ -727,7 +727,7 @@ void QProcess::closeStdinLaunch()
+ void QProcess::writeToStdin( const QString& buf )
+ {
+     QByteArray tmp = buf.local8Bit();
+-    tmp.resize( tmp.size() - 1 ); // drop the implicit \0
++    tmp.resize( qstrlen( tmp.data() ) );
+     writeToStdin( tmp );
+ }
+
diff -rNu qt-x11-free/patches/0077-utf8-decoder-fixes.diff qt-copy/patches/0077-utf8-decoder-fixes.diff
--- qt-x11-free/patches/0077-utf8-decoder-fixes.diff	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/0077-utf8-decoder-fixes.diff	2007-03-29 19:28:19.824529000 +0400
@@ -0,0 +1,109 @@
+qt-bugs@ issue : N154454
+bugs.kde.org number : none
+applied: no
+author: Dirk Mueller <mueller@kde.org>
+
+This patch makes the utf8 decoders in Qt reject overlong
+sequences, like required.
+
+--- src/codecs/qutfcodec.cpp
++++ src/codecs/qutfcodec.cpp
+@@ -154,6 +154,7 @@
+ 
+ class QUtf8Decoder : public QTextDecoder {
+     uint uc;
++    uint min_uc;
+     int need;
+     bool headerDone;
+ public:
+@@ -167,8 +168,9 @@
+ 	result.setLength( len ); // worst case
+ 	QChar *qch = (QChar *)result.unicode();
+ 	uchar ch;
++        int error = -1;
+ 	for (int i=0; i<len; i++) {
+-	    ch = *chars++;
++	    ch = chars[i];
+ 	    if (need) {
+ 		if ( (ch&0xc0) == 0x80 ) {
+ 		    uc = (uc << 6) | (ch & 0x3f);
+@@ -182,6 +184,8 @@
+ 			    *qch++ = QChar(high);
+ 			    *qch++ = QChar(low);
+ 			    headerDone = TRUE;
++			} else if ((uc < min_uc) || (uc >= 0xd800 && uc <= 0xdfff) || (uc >= 0xfffe)) {
++                            *qch++ = QChar::replacement;
+ 			} else {
+ 			    if (headerDone || QChar(uc) != QChar::byteOrderMark)
+ 				*qch++ = uc;
+@@ -190,6 +194,7 @@
+ 		    }
+ 		} else {
+ 		    // error
++                    i = error;
+ 		    *qch++ = QChar::replacement;
+ 		    need = 0;
+ 		}
+@@ -200,12 +205,21 @@
+ 		} else if ((ch & 0xe0) == 0xc0) {
+ 		    uc = ch & 0x1f;
+ 		    need = 1;
++                    error = i;
++		    min_uc = 0x80;
+ 		} else if ((ch & 0xf0) == 0xe0) {
+ 		    uc = ch & 0x0f;
+ 		    need = 2;
++                    error = i;
++		    min_uc = 0x800;
+ 		} else if ((ch&0xf8) == 0xf0) {
+ 		    uc = ch & 0x07;
+ 		    need = 3;
++                    error = i;
++                    min_uc = 0x10000;
++                } else {
++                    // error
++                    *qch++ = QChar::replacement;
+ 		}
+ 	    }
+ 	}
+--- src/tools/qstring.cpp
++++ src/tools/qstring.cpp
+@@ -5805,6 +5805,7 @@
+     result.setLength( len ); // worst case
+     QChar *qch = (QChar *)result.unicode();
+     uint uc = 0;
++    uint min_uc = 0;
+     int need = 0;
+     int error = -1;
+     uchar ch;
+@@ -5822,6 +5823,12 @@
+ 			unsigned short low = uc%0x400 + 0xdc00;
+ 			*qch++ = QChar(high);
+ 			*qch++ = QChar(low);
++		    } else if (uc < min_uc || (uc >= 0xd800 && uc <= 0xdfff) || (uc >= 0xfffe)) {
++			// overlong seqence, UTF16 surrogate or BOM
++                        i = error;
++                        qch = addOne(qch, result);
++                        *qch++ = QChar(0xdbff);
++                        *qch++ = QChar(0xde00+((uchar)utf8[i]));
+ 		    } else {
+ 			*qch++ = uc;
+ 		    }
+@@ -5844,14 +5851,17 @@
+ 		uc = ch & 0x1f;
+ 		need = 1;
+ 		error = i;
++		min_uc = 0x80;
+ 	    } else if ((ch & 0xf0) == 0xe0) {
+ 		uc = ch & 0x0f;
+ 		need = 2;
+ 		error = i;
++		min_uc = 0x800;
+ 	    } else if ((ch&0xf8) == 0xf0) {
+ 		uc = ch & 0x07;
+ 		need = 3;
+ 		error = i;
++		min_uc = 0x10000;
+ 	    } else {
+ 	        // Error
+                 qch = addOne(qch, result);
diff -rNu qt-x11-free/patches/DISABLED qt-copy/patches/DISABLED
--- qt-x11-free/patches/DISABLED	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/DISABLED	2006-01-27 13:52:46.560582000 +0300
@@ -0,0 +1 @@
+# put the numbers of patches to disable here (e.g. because they currently don't apply)
diff -rNu qt-x11-free/patches/notsafe/0025-tenfold_qstring_multiarg.patch qt-copy/patches/notsafe/0025-tenfold_qstring_multiarg.patch
--- qt-x11-free/patches/notsafe/0025-tenfold_qstring_multiarg.patch	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/notsafe/0025-tenfold_qstring_multiarg.patch	2003-08-13 14:59:06.000000000 +0400
@@ -0,0 +1,215 @@
+qt-bugs@ issue : N26198
+applied: notsafe
+author: Marc Mutz <mutz@kde.org>
+
+This patch changes the signature of the private QString::multiArg() to support
+arbitrarily many arguments (practical limit is, of course, 10 since in %n, n
+is between 0 and 9 incl.), keeps the old multiArg() method for BC (it's called
+from inline methods) and expresses the arg( n * const QString & ) overloads in
+terms of the new method. Overloads are now provided for up to ten arguments,
+while in the documentation they appear as one method with default arguments to
+keep the API docs clean.
+
+It also fixes an api doc issue.
+
+Index: src/tools/qstring.cpp
+===================================================================
+RCS file: /home/kde/qt-copy/src/tools/qstring.cpp,v
+retrieving revision 1.56
+diff -u -3 -p -r1.56 qstring.cpp
+--- src/tools/qstring.cpp	10 Aug 2003 11:45:37 -0000	1.56
++++ src/tools/qstring.cpp	13 Aug 2003 10:39:24 -0000
+@@ -1868,10 +1868,14 @@ QString QString::arg( const QString& a, 
+ }
+ 
+ /*!
+-    \fn QString QString::arg( const QString& a1, const QString& a2 ) const
++    \fn QString QString::arg( const QString& a1, const QString& a2,
++           const QString& a3=QString::null, const QString& a4=QString::null,
++           const QString& a5=QString::null, const QString& a6=QString::null,
++           const QString& a7=QString::null, const QString& a8=QString::null,
++	   const QString& a9=QString::null, const QString& a10=QString::null ) const
+     \overload
+ 
+-    This is the same as str.arg(\a a1).arg(\a a2), except that
++    This is the same as str.arg(\a a1).arg(\a a2)..., except that
+     the strings are replaced in one pass. This can make a difference
+     if \a a1 contains e.g. \c{%1}:
+ 
+@@ -1883,6 +1887,16 @@ QString QString::arg( const QString& a, 
+     str.arg( "(%1)", "Hello" );           // returns "(%1) Hello"
+     str.arg( "(%1)" ).arg( "Hello" );     // returns "(Hello) %2"
+     \endcode
++
++    In addition, multiple occurrences of the same placeholder are
++    replaced with the same replacement string, in contrast to
++    str.arg\a( a1).arg(\a a2)...:
++
++    \code
++    QString str( "%1 %1" );
++    str.arg( "Hello", "world" );        // returns "Hello Hello"
++    atr.arg( "Hello" ).arg( "world" );  // returns "Hello world"
++    \endcode
+ */
+ 
+ /*!
+@@ -2055,23 +2069,28 @@ QString QString::arg( double a, int fiel
+ QString QString::multiArg( int numArgs, const QString& a1, const QString& a2,
+ 			   const QString& a3, const QString& a4 ) const
+ {
++    const QString * args[4] = { &a1, &a2, &a3, &a4 };
++    return multiArg( numArgs, args );
++}
++
++QString QString::multiArg( int numArgs, const QString * args[] ) const
++{
+     QString result;
++    if ( numArgs > 10 ) {
++      qWarning( "QString::multiArg(): more than 10 arguments given, using only first ten" );
++      numArgs = 10;
++    }
+     union {
+ 	int digitUsed[10];
+ 	int argForDigit[10];
+     };
+     register const QChar *uc = d->unicode;
+-    const QString *args[4];
+     const int len = (int) length();
+     const int end = len - 1;
+     int lastDigit = -1;
+     int i;
+ 
+     memset( digitUsed, 0, sizeof(digitUsed) );
+-    args[0] = &a1;
+-    args[1] = &a2;
+-    args[2] = &a3;
+-    args[3] = &a4;
+ 
+     for ( i = 0; i < end; i++ ) {
+ 	if ( uc[i] == '%' ) {
+Index: src/tools/qstring.h
+===================================================================
+RCS file: /home/kde/qt-copy/src/tools/qstring.h,v
+retrieving revision 1.49
+diff -u -3 -p -r1.49 qstring.h
+--- src/tools/qstring.h	23 Jun 2003 11:48:50 -0000	1.49
++++ src/tools/qstring.h	13 Aug 2003 10:39:24 -0000
+@@ -439,11 +439,36 @@ public:
+     QString arg( char a, int fieldWidth = 0 ) const;
+     QString arg( QChar a, int fieldWidth = 0 ) const;
+     QString arg( const QString& a, int fieldWidth = 0 ) const;
++#if defined(Q_QDOC)
++    QString arg( const QString& a1, const QString& a2,
++		 const QString& a3=QString::null, const QString& a4=QString::null,
++		 const QString& a5=QString::null, const QString& a6=QString::null,
++		 const QString& a7=QString::null, const QString& a8=QString::null,
++		 const QString& a9=QString::null, const QString& a10=QString::null ) const;
++#else
+     QString arg( const QString& a1, const QString& a2 ) const;
+     QString arg( const QString& a1, const QString& a2,
+ 		 const QString& a3 ) const;
+     QString arg( const QString& a1, const QString& a2, const QString& a3,
+ 		 const QString& a4 ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5 ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5, const QString& a6  ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5, const QString& a6,
++		 const QString& a7 ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5, const QString& a6,
++		 const QString& a7, const QString& a8 ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5, const QString& a6,
++		 const QString& a7, const QString& a8, const QString& a9 ) const;
++    QString arg( const QString& a1, const QString& a2, const QString& a3,
++		 const QString& a4, const QString& a5, const QString& a6,
++		 const QString& a7, const QString& a8, const QString& a9,
++		 const QString& a10 ) const;
++#endif
+ 
+ #ifndef QT_NO_SPRINTF
+     QString    &sprintf( const char* format, ... )
+@@ -724,7 +749,8 @@ private:
+     void subat( uint );
+     QString multiArg( int numArgs, const QString& a1, const QString& a2,
+ 		      const QString& a3 = QString::null,
+-		      const QString& a4 = QString::null ) const;
++		      const QString& a4 = QString::null ) const; // ### Qt 4.0: remove this
++    QString multiArg( int numArgs, const QString * args[] ) const;
+ 
+     void checkSimpleText() const;
+     void grow( uint newLength );
+@@ -977,17 +1003,68 @@ inline QString QString::arg( ushort a, i
+ { return arg( (Q_ULLONG)a, fieldWidth, base ); }
+ 
+ inline QString QString::arg( const QString& a1, const QString& a2 ) const {
+-    return multiArg( 2, a1, a2 );
++    const QString * args[] = { &a1, &a2 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
+ }
+ 
+ inline QString QString::arg( const QString& a1, const QString& a2,
+ 			     const QString& a3 ) const {
+-    return multiArg( 3, a1, a2, a3 );
++    const QString * args[] = { &a1, &a2, &a3 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
+ }
+ 
+ inline QString QString::arg( const QString& a1, const QString& a2,
+ 			     const QString& a3, const QString& a4 ) const {
+-    return multiArg( 4, a1, a2, a3, a4 );
++    const QString * args[] = { &a1, &a2, &a3, &a4 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5, const QString& a6 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5, &a6 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5, const QString& a6,
++			     const QString& a7 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5, const QString& a6,
++			     const QString& a7, const QString& a8 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5, const QString& a6,
++			     const QString& a7, const QString& a8,
++			     const QString& a9 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
++}
++
++inline QString QString::arg( const QString& a1, const QString& a2,
++			     const QString& a3, const QString& a4,
++			     const QString& a5, const QString& a6,
++			     const QString& a7, const QString& a8,
++			     const QString& a9, const QString& a10 ) const {
++    const QString * args[] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10 };
++    return multiArg( sizeof(args)/sizeof(*args), args );
+ }
+ 
+ inline int QString::find( char c, int index, bool cs ) const
diff -rNu qt-x11-free/patches/README qt-copy/patches/README
--- qt-x11-free/patches/README	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/patches/README	2007-03-29 19:28:19.824529000 +0400
@@ -0,0 +1,38 @@
+Please assign the numbers incrementally, and don't reuse them. The next one:
+#0078
+
+This directory contains patches for Qt that haven't been accepted by TrollTech
+yet. All patches in this directory itself shouldn't make qt-copy incompatible
+to official Qt, patches adding new API etc. belong to the notsafe/
+subdirectory.
+
+When adding new patches, use the same naming scheme for naming the patch file,
+i.e. <next available number>-<some suitable name>.<patch extension>.
+The number is used to order applying of the patches in the apply_patches
+script, in case they depend on each other. The extension should be either
+".diff" or ".patch". Also, include the following header:
+
+qt-bugs@ issue : <number>
+bugs.kde.org number : <number>
+applied: <no/yes>
+author: <who to blame for the thing :) >
+<description of the patch - the qt-bugs@ mail will do>
+
+The patch should be created from the toplevel directory, so that
+'patch -p0' in the toplevel directory can apply it.
+
+If you want to include more information that shouldn't be in the patch
+itself, create another file with the same file name, just use a different
+extension. E.g. if you want to include whole qt-copy@ mail, but the mail
+contains two patches and you want only one of them to be applied, put
+the mail in 1234-mypatch.txt, and in file 1234-mypatch.diff put only
+the header, perhaps very short description, and the patch to be applied.
+
+The apply_patches script will apply patches that have 'applied: no'
+in the header (first 5 lines). When adding a new patch, you should apply it
+to qt-copy (in CVS) only if it's a bugfix - optimizations, new features etc.
+shouldn't be applied, so that people need to apply those patches explicitly
+by running the apply_patches script, and will be aware of the fact that their
+qt build differs from the official Qt.
+
+Lubos Lunak <l.lunak@kde.org>
diff -rNu qt-x11-free/README.qt-copy qt-copy/README.qt-copy
--- qt-x11-free/README.qt-copy	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/README.qt-copy	2007-02-22 23:30:42.021290000 +0300
@@ -0,0 +1,109 @@
+To configure this copy of Qt 3.3.8, type some variation of:
+
+export QTDIR=$PWD
+export PATH=$QTDIR/bin:$PATH
+export YACC='byacc -d'
+make -f Makefile.cvs
+./configure <see below for options>
+make sub-tools
+
+This will give you the minimal version of Qt that is required for KDE.
+
+You may also consider running the apply_patches script before configuring qt-copy,
+which will apply all not yet applied patches from the patches/ directory that
+are considered safe (they mostly include optimizations and features that don't
+add new API). Note that most of those patches haven't been accepted
+by TrollTech yet. and therefore they'll make your qt-copy differ from official
+Qt version.
+
+On Systems using GNU C++ please use -no-exceptions as well. It will
+greatly help to reduce the memory consumption!
+
+The recommended compile line is:
+
+--default-config-begin--
+./configure -system-zlib -qt-gif -system-libpng -system-libjpeg \
+  -plugin-imgfmt-mng -thread -no-exceptions -debug -fast -dlopen-opengl
+--default-config-end--
+
+It adds "-debug" as well, which greatly improves the use for backtraces (but
+also needs a lot more disk space and makes things slower).
+
+If you wish to save some time and skip the examples and tutorials you can
+use
+
+    make sub-tools
+
+This will only build the moc compiler and Qt library. You can always build
+the examples and tutorials later by just re-running make by itself (without
+target).
+
+If you want to prelink Qt/KDE and depend on NVIDIA's binary drivers, add
+
+  -dlopen-opengl
+
+to the configure options.
+
+On current versions of glibc, a bug causes memory corruption when opening,
+closing and then opening dynamic libraries. This crashes kde designer
+plugins. A simple workaround is disabling dlopen() call in qlibrary_unix.cpp
+
+Please be aware of the fact that you need the original BSD version of yacc.
+The GNU bison which claims to be yacc compatible will not work with C++
+reliably. Often,
+
+	export YACC='byacc -d'
+
+helps the bash shell user
+
+or  setenv YACC 'byacc -d'
+
+fixes the problem for csh user.
+
+Please remember that there might be some older Qt header files in your
+$KDEDIR/include. Remove them before you try to recompile KDE.
+
+
+Hint for people debugging Qt, being sick of waiting for the linker: In the
+toplevel directory there's a file called .qmake.cache . Add the line
+"QMAKE_INCREMENTAL = qfoo* qbar*" to the end of the file and run make. Then
+qmake creates one big library which contains all the other classes and as
+soon as you touch qfoo* or qbar* it only links these classes against the big
+library.
+
+Due to that nice trick linking time goes down to about 0,5 seconds. Note:
+This feature is experimental and it's said to work on Linux only. You've
+been warned.
+
+Another way of reducing the linking time is compiling all moc files
+in one .cpp file (saves about 20% normal linking time). To turn this feature
+on, add "PRECOMPH = $$KERNEL_H/qt.h" at the end of src/kernel/qt_x11.pri ,
+and move the one line referring to allmoc.cpp in configure out of the 'if'
+block.
+
+
+TROUBLESHOOTING THE RE-CONFIGURATION & RE-COMPILING PROCESS
+
+For those updating the source in a directory where Qt has already
+been compiled, you may need to run the following commands from the
+top directory of your Qt sources:
+
+	find . -name '*.moc' | xargs rm
+
+Sometimes ./configure will refuse to run.  You may need to:
+	rm .qmake.cache
+
+ANTI-ALIASING
+
+There are two versions of xft library: xft1 and xft2. In some cases, it may
+be advisable for people who are experiencing problems with xft1 to try
+compiling KDE with xft2. These cases include missing fonts and performance
+problems loading qt applications. It has also been suggested that KDE's Font
+Installer config. module may interactly badly with xft1 configuration (That
+remains as a speculation, though)
+
+-----------------------------------------------------------------------------
+Please add your patches to the patches/ directory, unless they come from TT.
+
+Otherwise the change will be lost if it hasn't been applied to official Qt
+meanwhile.
diff -rNu qt-x11-free/src/3rdparty/sqlite/attach.c qt-copy/src/3rdparty/sqlite/attach.c
--- qt-x11-free/src/3rdparty/sqlite/attach.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/attach.c	2005-09-12 14:00:31.077571000 +0400
@@ -11,7 +11,7 @@
 *************************************************************************
 ** This file contains code used to implement the ATTACH and DETACH commands.
 **
-** $Id: qt/attach.c   3.3.8   edited Mar 30 2004 $
+** $Id: attach.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/auth.c qt-copy/src/3rdparty/sqlite/auth.c
--- qt-x11-free/src/3rdparty/sqlite/auth.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/auth.c	2005-09-12 14:00:31.077571000 +0400
@@ -14,7 +14,7 @@
 ** systems that do not need this facility may omit it by recompiling
 ** the library with -DSQLITE_OMIT_AUTHORIZATION=1
 **
-** $Id: qt/auth.c   3.3.8   edited Mar 30 2004 $
+** $Id: auth.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/btree.c qt-copy/src/3rdparty/sqlite/btree.c
--- qt-x11-free/src/3rdparty/sqlite/btree.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/btree.c	2005-09-12 14:00:31.077571000 +0400
@@ -9,7 +9,7 @@
 **    May you share freely, never taking more than you give.
 **
 *************************************************************************
-** $Id: qt/btree.c   3.3.8   edited Mar 30 2004 $
+** $Id: btree.c 459878 2005-09-12 10:00:31Z binner $
 **
 ** This file implements a external (disk-based) database using BTrees.
 ** For a detailed discussion of BTrees, refer to
diff -rNu qt-x11-free/src/3rdparty/sqlite/btree.h qt-copy/src/3rdparty/sqlite/btree.h
--- qt-x11-free/src/3rdparty/sqlite/btree.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/btree.h	2005-09-12 14:00:31.077571000 +0400
@@ -13,7 +13,7 @@
 ** subsystem.  See comments in the source code for a detailed description
 ** of what each interface routine does.
 **
-** @(#) $Id: qt/btree.h   3.3.8   edited Mar 30 2004 $
+** @(#) $Id: btree.h 459878 2005-09-12 10:00:31Z binner $
 */
 #ifndef _BTREE_H_
 #define _BTREE_H_
diff -rNu qt-x11-free/src/3rdparty/sqlite/btree_rb.c qt-copy/src/3rdparty/sqlite/btree_rb.c
--- qt-x11-free/src/3rdparty/sqlite/btree_rb.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/btree_rb.c	2005-09-12 14:00:31.077571000 +0400
@@ -9,7 +9,7 @@
 **    May you share freely, never taking more than you give.
 **
 *************************************************************************
-** $Id: qt/btree_rb.c   3.3.8   edited Mar 30 2004 $
+** $Id: btree_rb.c 459878 2005-09-12 10:00:31Z binner $
 **
 ** This file implements an in-core database using Red-Black balanced
 ** binary trees.
diff -rNu qt-x11-free/src/3rdparty/sqlite/build.c qt-copy/src/3rdparty/sqlite/build.c
--- qt-x11-free/src/3rdparty/sqlite/build.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/build.c	2005-09-12 14:00:31.077571000 +0400
@@ -23,7 +23,7 @@
 **     ROLLBACK
 **     PRAGMA
 **
-** $Id: qt/build.c   3.3.8   edited Mar 30 2004 $
+** $Id: build.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include <ctype.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/copy.c qt-copy/src/3rdparty/sqlite/copy.c
--- qt-x11-free/src/3rdparty/sqlite/copy.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/copy.c	2005-09-12 14:00:31.077571000 +0400
@@ -11,7 +11,7 @@
 *************************************************************************
 ** This file contains code used to implement the COPY command.
 **
-** $Id: qt/copy.c   3.3.8   edited Mar 30 2004 $
+** $Id: copy.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/date.c qt-copy/src/3rdparty/sqlite/date.c
--- qt-x11-free/src/3rdparty/sqlite/date.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/date.c	2005-09-12 14:00:31.077571000 +0400
@@ -16,7 +16,7 @@
 ** sqliteRegisterDateTimeFunctions() found at the bottom of the file.
 ** All other code has file scope.
 **
-** $Id: qt/date.c   3.3.8   edited Mar 30 2004 $
+** $Id: date.c 459878 2005-09-12 10:00:31Z binner $
 **
 ** NOTES:
 **
diff -rNu qt-x11-free/src/3rdparty/sqlite/delete.c qt-copy/src/3rdparty/sqlite/delete.c
--- qt-x11-free/src/3rdparty/sqlite/delete.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/delete.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains C code routines that are called by the parser
 ** to handle DELETE FROM statements.
 **
-** $Id: qt/delete.c   3.3.8   edited Mar 30 2004 $
+** $Id: delete.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/expr.c qt-copy/src/3rdparty/sqlite/expr.c
--- qt-x11-free/src/3rdparty/sqlite/expr.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/expr.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains routines used for analyzing expressions and
 ** for generating VDBE code that evaluates expressions in SQLite.
 **
-** $Id: qt/expr.c   3.3.8   edited Mar 30 2004 $
+** $Id: expr.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include <ctype.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/func.c qt-copy/src/3rdparty/sqlite/func.c
--- qt-x11-free/src/3rdparty/sqlite/func.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/func.c	2005-09-12 14:00:31.077571000 +0400
@@ -16,7 +16,7 @@
 ** sqliteRegisterBuildinFunctions() found at the bottom of the file.
 ** All other code has file scope.
 **
-** $Id: qt/func.c   3.3.8   edited Mar 30 2004 $
+** $Id: func.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include <ctype.h>
 #include <math.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/hash.c qt-copy/src/3rdparty/sqlite/hash.c
--- qt-x11-free/src/3rdparty/sqlite/hash.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/hash.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This is the implementation of generic hash-tables
 ** used in SQLite.
 **
-** $Id: qt/hash.c   3.3.8   edited Mar 30 2004 $
+** $Id: hash.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include <assert.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/hash.h qt-copy/src/3rdparty/sqlite/hash.h
--- qt-x11-free/src/3rdparty/sqlite/hash.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/hash.h	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This is the header file for the generic hash-table implemenation
 ** used in SQLite.
 **
-** $Id: qt/hash.h   3.3.8   edited Mar 30 2004 $
+** $Id: hash.h 459878 2005-09-12 10:00:31Z binner $
 */
 #ifndef _SQLITE_HASH_H_
 #define _SQLITE_HASH_H_
diff -rNu qt-x11-free/src/3rdparty/sqlite/insert.c qt-copy/src/3rdparty/sqlite/insert.c
--- qt-x11-free/src/3rdparty/sqlite/insert.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/insert.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains C code routines that are called by the parser
 ** to handle INSERT statements in SQLite.
 **
-** $Id: qt/insert.c   3.3.8   edited Mar 30 2004 $
+** $Id: insert.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/main.c qt-copy/src/3rdparty/sqlite/main.c
--- qt-x11-free/src/3rdparty/sqlite/main.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/main.c	2005-09-12 14:00:31.077571000 +0400
@@ -14,7 +14,7 @@
 ** other files are for internal use by SQLite and should not be
 ** accessed by users of the library.
 **
-** $Id: qt/main.c   3.3.8   edited Mar 30 2004 $
+** $Id: main.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include "os.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/pager.c qt-copy/src/3rdparty/sqlite/pager.c
--- qt-x11-free/src/3rdparty/sqlite/pager.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/pager.c	2005-09-12 14:00:31.077571000 +0400
@@ -18,7 +18,7 @@
 ** file simultaneously, or one process from reading the database while
 ** another is writing.
 **
-** @(#) $Id: qt/pager.c   3.3.8   edited Mar 30 2004 $
+** @(#) $Id: pager.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "os.h"         /* Must be first to enable large file support */
 #include "sqliteInt.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/pager.h qt-copy/src/3rdparty/sqlite/pager.h
--- qt-x11-free/src/3rdparty/sqlite/pager.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/pager.h	2005-09-12 14:00:31.077571000 +0400
@@ -13,7 +13,7 @@
 ** subsystem.  The page cache subsystem reads and writes a file a page
 ** at a time and provides a journal for rollback.
 **
-** @(#) $Id: qt/pager.h   3.3.8   edited Mar 30 2004 $
+** @(#) $Id: pager.h 459878 2005-09-12 10:00:31Z binner $
 */
 
 /*
diff -rNu qt-x11-free/src/3rdparty/sqlite/pragma.c qt-copy/src/3rdparty/sqlite/pragma.c
--- qt-x11-free/src/3rdparty/sqlite/pragma.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/pragma.c	2005-09-12 14:00:31.077571000 +0400
@@ -11,7 +11,7 @@
 *************************************************************************
 ** This file contains code used to implement the PRAGMA command.
 **
-** $Id: qt/pragma.c   3.3.8   edited Mar 30 2004 $
+** $Id: pragma.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include <ctype.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/random.c qt-copy/src/3rdparty/sqlite/random.c
--- qt-x11-free/src/3rdparty/sqlite/random.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/random.c	2005-09-12 14:00:31.077571000 +0400
@@ -15,7 +15,7 @@
 ** Random numbers are used by some of the database backends in order
 ** to generate random integer keys for tables or random filenames.
 **
-** $Id: qt/random.c   3.3.8   edited Mar 30 2004 $
+** $Id: random.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include "os.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/select.c qt-copy/src/3rdparty/sqlite/select.c
--- qt-x11-free/src/3rdparty/sqlite/select.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/select.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains C code routines that are called by the parser
 ** to handle SELECT statements in SQLite.
 **
-** $Id: qt/select.c   3.3.8   edited Mar 30 2004 $
+** $Id: select.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/shell.c qt-copy/src/3rdparty/sqlite/shell.c
--- qt-x11-free/src/3rdparty/sqlite/shell.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/shell.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains code to implement the "sqlite" command line
 ** utility for accessing SQLite databases.
 **
-** $Id: qt/shell.c   3.3.8   edited Mar 30 2004 $
+** $Id: shell.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include <stdlib.h>
 #include <string.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/sqlite.h qt-copy/src/3rdparty/sqlite/sqlite.h
--- qt-x11-free/src/3rdparty/sqlite/sqlite.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/sqlite.h	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This header file defines the interface that the SQLite library
 ** presents to client programs.
 **
-** @(#) $Id: qt/sqlite.h   3.3.8   edited Mar 30 2004 $
+** @(#) $Id: sqlite.h 459878 2005-09-12 10:00:31Z binner $
 */
 #ifndef _SQLITE_H_
 #define _SQLITE_H_
diff -rNu qt-x11-free/src/3rdparty/sqlite/sqliteInt.h qt-copy/src/3rdparty/sqlite/sqliteInt.h
--- qt-x11-free/src/3rdparty/sqlite/sqliteInt.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/sqliteInt.h	2005-09-12 14:00:31.077571000 +0400
@@ -11,7 +11,7 @@
 *************************************************************************
 ** Internal interface definitions for SQLite.
 **
-** @(#) $Id: qt/sqliteInt.h   3.3.8   edited Mar 30 2004 $
+** @(#) $Id: sqliteInt.h 459878 2005-09-12 10:00:31Z binner $
 */
 #include "config.h"
 #include "sqlite.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/tokenize.c qt-copy/src/3rdparty/sqlite/tokenize.c
--- qt-x11-free/src/3rdparty/sqlite/tokenize.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/tokenize.c	2005-09-12 14:00:31.077571000 +0400
@@ -15,7 +15,7 @@
 ** individual tokens and sends those tokens one-by-one over to the
 ** parser for analysis.
 **
-** $Id: qt/tokenize.c   3.3.8   edited Mar 30 2004 $
+** $Id: tokenize.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include "os.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/update.c qt-copy/src/3rdparty/sqlite/update.c
--- qt-x11-free/src/3rdparty/sqlite/update.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/update.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This file contains C code routines that are called by the parser
 ** to handle UPDATE statements.
 **
-** $Id: qt/update.c   3.3.8   edited Mar 30 2004 $
+** $Id: update.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/sqlite/util.c qt-copy/src/3rdparty/sqlite/util.c
--- qt-x11-free/src/3rdparty/sqlite/util.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/util.c	2005-09-12 14:00:31.077571000 +0400
@@ -14,7 +14,7 @@
 ** This file contains functions for allocating memory, comparing
 ** strings, and stuff like that.
 **
-** $Id: qt/util.c   3.3.8   edited Mar 30 2004 $
+** $Id: util.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include <stdarg.h>
diff -rNu qt-x11-free/src/3rdparty/sqlite/vacuum.c qt-copy/src/3rdparty/sqlite/vacuum.c
--- qt-x11-free/src/3rdparty/sqlite/vacuum.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/vacuum.c	2005-09-12 14:00:31.077571000 +0400
@@ -14,7 +14,7 @@
 ** Most of the code in this file may be omitted by defining the
 ** SQLITE_OMIT_VACUUM macro.
 **
-** $Id: qt/vacuum.c   3.3.8   edited Mar 30 2004 $
+** $Id: vacuum.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include "os.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/vdbe.c qt-copy/src/3rdparty/sqlite/vdbe.c
--- qt-x11-free/src/3rdparty/sqlite/vdbe.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/vdbe.c	2005-09-12 14:00:31.077571000 +0400
@@ -43,7 +43,7 @@
 ** in this file for details.  If in doubt, do not deviate from existing
 ** commenting and indentation practices when changing or adding code.
 **
-** $Id: qt/vdbe.c   3.3.8   edited Mar 30 2004 $
+** $Id: vdbe.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 #include "os.h"
diff -rNu qt-x11-free/src/3rdparty/sqlite/vdbe.h qt-copy/src/3rdparty/sqlite/vdbe.h
--- qt-x11-free/src/3rdparty/sqlite/vdbe.h	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/vdbe.h	2005-09-12 14:00:31.077571000 +0400
@@ -15,7 +15,7 @@
 ** or VDBE.  The VDBE implements an abstract machine that runs a
 ** simple program to access and modify the underlying database.
 **
-** $Id: qt/vdbe.h   3.3.8   edited Mar 30 2004 $
+** $Id: vdbe.h 459878 2005-09-12 10:00:31Z binner $
 */
 #ifndef _SQLITE_VDBE_H_
 #define _SQLITE_VDBE_H_
diff -rNu qt-x11-free/src/3rdparty/sqlite/where.c qt-copy/src/3rdparty/sqlite/where.c
--- qt-x11-free/src/3rdparty/sqlite/where.c	2007-02-02 17:01:22.000000000 +0300
+++ qt-copy/src/3rdparty/sqlite/where.c	2005-09-12 14:00:31.077571000 +0400
@@ -12,7 +12,7 @@
 ** This module contains C code that generates VDBE code used to process
 ** the WHERE clause of SQL statements.
 **
-** $Id: qt/where.c   3.3.8   edited Mar 30 2004 $
+** $Id: where.c 459878 2005-09-12 10:00:31Z binner $
 */
 #include "sqliteInt.h"
 
diff -rNu qt-x11-free/src/3rdparty/zlib/projects/visualc6/README.txt qt-copy/src/3rdparty/zlib/projects/visualc6/README.txt
--- qt-x11-free/src/3rdparty/zlib/projects/visualc6/README.txt	2004-05-31 08:00:00.000000000 +0400
+++ qt-copy/src/3rdparty/zlib/projects/visualc6/README.txt	2005-01-30 19:28:28.000000000 +0300
@@ -1,38 +1,38 @@
-Microsoft Developer Studio Project Files, Format Version 6.00 for zlib.
-
-Copyright (C) 2000-2004 Simon-Pierre Cadieux.
-Copyright (C) 2004 Cosmin Truta.
-For conditions of distribution and use, see copyright notice in zlib.h.
-
-
-To use:
-
-1) On the main menu, select "File | Open Workspace".
-   Open "zlib.dsw".
-
-2) Select "Build | Set Active Configuration".
-   Choose the configuration you wish to build.
-
-3) Select "Build | Clean".
-
-4) Select "Build | Build ... (F7)".  Ignore warning messages about
-   not being able to find certain include files (e.g. alloc.h).
-
-5) If you built one of the sample programs (example or minigzip),
-   select "Build | Execute ... (Ctrl+F5)".
-
-
-This project builds the zlib binaries as follows:
-
-* Win32_DLL_Release\zlib1.dll       DLL build
-* Win32_DLL_Debug\zlib1d.dll        DLL build (debug version)
-* Win32_DLL_ASM_Release\zlib1.dll   DLL build using ASM code
-* Win32_DLL_ASM_Debug\zlib1d.dll    DLL build using ASM code (debug version)
-* Win32_LIB_Release\zlib.lib        static build
-* Win32_LIB_Debug\zlibd.lib         static build (debug version)
-* Win32_LIB_ASM_Release\zlib.lib    static build using ASM code
-* Win32_LIB_ASM_Debug\zlibd.lib     static build using ASM code (debug version)
-
-
-For more information regarding the DLL builds, please see the DLL FAQ
-in ..\..\win32\DLL_FAQ.txt.
+Microsoft Developer Studio Project Files, Format Version 6.00 for zlib.
+
+Copyright (C) 2000-2004 Simon-Pierre Cadieux.
+Copyright (C) 2004 Cosmin Truta.
+For conditions of distribution and use, see copyright notice in zlib.h.
+
+
+To use:
+
+1) On the main menu, select "File | Open Workspace".
+   Open "zlib.dsw".
+
+2) Select "Build | Set Active Configuration".
+   Choose the configuration you wish to build.
+
+3) Select "Build | Clean".
+
+4) Select "Build | Build ... (F7)".  Ignore warning messages about
+   not being able to find certain include files (e.g. alloc.h).
+
+5) If you built one of the sample programs (example or minigzip),
+   select "Build | Execute ... (Ctrl+F5)".
+
+
+This project builds the zlib binaries as follows:
+
+* Win32_DLL_Release\zlib1.dll       DLL build
+* Win32_DLL_Debug\zlib1d.dll        DLL build (debug version)
+* Win32_DLL_ASM_Release\zlib1.dll   DLL build using ASM code
+* Win32_DLL_ASM_Debug\zlib1d.dll    DLL build using ASM code (debug version)
+* Win32_LIB_Release\zlib.lib        static build
+* Win32_LIB_Debug\zlibd.lib         static build (debug version)
+* Win32_LIB_ASM_Release\zlib.lib    static build using ASM code
+* Win32_LIB_ASM_Debug\zlibd.lib     static build using ASM code (debug version)
+
+
+For more information regarding the DLL builds, please see the DLL FAQ
+in ..\..\win32\DLL_FAQ.txt.
diff -rNu qt-x11-free/src/3rdparty/zlib/zconf.in.h qt-copy/src/3rdparty/zlib/zconf.in.h
--- qt-x11-free/src/3rdparty/zlib/zconf.in.h	2007-02-02 17:01:17.000000000 +0300
+++ qt-copy/src/3rdparty/zlib/zconf.in.h	2005-09-12 14:00:31.077571000 +0400
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* @(#) $Id: qt/zconf.in.h   3.3.8   edited May 30 2004 $ */
+/* @(#) $Id: zconf.in.h 459878 2005-09-12 10:00:31Z binner $ */
 
 #ifndef ZCONF_H
 #define ZCONF_H
diff -rNu qt-x11-free/src/opengl/qgl_x11_p.h qt-copy/src/opengl/qgl_x11_p.h
--- qt-x11-free/src/opengl/qgl_x11_p.h	2007-02-02 17:01:17.000000000 +0300
+++ qt-copy/src/opengl/qgl_x11_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qgl_x11_p.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qgl_x11_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Definitions needed for resolving GL/GLX symbols using dlopen()
 ** under X11.
diff -rNu qt-x11-free/src/tools/qlocale.cpp qt-copy/src/tools/qlocale.cpp
--- qt-x11-free/src/tools/qlocale.cpp	2007-02-02 17:01:05.000000000 +0300
+++ qt-copy/src/tools/qlocale.cpp	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qlocale.cpp   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale.cpp 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Implementation of the QLocale class
 **
diff -rNu qt-x11-free/src/tools/qlocale.h qt-copy/src/tools/qlocale.h
--- qt-x11-free/src/tools/qlocale.h	2007-02-02 17:01:05.000000000 +0300
+++ qt-copy/src/tools/qlocale.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qlocale.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QLocale class
 **
diff -rNu qt-x11-free/src/tools/qlocale_p.h qt-copy/src/tools/qlocale_p.h
--- qt-x11-free/src/tools/qlocale_p.h	2007-02-02 17:01:05.000000000 +0300
+++ qt-copy/src/tools/qlocale_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qlocale_p.h   3.3.8   edited Jan 11 14:38 $
+** $Id: qlocale_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Declaration of the QLocalePrivate class
 **
diff -rNu qt-x11-free/src/widgets/qsyntaxhighlighter_p.h qt-copy/src/widgets/qsyntaxhighlighter_p.h
--- qt-x11-free/src/widgets/qsyntaxhighlighter_p.h	2007-02-02 17:01:24.000000000 +0300
+++ qt-copy/src/widgets/qsyntaxhighlighter_p.h	2007-02-22 23:30:42.021290000 +0300
@@ -1,5 +1,5 @@
 /****************************************************************************
-** $Id: qt/qsyntaxhighlighter_p.h   3.3.8   edited Jan 11 14:39 $
+** $Id: qsyntaxhighlighter_p.h 636340 2007-02-22 20:30:42Z mueller $
 **
 ** Definition of the internal QSyntaxHighlighterInternal class
 **
diff -rNu qt-x11-free/upgrade_script.qt qt-copy/upgrade_script.qt
--- qt-x11-free/upgrade_script.qt	1970-01-01 03:00:00.000000000 +0300
+++ qt-copy/upgrade_script.qt	2006-03-17 01:31:32.783928000 +0300
@@ -0,0 +1,116 @@
+#!/bin/sh
+# Script to upgrade to a new Qt.
+# Apply VERY carefully, step by step.
+#
+# David Faure <faure@kde.org>
+#
+
+if test -z "$1"; then echo give snapshot file name; exit 1; fi
+SNAPSHOT=$1
+
+if [ ! -f $SNAPSHOT ]; then echo $SNAPSHOT not found ; fi
+
+TOPLEVEL=`tar tf $SNAPSHOT | head -1 | sed -e 's,/$,,' `
+
+echo Found TOPLEVEL=$TOPLEVEL
+
+echo -n Cleaning qt-copy...
+# Do a make svn-clean first
+if [ ! -d qt-copy ]; then echo You should have a qt-copy directory under here ; fi
+cd qt-copy
+common="`which svn-clean`"
+if [ -f ../kdesdk/scripts/svn-clean ] ; then common=../kdesdk/scripts/svn-clean; fi
+if [ -f ../../kdesdk/scripts/svn-clean ] ; then common=../../kdesdk/scripts/svn-clean; fi
+if [ -z "$common" ]; then
+  echo svn-clean not found ;
+else
+  perl $common
+fi
+cd ..
+echo done
+
+# List of new stuff
+echo -n Creating to_add and to_remove...
+tar tf $SNAPSHOT | sort > qtlist     || exit 1
+perl -pi -e "s/$TOPLEVEL/qt-copy/" qtlist
+
+# Plus stuff we added ourselves
+echo qt-copy/README.qt-copy >> qtlist
+echo qt-copy/apply_patches >> qtlist
+echo qt-copy/switch-qt-symlinks >> qtlist
+echo qt-copy/upgrade_script.qt >> qtlist
+
+tar tvf $SNAPSHOT | grep ' -> ' | sed -e "s, ->.*\$,,; s,^.*$TOPLEVEL/,qt-copy/," | sort -u > new_links
+changed_links=
+find qt-copy -type l -print | sort -u > old_links
+
+for link in `cat new_links`; do
+  if test -f $link; then 
+    changed_links="$changed_links $link"
+  fi
+done
+for link in `cat old_links`; do
+  if ! grep -q $link new_links; then
+    changed_links="$changed_links $link"
+  fi
+done
+
+# Prepare list of what's new 
+: > to_add
+cat qtlist | while read a ; do
+  if [ ! -e "$a" ]; then
+     echo "$a" >> to_add
+  fi
+done
+for a in $changed_links; do echo $a >> to_add; done
+
+# And what we don't want to see in our svn
+perl -pi -e 'if (/^qt-copy\/src\/tools\/qmodules.h/) {$_ = "";}' to_add
+
+# Remove old stuff
+: > to_remove
+find qt-copy | grep -v .svn | grep -v debian | grep -v patches | while read a ; do
+  if ! grep -q -F $a qtlist; then
+    echo $a >> to_remove
+  fi
+done
+echo done
+for a in $changed_links; do echo $a >> to_remove; done
+
+if [ ! -d qt-copy ]; then echo You should have a qt-copy directory under here ; fi # Better very safe than very sorry...
+cd qt-copy
+perl -pi -e "s/qt-copy\///" ../to_remove
+
+cat ../to_remove | while read a; do
+  echo Removing $a
+  svn rm --force $a
+done
+
+cd ..
+
+# Untar
+echo -n Untarring snapshot over qt-copy...
+rm -rf $TOPLEVEL
+mv qt-copy $TOPLEVEL
+tar xf $SNAPSHOT
+mv $TOPLEVEL qt-copy
+echo done
+
+cd qt-copy
+perl -pi -e "s/^.*qt-copy\///" ../to_add
+
+cat ../to_add | while read a ; do
+     echo Adding $a
+     svn add $a
+done
+
+tar tf ../$SNAPSHOT | sort > ../qtlist || exit 1
+perl -pi -e "s/$TOPLEVEL/qt-copy/" ../qtlist
+# defang $Id$ tags
+cat ../qtlist | while read a ; do
+     if ! test -L ../$a && test -f ../$a; then
+         perl -pi -e 's/<!-- \/\S+\/qt-x11-opensource-\S+ -->//' ../$a
+     fi
+done
+
+echo done, please update README.qt-copy now
