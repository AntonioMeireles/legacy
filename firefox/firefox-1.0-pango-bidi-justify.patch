--- ./layout/html/base/src/nsTextFrame.cpp.SCREW	2005-05-03 15:53:09.000000000 -0400
+++ ./layout/html/base/src/nsTextFrame.cpp	2005-05-03 16:45:25.000000000 -0400
@@ -2967,12 +2967,21 @@
 
   if (0 != textLength) {
 #ifdef IBMBIDI
+    PRBool isRightToLeftOnBidiPlatform = PR_FALSE;
+    PRBool isBidiSystem = PR_FALSE;
+    PRUint32 hints = 0;
+    aRenderingContext.GetHints(hints);
+    PRBool paintCharByChar = (0 == (hints & NS_RENDERING_HINT_REORDER_SPACED_TEXT)) &&
+      ((0 != aTextStyle.mLetterSpacing) ||
+       (0 != aTextStyle.mWordSpacing) ||
+       aTextStyle.mJustifying);
     PRBool bidiEnabled;
     PRUint8 level = 0;
     nsCharType charType = eCharType_LeftToRight;
     aPresContext->GetBidiEnabled(&bidiEnabled);
 
     if (bidiEnabled) {
+      isBidiSystem = aPresContext->IsBidiSystem();
       nsBidiPresUtils* bidiUtils;
       aPresContext->GetBidiUtils(&bidiUtils);
 
@@ -2985,8 +2994,19 @@
         PRInt32 rememberTextLength = textLength;
 #endif
         // Since we paint char by char, handle the text like on non-bidi platform
+        isRightToLeftOnBidiPlatform = (!paintCharByChar &&
+                                       isBidiSystem &&
+                                       (eCharType_RightToLeft == charType ||
+                                        eCharType_RightToLeftArabic == charType));
+        if (isRightToLeftOnBidiPlatform) {
+          // indicate that the platform should use its native
+          // capabilities to reorder the text with right-to-left
+          // base direction 
+          aRenderingContext.SetRightToLeftText(PR_TRUE);
+        }
+        // If we will be painting char by char, handle the text like on non-bidi platform
         bidiUtils->ReorderUnicodeText(text, textLength, charType,
-                                      level & 1, PR_FALSE);
+                                      level & 1, (paintCharByChar) ? PR_FALSE : isBidiSystem);
         NS_ASSERTION(rememberTextLength == textLength, "Bidi formatting changed text length");
       }
     }
@@ -3028,7 +3048,9 @@
         sdptr->mStart = ip[sdptr->mStart] - mContentOffset;
         sdptr->mEnd = ip[sdptr->mEnd]  - mContentOffset;
 #ifdef IBMBIDI
-        AdjustSelectionPointsForBidi(sdptr, textLength, CHARTYPE_IS_RTL(charType), level & 1, PR_FALSE);
+        AdjustSelectionPointsForBidi(sdptr, textLength,
+                                     CHARTYPE_IS_RTL(charType), level & 1,
+                                     (paintCharByChar) ? PR_FALSE : isBidiSystem);
 #endif
         sdptr = sdptr->mNext;
       }
@@ -3036,19 +3058,32 @@
       DrawSelectionIterator iter(content, details,text,(PRUint32)textLength,aTextStyle, selectionValue, aPresContext, mStyleContext);
       if (!iter.IsDone() && iter.First())
       {
-	      nscoord currentX = dx;
-	      nsTextDimensions newDimensions;//temp
-	      while (!iter.IsDone())
-	      {
-	      PRUnichar *currenttext  = iter.CurrentTextUnicharPtr();
-	      PRUint32   currentlength= iter.CurrentLength();
-	      //TextStyle &currentStyle = iter.CurrentStyle();
-	      nscolor    currentFGColor = iter.CurrentForeGroundColor();
-	      nscolor    currentBKColor;
-	      PRBool     isCurrentBKColorTransparent;
-	      GetTextDimensions(aRenderingContext,aTextStyle,currenttext, (PRInt32)currentlength,&newDimensions);
-	      if (newDimensions.width)
-	      {
+        nscoord currentX = dx;
+        nsTextDimensions newDimensions;//temp
+#ifdef IBMBIDI // Simon - display substrings RTL in RTL frame
+        if (isRightToLeftOnBidiPlatform)
+        {
+          nsTextDimensions frameDimensions;
+          GetTextDimensions(aRenderingContext, aTextStyle, text, 
+                            (PRInt32)textLength, &frameDimensions);
+          currentX = dx + frameDimensions.width;
+        }
+#endif
+        while (!iter.IsDone())
+        {
+        PRUnichar *currenttext  = iter.CurrentTextUnicharPtr();
+        PRUint32   currentlength= iter.CurrentLength();
+        //TextStyle &currentStyle = iter.CurrentStyle();
+        nscolor    currentFGColor = iter.CurrentForeGroundColor();
+        nscolor    currentBKColor;
+        PRBool     isCurrentBKColorTransparent;
+        GetTextDimensions(aRenderingContext,aTextStyle,currenttext, (PRInt32)currentlength,&newDimensions);
+        if (newDimensions.width)
+        {
+#ifdef IBMBIDI
+            if (isRightToLeftOnBidiPlatform)
+              currentX -= newDimensions.width;
+#endif
             if (iter.CurrentBackGroundColor(currentBKColor, &isCurrentBKColorTransparent))
             {//DRAW RECT HERE!!!
               if (!isCurrentBKColorTransparent) {
@@ -3057,7 +3092,7 @@
               }
               currentFGColor = EnsureDifferentColors(currentFGColor, currentBKColor);
             }
-	      }
+        }
 
         if (isPaginated && !iter.IsBeforeOrAfter()) {
           aRenderingContext.SetColor(nsCSSRendering::TransformColor(aTextStyle.mColor->mColor,canDarkenColor));
@@ -3071,11 +3106,13 @@
                        dy, width, details);
         }
 
+#ifdef IBMBIDI
+          if (!isRightToLeftOnBidiPlatform)
+#endif
           //increment twips X start but remember to get ready for next draw by reducing current x by letter spacing amount
-	      currentX+=newDimensions.width;// + aTextStyle.mLetterSpacing;
-
-	      iter.Next();
-	      }
+          currentX+=newDimensions.width;// + aTextStyle.mLetterSpacing;
+          iter.Next();
+        }
       }
       else if (!isPaginated) 
       {
@@ -3093,8 +3130,15 @@
         delete details;
       }
     }
+#ifdef IBMBIDI
+    if (isRightToLeftOnBidiPlatform) {
+      // indicate that future text should not be reordered with
+      // right-to-left base direction 
+      aRenderingContext.SetRightToLeftText(PR_FALSE);
+    }
+#endif // IBMBIDI
   }
-}
+}  
 
 void
 nsTextFrame::PaintAsciiText(nsIPresContext* aPresContext,
--- ./gfx/public/nsIRenderingContext.h.SCREW	2005-05-03 15:53:09.000000000 -0400
+++ ./gfx/public/nsIRenderingContext.h	2005-05-03 15:53:09.000000000 -0400
@@ -932,6 +932,14 @@
  */
 #define NS_RENDERING_HINT_TEXT_CLUSTERS 0x20
 
+/**
+ * This bit, when set, indicates that gfx performs glyph reordering of complex
+ * text after applying character or word spacing, and so expects to be passed
+ * text in logical order. When this bit is not set, gfx must be passed text in
+ * visual order if characters and word spacing are to be applied.
+ */
+#define NS_RENDERING_HINT_REORDER_SPACED_TEXT 0x40
+
 //flags for copy CopyOffScreenBits
 
 //when performing the blit, use the region, if any,
--- ./gfx/src/gtk/nsFontMetricsPango.cpp.SCREW	2005-05-03 15:53:09.000000000 -0400
+++ ./gfx/src/gtk/nsFontMetricsPango.cpp	2005-05-03 15:53:09.000000000 -0400
@@ -1138,7 +1138,8 @@
     return (NS_RENDERING_HINT_BIDI_REORDERING |
             NS_RENDERING_HINT_ARABIC_SHAPING | 
             NS_RENDERING_HINT_FAST_MEASURE | 
-            NS_RENDERING_HINT_TEXT_CLUSTERS);
+            NS_RENDERING_HINT_TEXT_CLUSTERS |
+            NS_RENDERING_HINT_REORDER_SPACED_TEXT);
 }
 
 /* static */
