diff -r 941bdd266217 dmesg.c
--- a/dmesg.c	Mon Jun 09 23:32:03 2008 -0400
+++ b/dmesg.c	Fri Jun 13 20:54:24 2008 -0400
@@ -40,6 +40,8 @@
 
 static char *linelevel;
 static int linecount;
+
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
 
 
 /*
@@ -354,6 +356,7 @@
 	struct stat statb;
 	FILE *file;
 	int ret;
+	size_t buflen;
 
 	memset(&statb, 0, sizeof(statb));
 
@@ -366,9 +369,15 @@
 	 * in theory there's a race here, since someone could spew
 	 * to /var/log/messages before we read it in... we try to
 	 * deal with it by reading at most 1023 bytes extra. If there's
-	 * more than that.. any oops will be in dmesg anyway
+	 * more than that.. any oops will be in dmesg anyway.
+	 * Do not try to allocate an absurt amount of memory; ignore
+	 * older log messages because they are unlikely to have
+	 * sufficiently recent data to be useful.  32MB is more
+	 * than enough; it's not worth looping through more log
+	 * if the log is larger than that.
 	 */
-	buffer = calloc(statb.st_size+1024, 1);
+	buflen = MAX(statb.st_size+1024, 32*1024*1024);
+	buffer = calloc(buflen, 1);
 	assert(buffer != NULL);
 
 	file = fopen(filename, "rm");
@@ -376,11 +385,12 @@
 		free(buffer);
 		return;
 	}
-	ret = fread(buffer, 1, statb.st_size+1023, file);
+	fseek(file, -buflen, SEEK_END);
+	ret = fread(buffer, 1, buflen-1, file);
 	fclose(file);
 
 	if (ret > 0)
-		extract_oops(buffer, statb.st_size+1023, issyslog);
+		extract_oops(buffer, buflen-1, issyslog);
 	free(buffer);
 	if (opted_in >= 2)
 		submit_queue();
