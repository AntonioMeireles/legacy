diff -r d2ab8c56cb68 kerneloops-applet.c
--- a/kerneloops-applet.c	Mon Jun 09 19:39:23 2008 -0400
+++ b/kerneloops-applet.c	Mon Jun 09 23:31:53 2008 -0400
@@ -34,9 +34,13 @@
 
 #include <stdio.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
 #include <locale.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
 
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus.h>
@@ -65,6 +69,7 @@
 
 
 int user_preference;
+static char *detail_file_name;
 
 static void write_config(char *permission)
 {
@@ -92,6 +97,7 @@
 			"org.kerneloops.submit.permission", answer);
 	dbus_connection_send(bus, message, NULL);
 	dbus_message_unref(message);
+	detail_file_name = NULL;
 }
 
 /*
@@ -118,11 +124,103 @@
 	char *answer = (char *) user_data;
 
 	send_permission(answer);
+	detail_file_name = NULL;
 	if (strcmp(answer, "always") == 0)
 		write_config("always");
 	if (strcmp(answer, "never") == 0)
 		write_config("never");
 	gtk_status_icon_set_visible(statusicon, FALSE);
+}
+
+/* Called only from the detail window */
+static void send_action(NotifyNotification __unused *notify,
+			gchar __unused *action, gpointer __unused user_data)
+{
+	send_permission("yes");
+}
+
+
+/* Called only to display details */
+static void detail_action(NotifyNotification __unused *notify,
+			  gchar __unused *action, gpointer __unused user_data)
+{
+	GtkWidget *dialog;
+	GtkWidget *scrollwindow;
+	GtkWidget *view;
+	GtkTextBuffer *buffer;
+	GtkWidget *button_cancel;
+	GtkWidget *button_send;
+	char *detail_data;
+	struct stat statb;
+	int detail_fd;
+	int ret;
+
+	/* If anything goes wrong, return as early as possible... */
+
+	if (!detail_file_name)
+		return;
+
+        memset(&statb, 0, sizeof(statb));
+	ret = stat(detail_file_name, &statb);
+	if (statb.st_size < 1 || ret != 0)
+		return;
+
+	detail_fd = open(detail_file_name, O_RDONLY);
+	if (detail_fd < 0)
+		return;
+
+	detail_data = malloc(statb.st_size+1);
+	if (!detail_data)
+		return;
+	
+	if (read(detail_fd, detail_data, statb.st_size) != statb.st_size) {
+		free(detail_data);
+		return;
+	}
+	close(detail_fd);
+
+	dialog = gtk_dialog_new();
+	gtk_window_set_title(GTK_WINDOW(dialog), _("Kernel failure details"));
+	gtk_widget_set_size_request(dialog, 600, 400);
+	scrollwindow = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW (scrollwindow),
+				       GTK_POLICY_AUTOMATIC,
+				       GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), scrollwindow, 
+			   TRUE, TRUE, 0);
+	view = gtk_text_view_new();
+	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (view));
+	gtk_text_buffer_set_text(buffer, detail_data, -1);
+	free(detail_data);
+	gtk_scrolled_window_add_with_viewport(
+		GTK_SCROLLED_WINDOW(scrollwindow), view);
+	gtk_text_view_set_editable(GTK_TEXT_VIEW(view), FALSE);
+	button_send = gtk_button_new_with_label (_("Send"));
+	GTK_WIDGET_SET_FLAGS(button_send, GTK_CAN_DEFAULT);
+	gtk_widget_grab_default(button_send);
+	button_cancel = gtk_button_new_with_label (_("Cancel"));
+
+	g_signal_connect(G_OBJECT(dialog), "delete_event",
+			 G_CALLBACK(gtk_widget_destroy), dialog);
+	g_signal_connect_swapped(G_OBJECT(button_cancel), "clicked",
+		         G_CALLBACK(gtk_widget_destroy),
+			 G_OBJECT(dialog));
+	g_signal_connect(G_OBJECT(dialog), "destroy",
+			 G_CALLBACK(gtk_widget_destroy),
+			 G_OBJECT(dialog));
+	g_signal_connect(G_OBJECT(button_send), "clicked",
+			 G_CALLBACK(send_action), NULL);
+  
+	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		button_send, TRUE, TRUE, 0);
+	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		button_cancel, TRUE, TRUE, 0);
+
+	gtk_widget_show(view);
+	gtk_widget_show(button_send);
+	gtk_widget_show(button_cancel);
+	gtk_widget_show(scrollwindow);
+	gtk_widget_show(dialog);
 }
 
 static void got_a_message(void)
@@ -160,6 +258,11 @@
 						callback, "no", NULL);
 	notify_notification_add_action(notify, "never", _("Never"),
 						callback, "never", NULL);
+	if (detail_file_name) {
+		notify_notification_add_action(notify,
+			"details", _("Show Details"),
+			detail_action, "details", NULL);
+	}
 
 	notify_notification_show(notify, NULL);
 }
@@ -272,6 +375,9 @@
 		} else {
 			/* ok time to ask the user */
 			gtk_status_icon_set_visible(statusicon, TRUE);
+			dbus_message_get_args(message, NULL,
+			        DBUS_TYPE_STRING, &detail_file_name,
+			        DBUS_TYPE_INVALID);
 			got_a_message();
 			gtk_status_icon_set_visible(statusicon, FALSE);
 		}
diff -r d2ab8c56cb68 kerneloops.c
--- a/kerneloops.c	Mon Jun 09 19:39:23 2008 -0400
+++ b/kerneloops.c	Mon Jun 09 23:31:53 2008 -0400
@@ -90,13 +90,18 @@
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-void dbus_ask_permission(void)
+void dbus_ask_permission(char * detail_file_name)
 {
 	DBusMessage *message;
 	if (!bus)
 		return;
 	message = dbus_message_new_signal("/org/kerneloops/submit/permission",
 			"org.kerneloops.submit.permission", "ask");
+	if (detail_file_name) {
+		dbus_message_append_args(message,
+			DBUS_TYPE_STRING, &detail_file_name,
+			DBUS_TYPE_INVALID);
+	}
 	dbus_connection_send(bus, message, NULL);
 	dbus_message_unref(message);
 }
diff -r d2ab8c56cb68 kerneloops.h
--- a/kerneloops.h	Mon Jun 09 19:39:23 2008 -0400
+++ b/kerneloops.h	Mon Jun 09 23:31:53 2008 -0400
@@ -39,7 +39,7 @@
 extern void read_config_file(char *filename);
 
 extern void ask_permission(void);
-extern void dbus_ask_permission(void);
+extern void dbus_ask_permission(char * detail_file_name);
 extern void dbus_say_thanks(char *url);
 
 extern int opted_in;
diff -r d2ab8c56cb68 submit.c
--- a/submit.c	Mon Jun 09 19:39:23 2008 -0400
+++ b/submit.c	Mon Jun 09 23:31:53 2008 -0400
@@ -28,6 +28,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <syslog.h>
+#include <sys/stat.h>
 
 #include <asm/unistd.h>
 
@@ -64,6 +65,11 @@
  */
 static struct oops *queued_oopses;
 static int newoops;
+
+/* For communicating details to the applet, we write the
+ * details in a file, and provide the filename to the applet
+ */
+static char *detail_filename;
 
 
 static unsigned int checksum(char *ptr)
@@ -103,6 +109,46 @@
 	new->text = strdup(oops);
 	queued_oopses = new;
 	newoops = 1;
+}
+
+
+void write_detail_file(void)
+{
+	int temp_fileno;
+	FILE *tmpf;
+	struct oops *oops;
+	int count = 0;
+
+	detail_filename = strdup("/tmp/kerneloops.XXXXXX");
+	temp_fileno = mkstemp(detail_filename);
+	if (temp_fileno < 0) {
+		free(detail_filename);
+		detail_filename = NULL;
+		return;
+	}
+	/* regular user must be able to read this detail file to be
+	 * useful; there is nothing worth doing if fchmod fails.
+	 */
+	fchmod(temp_fileno, 0644);
+	tmpf = fdopen(temp_fileno, "w");
+	oops = queued_oopses;
+	while (oops) {
+		count++; /* Users are not programmers, start at 1 */
+		fprintf(tmpf, "Kernel failure message %d:\n", count);
+		fprintf(tmpf, oops->text);
+		fprintf(tmpf, "\n\n");
+		oops = oops->next;
+	}
+	fclose(tmpf);
+	close(temp_fileno);
+}
+
+void unlink_detail_file(void)
+{
+	if (detail_filename) {
+		unlink(detail_filename);
+		free(detail_filename);
+	}
 }
 
 
@@ -217,8 +263,10 @@
 	 * If we've reached the maximum count, we'll exit the program,
 	 * the program won't do any useful work anymore going forward.
 	 */
-	if (submitted >= MAX_CHECKSUMS-1)
+	if (submitted >= MAX_CHECKSUMS-1) {
+		unlink_detail_file();
 		exit(EXIT_SUCCESS);
+	}
 }
 
 void clear_queue(void)
@@ -245,7 +293,8 @@
 		return;
 	pinged = 0;
 	newoops = 0;
-	if (queued_oopses)
-		dbus_ask_permission();
+	if (queued_oopses) {
+		write_detail_file();
+		dbus_ask_permission(detail_filename);
+	}
 }
-
