diff -u -B -r1.139 configure.in
--- configure.in	30 Jan 2006 04:49:14 -0000	1.139
+++ configure.in	31 Jan 2006 05:48:32 -0000
@@ -2,7 +2,7 @@
 
 AM_CONFIG_HEADER(config.h)
 
-AM_INIT_AUTOMAKE(muine, 0.8.4)
+AM_INIT_AUTOMAKE(muine, 0.8.4.99)
 
 AM_MAINTAINER_MODE
 
@@ -20,7 +20,8 @@
 dnl Version dependencies
 
 LIBXINE_REQUIRED=1.0.0
-GSTREAMER_REQUIRED=0.8.0
+GSTREAMER_REQUIRED=0.10.0
+GSTREAMER_OLD_REQUIRED=0.8.0
 GTK_REQUIRED=2.6
 ICON_THEME_REQUIRED=2.10
 MONO_REQUIRED=1.1
@@ -30,19 +31,29 @@
 
 dnl Audio backend stuff
 AC_ARG_ENABLE(xine, [  --enable-xine=[no/yes]    compile with libxine support.],,enable_xine=no)
+AC_ARG_ENABLE(xine, [  --enable-gstreamer=[0.8/0.10]  specify the gstreamer version.],,)
 
 if test "x$enable_xine" = "xyes"; then
    audio_pkgconfig="libxine >= $LIBXINE_REQUIRED"
    have_xine=yes
    AC_DEFINE(HAVE_XINE, 1, xine support)
 else
-   audio_pkgconfig="gstreamer-0.8 >= $GSTREAMER_REQUIRED gstreamer-gconf-0.8 >= $GSTREAMER_REQUIRED"
+   PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 >= $GSTREAMER_REQUIRED, have_gstreamer=yes, have_gstreamer=no)
+   if test "x$enable_gstreamer" = "x0.8" -o "x$have_gstreamer" = "xno"; then
+      have_gstreamer_old=yes
+      have_gstreamer=no
+      audio_pkgconfig="gstreamer-0.8 >= $GSTREAMER_OLD_REQUIRED"
+      AC_DEFINE(HAVE_GST_OLD, 1, gstreamer 0.8.x support)
+   else
+      audio_pkgconfig="gstreamer-0.10 >= $GSTREAMER_REQUIRED"
+      AC_DEFINE(HAVE_GST, 1, gstreamer 0.10.x support)
+   fi
    have_xine=no
-   AC_DEFINE(HAVE_GST, 1, gstreamer support)
 fi
 
 AM_CONDITIONAL(HAVE_XINE, test "x$have_xine" = "xyes")
-AM_CONDITIONAL(HAVE_GST, test "x$have_xine" = "xno")
+AM_CONDITIONAL(HAVE_GST, test "x$have_gstreamer" = "xyes")
+AM_CONDITIONAL(HAVE_GST_OLD, test "x$have_gstreamer_old" = "xyes")
 
 dnl Pkgconfig
 PKG_CHECK_MODULES(MUINE,
Index: libmuine/Makefile.am
===================================================================
RCS file: /cvs/gnome/muine/libmuine/Makefile.am,v
retrieving revision 1.24
diff -u -B -r1.24 Makefile.am
--- libmuine/Makefile.am	30 Jan 2006 04:45:49 -0000	1.24
+++ libmuine/Makefile.am	31 Jan 2006 05:48:32 -0000
@@ -32,9 +32,14 @@
 gst_sources = player-gst.c
 endif
 
+if HAVE_GST_OLD
+gst_old_sources = player-gst-0.8.c
+endif
+
 libmuine_la_SOURCES =			\
 	$(xine_sources) 		\
 	$(gst_sources)			\
+	$(gst_old_sources)		\
 	macros.h			\
 	player.h			\
 	metadata.c			\
Index: libmuine/player-gst.c
===================================================================
RCS file: /cvs/gnome/muine/libmuine/player-gst.c,v
retrieving revision 1.15
diff -u -B -r1.15 player-gst.c
--- libmuine/player-gst.c	29 Jan 2006 07:12:57 -0000	1.15
+++ libmuine/player-gst.c	31 Jan 2006 05:48:33 -0000
@@ -24,7 +24,6 @@
 #include <string.h>
 #include <math.h>
 #include <gst/gst.h>
-#include <gst/gconf/gconf.h>
 #include <libgnomevfs/gnome-vfs-utils.h>
 #include <glib/gi18n.h>
 
@@ -34,17 +33,9 @@
 static void player_class_init (PlayerClass     *klass);
 static void player_init       (Player          *player);
 static void player_finalize   (GObject         *object);
-static void eos_cb            (GstElement      *sink,
-		               Player          *player);
-static void error_cb          (GstElement      *element,
-	                       GstElement      *source,
-	                       GError          *error,
-                               char            *debug,
-	                       Player          *player);
-static void state_change_cb   (GstElement      *play,
-			       GstElementState  old_state,
-		               GstElementState  new_state,
-			       Player          *player);
+static gboolean bus_message_cb (GstBus *bus,
+				GstMessage *message,
+				gpointer data);
 static gboolean tick_timeout  (Player          *player);
 
 enum {
@@ -62,7 +53,6 @@
 	int	    cur_volume;
 	double      volume_scale;
 
-	guint	    eos_idle_id;
 	guint       iterate_idle_id;
 	guint       tick_timeout_id;
 
@@ -158,7 +148,6 @@
 	g_timer_stop (priv->timer);
 	priv->timer_add = 0;
 
-	priv->eos_idle_id = 0;
 	priv->tick_timeout_id = g_timeout_add (200, (GSourceFunc) tick_timeout, player);
 
 	priv->play = gst_element_factory_make ("playbin", "play");
@@ -168,7 +157,7 @@
 		return;
 	}
 
-	sink = gst_gconf_get_default_audio_sink ();
+	sink = gst_element_factory_make ("gconfaudiosink", "sink");
 	if (!sink) {
 		*error = g_strdup (_("Could not render default GStreamer audio output sink"));
 
@@ -178,20 +167,8 @@
 	g_object_set (G_OBJECT (priv->play), "audio-sink",
 		      sink, NULL);
 
-	g_signal_connect (priv->play,
-			  "error",
-			  G_CALLBACK (error_cb),
-			  player);
-
-	g_signal_connect (priv->play,
-			  "eos",
-			  G_CALLBACK (eos_cb),
-			  player);
-
-	g_signal_connect (priv->play,
-			  "state_change",
-			  G_CALLBACK (state_change_cb),
-			  player);
+	gst_bus_add_watch (gst_pipeline_get_bus (GST_PIPELINE (priv->play)),
+			   bus_message_cb, player);
 }
 
 static void
@@ -233,7 +210,10 @@
 static gboolean
 tick_timeout (Player *player)
 {
-	if (gst_element_get_state (player->priv->play) != GST_STATE_PLAYING)
+	GstState state;
+
+	gst_element_get_state (player->priv->play, &state, NULL, 0);
+	if (state != GST_STATE_PLAYING)
 		return TRUE;
 
 	g_signal_emit (player, signals[TICK], 0, player_tell (player));
@@ -242,72 +222,16 @@
 }
 
 static gboolean
-eos_idle_cb (Player *player)
-{
-	player->priv->timer_add += floor (g_timer_elapsed (player->priv->timer, NULL) + 0.5);
-	g_timer_stop (player->priv->timer);
-	g_timer_reset (player->priv->timer);
-
-	player->priv->eos_idle_id = 0;
-
-	g_signal_emit (player, signals[END_OF_STREAM], 0);
-
-	return FALSE;
-}
-
-static void
-eos_cb (GstElement *UNUSED(sink), Player *player)
-{
-	player->priv->eos_idle_id = g_idle_add ((GSourceFunc) eos_idle_cb, player);
-}
-
-typedef struct {
-	Player *player;
-	char *error;
-} PlayerError;
-
-static gboolean
-error_idle_cb (PlayerError *data)
-{
-	g_signal_emit (data->player, signals[ERROR], 0, data->error);
-
-	g_free (data->error);
-	g_free (data);
-
-	return FALSE;
-}
-
-static void
-error_cb (GstElement *UNUSED(element),
-	  GstElement *UNUSED(source),
-	  GError     *error,
-          char       *UNUSED(debug),
-	  Player     *player)
-{
-	PlayerError *data = g_new0 (PlayerError, 1);
-
-	/* Stop playing so we don't get repeated error messages. Might lead to
-	 * troubles with threads, not sure.
-	 */
-	player_stop (player);
-
-	data->player = player;
-	data->error = g_strdup (error->message);
-
-	g_idle_add ((GSourceFunc) error_idle_cb, data);
-}
-
-static gboolean
 iterate_cb (Player *player)
 {
 	gboolean res;
+	GstState state;
 
-	if (!GST_FLAG_IS_SET (player->priv->play, GST_BIN_SELF_SCHEDULABLE)) {
-		res = gst_bin_iterate (GST_BIN (player->priv->play));
-	} else {
-		g_usleep (100);
-		res = (gst_element_get_state (player->priv->play) == GST_STATE_PLAYING);
-	}
+	g_usleep (100);
+	
+	gst_element_get_state (player->priv->play, &state, NULL, 0);
+	
+	res = (state == GST_STATE_PLAYING);
 
 	if (!res)
 		player->priv->iterate_idle_id = 0;
@@ -315,20 +239,57 @@
 	return res;
 }
 
-static void
-state_change_cb (GstElement *UNUSED(play), GstElementState old_state,
-		 GstElementState new_state, Player *player)
-{
-	if (old_state == GST_STATE_PLAYING) {
-		if (player->priv->iterate_idle_id != 0) {
-			g_source_remove (player->priv->iterate_idle_id);
-			player->priv->iterate_idle_id = 0;
+static gboolean
+bus_message_cb (GstBus *UNUSED(bus),
+		GstMessage *message,
+		gpointer data)
+{
+	Player *player = (Player *) data;
+	char *debug;
+	GError *err;
+	GstState old_state, new_state;
+
+	switch (GST_MESSAGE_TYPE (message)) {
+	case GST_MESSAGE_ERROR:
+		gst_message_parse_error (message, &err, &debug);
+
+		/* Stop playing so we don't get repeated error messages. 
+		   Might lead to troubles with threads, not sure.
+		*/
+		player_stop (player);
+		
+		g_signal_emit (player, signals[ERROR], 0, g_strdup (err->message));
+		break;
+
+	case GST_MESSAGE_EOS:
+		player->priv->timer_add += floor (g_timer_elapsed (player->priv->timer, NULL) + 0.5);
+		g_timer_stop (player->priv->timer);
+		g_timer_reset (player->priv->timer);
+		
+		g_signal_emit (player, signals[END_OF_STREAM], 0);
+		break;
+
+	case GST_MESSAGE_STATE_CHANGED:
+		gst_message_parse_state_changed (message, &old_state, &new_state, NULL);
+		
+		if (old_state == GST_STATE_PLAYING) {
+			if (player->priv->iterate_idle_id != 0) {
+				g_source_remove (player->priv->iterate_idle_id);
+				player->priv->iterate_idle_id = 0;
+			}
+		} else if (new_state == GST_STATE_PLAYING) {
+			if (player->priv->iterate_idle_id != 0)
+				g_source_remove (player->priv->iterate_idle_id);
+			player->priv->iterate_idle_id = g_idle_add ((GSourceFunc) iterate_cb, player);
 		}
-	} else if (new_state == GST_STATE_PLAYING) {
-		if (player->priv->iterate_idle_id != 0)
-			g_source_remove (player->priv->iterate_idle_id);
-		player->priv->iterate_idle_id = g_idle_add ((GSourceFunc) iterate_cb, player);
+
+		break;
+
+	default:
+		break;
 	}
+
+	return TRUE;
 }
 
 gboolean
@@ -377,11 +338,6 @@
 {
 	g_return_if_fail (IS_PLAYER (player));
 
-	if (player->priv->eos_idle_id > 0) {
-		g_source_remove (player->priv->eos_idle_id);
-		player->priv->eos_idle_id = 0;
-	}
-
 	g_free (player->priv->current_file);
 	player->priv->current_file = NULL;
 
@@ -469,9 +425,12 @@
 {
 	g_return_if_fail (IS_PLAYER (player));
 
-	gst_element_seek (player->priv->play, GST_SEEK_METHOD_SET |
-		          GST_SEEK_FLAG_FLUSH | GST_FORMAT_TIME,
-		          t * GST_SECOND);
+	gst_element_seek (player->priv->play, 1.0,
+			  GST_FORMAT_TIME,
+			  GST_SEEK_FLAG_FLUSH,
+			  GST_SEEK_TYPE_SET,
+			  t * GST_SECOND,
+			  0, 0);
 
 	g_timer_reset (player->priv->timer);
 	player->priv->timer_add = t;
