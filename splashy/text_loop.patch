--- src/splashy_functions.c.original	2007-10-22 13:24:48.000000000 +0300
+++ src/splashy_functions.c	2007-10-24 13:54:30.000000000 +0300
@@ -60,6 +60,8 @@
 #include <sys/types.h>          /* needed by regex.h regcomp() */
 #include <regex.h>              /* regexec() regcomp() */
 #include <sys/poll.h>           /* poll() */
+#include <sys/stat.h>
+#include <ctype.h>
 #ifdef __linux__
 /*
  * #include <sys/mount.h> USE for mounting /proc if not mounted yet 
@@ -91,7 +93,7 @@ static gboolean read_console = FALSE;   
                                          * /dev/vcs* files */
 static gboolean show_textbox_area = FALSE;      /* flag to toggle showing
                                                  * textbox area */
-static gboolean switched_to_verbose = FALSE;    /* flag to know when verbose
+/*static gboolean switched_to_verbose = FALSE;    * flag to know when verbose
                                                  * image is displayed */
 static gboolean F2_toggle_pressed = FALSE;      /* keeps track of the depress 
                                                  * F2 key */
@@ -682,6 +684,216 @@ _switch_to_verbose_image ()
  * - make use of real console
  * - this is a slow function
  */
+void
+print_lines(char *start, int width, int max_lines, int scroll) {
+  char *cp, *cp2;
+  int i;
+  char c;
+  // for each line
+  for (cp = start, i = 0; i < max_lines ; cp += width, i++) {
+    int empty_line = 1;
+    for (cp2 = cp ; cp2 < cp + width; cp2++ ) { // check if line is empty
+      if (!isspace(*cp2)) {
+        empty_line = 0;
+        break;
+      }
+    }
+    if (empty_line) {  // skip empty lines
+      continue;
+    }
+    cp2 = cp + width - 1;		// cp2 points to the last char in line
+    while (isspace(*cp2) && cp2 > cp) cp2--; // cp2 skips all spaces
+    if (!isspace(*cp2)) { // cp2 to point to space or to the next line
+      cp2++;		  // or to null byte at the end
+    }
+    c = *cp2;		// save byte
+    *cp2 = '\0';	// null-terminate
+    // printf("%s\n", cp);	// print line
+    if (scroll) {
+      splashy_printline_s(cp);
+    }
+    else {
+      splashy_printline_ns(cp);
+    }
+    *cp2 = c;		// restore byte
+  }
+}
+
+// diff, but with a lot of assumptions
+char *
+find_new(char *buf_old, char *buf_new, int width, int height, int *scrollp) {
+  char *cp_old, *cp_new;
+  int line_old, line_new;
+  *scrollp = 1;
+  for (cp_old = buf_old, line_old = 0 ; line_old < height ;
+       cp_old += width, line_old++) { // try for each line of old screen
+    for (cp_new = buf_new, line_new = 0 ;
+         line_new <= line_old && line_new < height ;
+         cp_new += width, line_new++) { // try for each line of new one
+      if (!memcmp(cp_old, cp_new, width)) { // lines match, compare the rest
+        char *cp2_old, *cp2_new;
+        int line2_old, line2_new;
+        int occasional_match = 0;
+        for (cp2_old = cp_old, line2_old = line_old,
+             cp2_new = cp_new, line2_new = line_new ;
+             line2_new < height && line2_old < height ;
+             cp2_old += width, line2_old++, cp2_new += width, line2_new++) {
+          if (memcmp(cp2_old, cp2_new, width)) { // no match
+            char *cp3;
+
+            // nothing but spaces after cp2_old
+            for (cp3 = cp2_old ; *cp3 && isspace(*cp3) ; cp3++);
+            if (!*cp3) {
+              return cp2_new;  // return pointer to the new line on new scr
+            }
+
+            // one line and then only spaces after cp2_old
+            //   ("smth  -> smth [OK]"  case)
+            //   we use cp2_old + width here because line2_old < height
+            for (cp3 = cp2_old + width ; *cp3 && isspace(*cp3) ; cp3++);
+            if (!*cp3) {
+              *scrollp = 0;
+              return cp2_new;  // return pointer to the new line on new scr
+            }
+
+            // just hit similar lines in the middle
+            occasional_match = 1;
+            break;
+          }
+        }
+        // match or end reached
+        if (occasional_match) {
+          continue;
+        }
+        //printf("buf_new = 0x%x, cp2_new = 0x%x, diff = %d\n",
+        //  buf_new, cp2_new, cp2_new - buf_new);
+        return cp2_new;
+      }
+    }
+  }
+  return buf_new;
+}
+
+inline void *
+verbose_text_loop (void *data) {
+  int fd, j;
+  char *buf = NULL, *buf2 = NULL, *cp;
+  int buf_len = -1;
+  int width = 0, height = 0;
+  unsigned char attr[2] = {0,0};
+  const gchar *error_pattern;
+  gboolean autoverbose;
+  int scroll;
+
+  autoverbose = FALSE;    /* assume we don't need verbose mode for now */
+  error_pattern = "(FATAL|fail|error|abort|===|recovering journal)";
+
+  /*
+   * get autoverboseonerror from config file and set autoverbose
+   * accordingly 
+   */
+  if (g_ascii_strncasecmp
+      (splashy_get_config_string (SPL_AUTO_VERBOSE_ON_ERROR), "yes", 3) == 0)
+	  autoverbose = TRUE;
+
+  /*
+   * set the cancellation parameters -- - Enable thread cancellation - 
+   * Defer the action of the cancellation 
+   */
+  pthread_setcancelstate (PTHREAD_CANCEL_ENABLE, NULL);
+  pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED, NULL);
+
+  while (buf_len < 0) {
+    fd = open("/dev/vcsa1", O_RDONLY, 0);
+    if (fd < 0) {
+      mkdir("/dev", 0755);
+#define MKDEV(ma,mi)    ((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
+      mknod("/dev/vcsa1", (S_IFCHR|0600), MKDEV(7,129));
+      fd = open("/dev/vcsa1", O_RDONLY, 0);
+      if (fd < 0) {
+        sched_yield ();
+        perror("cant open /dev/vcsa1");
+        // pthread_exit(NULL);
+        continue;
+      }
+    }
+    j = read(fd, attr, 2);
+    if (j != 2) {
+      perror("cant read /dev/vcsa1");
+      pthread_exit(NULL);
+    }
+    close(fd);
+    height = attr[0];
+    width = attr[1];
+    buf_len = width*height;
+  }
+  if (!buf) {
+    buf = malloc(buf_len+1);
+    buf2 = malloc(buf_len+1);
+  }
+  if (!buf || ! buf2) {
+    printf("oom");
+    pthread_exit(NULL);
+  }
+  buf[buf_len] = '\0';
+  buf2[buf_len] = '\0';
+
+  fd = open("/dev/vcs1", O_RDONLY, 0);
+  if (fd < 0) {
+    mknod("/dev/vcs1", (S_IFCHR|0600), MKDEV(7,1));
+    fd = open("/dev/vcs1", O_RDONLY, 0);
+    if (fd < 0) {
+      perror("cant open /dev/vcs1");
+      pthread_exit(NULL);
+    }
+  }
+  //j = read(fd, buf2, buf_len);
+  //if (j != buf_len) {
+  //  perror("cant read /dev/vcs1");
+  //  pthread_exit(NULL);
+  //}
+  memset(buf2, ' ', buf_len); // splashy should print current contents on F2
+  for (;;) {
+    if (exiting) {
+      DEBUG_PRINT ("Not reading console at all...");
+      /*
+       * this thread shouldn't be holding a lock on this
+       * but... 
+       */
+      sched_yield();
+      usleep (200);
+      continue;
+    }
+    lseek(fd, 0, SEEK_SET);
+    j = read(fd, buf, buf_len);
+    if (F2_toggle_pressed != TRUE) {
+      if (autoverbose == TRUE && search_pattern_str(error_pattern, buf, 1)) {
+        F2_toggle_pressed = TRUE;
+      }
+      else {
+        sched_yield();
+        usleep (200);
+        continue;
+      }
+    }
+    if (memcmp(buf, buf2, buf_len)) {
+      //printf("no match\n");
+      cp = find_new(buf2, buf, width, height, &scroll);
+      if (!*cp) {
+        printf("find_new() returns empty line\n");
+      }
+      print_lines(cp, width, height-(cp-buf)/width, scroll);
+      cp = buf;
+      buf = buf2;
+      buf2 = cp;
+    }
+    //else {
+    //  printf("match\n");
+    //}
+    usleep(200);
+  }
+}
+#if 0
 inline void *
 verbose_text_loop (void *data)
 {
@@ -907,6 +1119,7 @@ verbose_text_loop (void *data)
         g_string_free (device, TRUE);   /* never reached */
         pthread_exit (NULL);    /* never reached */
 }
+#endif
 inline void *
 socket_loop (void *data)
 {
--- src/splashy_video.c.orig	2007-10-18 16:25:18.000000000 +0300
+++ src/splashy_video.c	2007-10-23 20:30:34.000000000 +0300
@@ -1340,6 +1340,19 @@ splashy_reset_splash () {
     splashy_change_splash(_current_background);
 }
 
+void
+splashy_printline_scroll (const char * string, int const scroll);
+
+/**
+ * Print a line of text in the textbox and NOT scroll down
+ *
+ * @return
+ */
+void
+splashy_printline_ns (const char * string)
+{
+	splashy_printline_scroll (string, 0);
+}
 /**
  * Print a line of text in the textbox.
  *
@@ -1404,6 +1417,12 @@ splashy_printline (const char * string)
 void
 splashy_printline_s (const char * string)
 {
+	splashy_printline_scroll (string, 1);
+}
+
+void
+splashy_printline_scroll (const char * string, const int scroll)
+{
         if (video.textbox == NULL)
                 return;
 
@@ -1429,7 +1448,9 @@ splashy_printline_s (const char * string
                                          video.textbox->offscreen,
                                          NULL, 0, 0);
 
-        last_text_y_position += abs (video.fontdesc.height * 2);
+	if (scroll || last_text_y_position == 0) {
+		last_text_y_position += abs (video.fontdesc.height * 2);
+	}
 
         /*
          * Draw string to the clipped surface 
--- src/splashy.h.orig	2007-10-23 17:38:09.000000000 +0300
+++ src/splashy.h	2007-10-23 20:10:09.000000000 +0300
@@ -47,11 +47,16 @@ void splashy_set_progressbar_visible(int
 void splashy_reset_progressbar_counters();
 
 /*
- * allows to print a single message to the center of the textbox area
- * reseting the old one
+ * allows to print a single message to the top of the textbox area
+ * reseting all text
  */
 void splashy_printline (const char * string);
 /*
+ * allows to print a single message to the current pos of the textbox area
+ * on the top of the old one
+ */
+void splashy_printline_ns (const char * string);
+/*
  * allows to print a message appended to the end of the textbox area
  * keeping the old one
  */
--- themes/default/theme.xml.orig	2007-10-24 14:25:03.000000000 +0300
+++ themes/default/theme.xml	2007-10-24 14:25:19.000000000 +0300
@@ -118,7 +118,7 @@
             <!-- font file to use, path relative to theme -->
             <font>
                 <file>FreeSans.ttf</file>
-                <height>10</height>
+                <height>2</height>
             </font>
             <!-- here you can set the color of the text/font...
             set the amount of red, green, blue and alpha channel. 
