--- src/splashy_functions.c.orig	2008-04-07 20:22:45.000000000 +0300
+++ src/splashy_functions.c	2008-04-07 20:23:17.000000000 +0300
@@ -60,6 +60,8 @@
 #include <sys/types.h>          /* needed by regex.h regcomp() */
 #include <regex.h>              /* regexec() regcomp() */
 #include <sys/poll.h>           /* poll() */
+#include <sys/stat.h>
+#include <ctype.h>
 #ifdef __linux__
 /*
  * #include <sys/mount.h> USE for mounting /proc if not mounted yet 
@@ -89,7 +91,7 @@ static gboolean exiting = FALSE;        
                                          * to true at cmd_exit() */
 static gboolean read_console = FALSE;   /* flag to turn on/off reading the
                                          * /dev/vcs* files */
-static gboolean switched_to_verbose = FALSE;    /* flag to know when verbose
+/*static gboolean switched_to_verbose = FALSE;    * flag to know when verbose
                                                  * image is displayed */
 static gboolean F2_toggle_pressed = FALSE;      /* keeps track of the depress 
                                                  * F2 key */
@@ -643,6 +645,218 @@ _switch_to_verbose_image ()
  * - make use of real console
  * - this is a slow function
  */
+void
+print_lines(char *start, int width, int max_lines, int scroll) {
+  char *cp, *cp2;
+  int i;
+  char c;
+  // for each line
+  for (cp = start, i = 0; i < max_lines ; cp += width, i++) {
+    int empty_line = 1;
+    for (cp2 = cp ; cp2 < cp + width; cp2++ ) { // check if line is empty
+      if (!isspace(*cp2)) {
+        empty_line = 0;
+        break;
+      }
+    }
+    if (empty_line) {  // skip empty lines
+      continue;
+    }
+    cp2 = cp + width - 1;		// cp2 points to the last char in line
+    while (isspace(*cp2) && cp2 > cp) cp2--; // cp2 skips all spaces
+    if (!isspace(*cp2)) { // cp2 to point to space or to the next line
+      cp2++;		  // or to null byte at the end
+    }
+    c = *cp2;		// save byte
+    *cp2 = '\0';	// null-terminate
+    // printf("%s\n", cp);	// print line
+    if (scroll) {
+      splashy_printline_s(cp);
+    }
+    else {
+      splashy_printline_ns(cp);
+    }
+    *cp2 = c;		// restore byte
+  }
+}
+
+// diff, but with a lot of assumptions
+// - *scrollp is set to 0 if new line should overwrites previous one,
+//   so to reproduce screen layout we don't need to scroll when printing
+char *
+find_new(char *buf_old, char *buf_new, int width, int height, int *scrollp) {
+  char *cp_old, *cp_new;
+  int line_old, line_new;
+  *scrollp = 1;
+  for (cp_old = buf_old, line_old = 0 ; line_old < height ;
+       cp_old += width, line_old++) { // try for each line of old screen
+    for (cp_new = buf_new, line_new = 0 ;
+         line_new <= line_old && line_new < height ;
+         cp_new += width, line_new++) { // try for each line of new one
+      if (!memcmp(cp_old, cp_new, width)) { // lines match, compare the rest
+        char *cp2_old, *cp2_new;
+        int line2_old, line2_new;
+        int occasional_match = 0;
+        for (cp2_old = cp_old, line2_old = line_old,
+             cp2_new = cp_new, line2_new = line_new ;
+             line2_new < height && line2_old < height ;
+             cp2_old += width, line2_old++, cp2_new += width, line2_new++) {
+          if (memcmp(cp2_old, cp2_new, width)) { // no match
+            char *cp3;
+
+            // nothing but spaces after cp2_old
+            for (cp3 = cp2_old ; *cp3 && isspace(*cp3) ; cp3++);
+            if (!*cp3) {
+              return cp2_new;  // return pointer to the new line on new scr
+            }
+
+            // one line and then only spaces after cp2_old
+            //   ("smth  -> smth [OK]"  case)
+            //   we use cp2_old + width here because line2_old < height
+            for (cp3 = cp2_old + width ; *cp3 && isspace(*cp3) ; cp3++);
+            if (!*cp3) {
+              *scrollp = 0;
+              return cp2_new;  // return pointer to the new line on new scr
+            }
+
+            // just hit similar lines in the middle
+            occasional_match = 1;
+            break;
+          }
+        }
+        // match or end reached
+        if (occasional_match) {
+          continue;
+        }
+        //printf("buf_new = 0x%x, cp2_new = 0x%x, diff = %d\n",
+        //  buf_new, cp2_new, cp2_new - buf_new);
+        return cp2_new;
+      }
+    }
+  }
+  return buf_new;
+}
+
+inline void *
+verbose_text_loop (void *data) {
+  int fd, j;
+  char *buf = NULL, *buf2 = NULL, *cp;
+  int buf_len = -1;
+  int width = 0, height = 0;
+  unsigned char attr[2] = {0,0};
+  const gchar *error_pattern;
+  gboolean autoverbose;
+  int scroll;
+
+  autoverbose = FALSE;    /* assume we don't need verbose mode for now */
+  error_pattern = "(FATAL|fail|error|abort|===|recovering journal)";
+
+  /*
+   * get autoverboseonerror from config file and set autoverbose
+   * accordingly 
+   */
+  if (g_ascii_strncasecmp
+      (splashy_get_config_string (SPL_AUTO_VERBOSE_ON_ERROR), "yes", 3) == 0)
+	  autoverbose = TRUE;
+
+  /*
+   * set the cancellation parameters -- - Enable thread cancellation - 
+   * Defer the action of the cancellation 
+   */
+  pthread_setcancelstate (PTHREAD_CANCEL_ENABLE, NULL);
+  pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED, NULL);
+
+  while (buf_len < 0) {
+    fd = open("/dev/vcsa1", O_RDONLY, 0);
+    if (fd < 0) {
+      mkdir("/dev", 0755);
+#define MKDEV(ma,mi)    ((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
+      mknod("/dev/vcsa1", (S_IFCHR|0600), MKDEV(7,129));
+      fd = open("/dev/vcsa1", O_RDONLY, 0);
+      if (fd < 0) {
+        sched_yield ();
+        perror("cant open /dev/vcsa1");
+        // pthread_exit(NULL);
+        continue;
+      }
+    }
+    j = read(fd, attr, 2);
+    if (j != 2) {
+      perror("cant read /dev/vcsa1");
+      pthread_exit(NULL);
+    }
+    close(fd);
+    height = attr[0];
+    width = attr[1];
+    buf_len = width*height;
+  }
+  if (!buf) {
+    buf = malloc(buf_len+1);
+    buf2 = malloc(buf_len+1);
+  }
+  if (!buf || ! buf2) {
+    printf("oom");
+    pthread_exit(NULL);
+  }
+  buf[buf_len] = '\0';
+  buf2[buf_len] = '\0';
+
+  fd = open("/dev/vcs1", O_RDONLY, 0);
+  if (fd < 0) {
+    mknod("/dev/vcs1", (S_IFCHR|0600), MKDEV(7,1));
+    fd = open("/dev/vcs1", O_RDONLY, 0);
+    if (fd < 0) {
+      perror("cant open /dev/vcs1");
+      pthread_exit(NULL);
+    }
+  }
+  //j = read(fd, buf2, buf_len);
+  //if (j != buf_len) {
+  //  perror("cant read /dev/vcs1");
+  //  pthread_exit(NULL);
+  //}
+  memset(buf2, ' ', buf_len); // splashy should print current contents on F2
+  for (;;) {
+    if (exiting) {
+      DEBUG_PRINT ("Not reading console at all...");
+      /*
+       * this thread shouldn't be holding a lock on this
+       * but... 
+       */
+      sched_yield();
+      usleep (200);
+      continue;
+    }
+    lseek(fd, 0, SEEK_SET);
+    j = read(fd, buf, buf_len);
+    if (F2_toggle_pressed != TRUE) {
+      if (autoverbose == TRUE && search_pattern_str(error_pattern, buf, 1)) {
+        F2_toggle_pressed = TRUE;
+      }
+      else {
+        sched_yield();
+        usleep (200);
+        continue;
+      }
+    }
+    if (memcmp(buf, buf2, buf_len)) {
+      //printf("no match\n");
+      cp = find_new(buf2, buf, width, height, &scroll);
+      if (!*cp) {
+        printf("find_new() returns empty line\n");
+      }
+      print_lines(cp, width, height-(cp-buf)/width, scroll);
+      cp = buf;
+      buf = buf2;
+      buf2 = cp;
+    }
+    //else {
+    //  printf("match\n");
+    //}
+    usleep(200);
+  }
+}
+#if 0
 inline void *
 verbose_text_loop (void *data)
 {
@@ -868,6 +1082,7 @@ verbose_text_loop (void *data)
         g_string_free (device, TRUE);   /* never reached */
         pthread_exit (NULL);    /* never reached */
 }
+#endif
 inline void *
 socket_loop (void *data)
 {
@@ -1127,11 +1342,11 @@ _splashy_child (const gchar * seq)
                                                  * to manage  our keyboard  
                                                  * events and SplashyClient */
 
-        /*gint thr_id_f;          * Handles /dev/vcs1 text to be displayed to
+        gint thr_id_f;          /* Handles /dev/vcs1 text to be displayed to
                                  * splashy overlay textbox ... when pressing
                                  * F2 we launch a thread to handle the
                                  * console text */
-        /*pthread_t p_thread_f;*/
+        pthread_t p_thread_f;
 
         gboolean _preview = FALSE;
 
@@ -1205,8 +1420,8 @@ _splashy_child (const gchar * seq)
          */
         thr_id_d = pthread_create (&p_thread_d, NULL, keyevent_loop, NULL);
 
-        /*thr_id_f =
-                pthread_create (&p_thread_f, NULL, verbose_text_loop, NULL);*/
+        thr_id_f =
+                pthread_create (&p_thread_f, NULL, verbose_text_loop, NULL);
 
         /*
          * Wait till thread is finished reading the socket... ie 'forever' 
--- src/splashy_video.c.orig	2008-04-07 20:24:54.000000000 +0300
+++ src/splashy_video.c	2008-04-07 20:26:18.000000000 +0300
@@ -1431,6 +1431,19 @@ splashy_reset_splash ()
         splashy_change_splash (_current_background);
 }
 
+void
+splashy_printline_scroll (const char * string, int const scroll);
+
+/**
+ * Print a line of text in the textbox and NOT scroll down
+ *
+ * @return
+ */
+void
+splashy_printline_ns (const char * string)
+{
+	splashy_printline_scroll (string, 0);
+}
 /**
  * Prints a line of text in the textbox. Supports multi-lines split by new-lines (\n)
  * This displays regardless of whether the user wants
@@ -1496,6 +1509,12 @@ splashy_printline (const char *string)
 void
 splashy_printline_s (const char *string)
 {
+	splashy_printline_scroll (string, 1);
+}
+ 
+void
+splashy_printline_scroll (const char * string, const int scroll)
+{
         char *str;
         DFBRectangle rect;
         int x, y = 0, ls;
@@ -1513,7 +1532,12 @@ splashy_printline_s (const char *string)
         video.font->GetStringExtents (video.font, "_", -1, NULL, &rect);
         video.font->GetHeight (video.font, &ls);
         x = rect.w;
-        y = (ls / 2 + last_text_y_position) + ls;
+        if (scroll) {
+                y = (ls / 2 + last_text_y_position) + ls;
+        }
+        else {
+                y = last_text_y_position;
+        }
 
         str = strdup (string);
         /*
--- src/splashy.h.orig	2008-04-07 18:11:38.000000000 +0300
+++ src/splashy.h	2008-04-07 18:41:27.000000000 +0300
@@ -72,12 +72,18 @@ void splashy_set_textbox_area_visible (i
 int splashy_get_textbox_area_visible (void);
 
 /*
- * allows to print a single message to the center of the textbox area
- * reseting the old one
+ * allows to print a single message to the top of the textbox area
+ * reseting all text
  */
 void splashy_printline (const char *string);
 
 /*
+ * allows to print a single message to the current pos of the textbox area
+ * on the top of the old one
+ */
+void splashy_printline_ns (const char * string);
+
+/*
  * allows to print a message appended to the end of the textbox area
  * keeping the old one
  */
--- themes/default/theme.xml.orig	2007-10-24 14:25:03.000000000 +0300
+++ themes/default/theme.xml	2007-10-24 14:25:19.000000000 +0300
@@ -118,7 +118,7 @@
             <!-- font file to use, path relative to theme -->
             <font>
                 <file>FreeSans.ttf</file>
-                <height>10</height>
+                <height>2</height>
             </font>
             <!-- here you can set the color of the text/font...
             set the amount of red, green, blue and alpha channel. 
