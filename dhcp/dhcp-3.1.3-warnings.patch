diff -rupN dhcp-3.1-ESV-R3_orig/client/dhclient.c dhcp-3.1-ESV-R3/client/dhclient.c
--- dhcp-3.1-ESV-R3_orig/client/dhclient.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/client/dhclient.c	2011-10-10 11:30:40.000000000 -0400
@@ -132,7 +132,9 @@ int main (argc, argv, envp)
 #ifdef LIBDHCP
   libdhcp_control = libdhcp_ctl;
 #endif
+#ifndef LIBDHCP
 	int fd;
+#endif
 	int i;
 	struct servent *ent;
 	struct interface_info *ip;
@@ -146,7 +148,6 @@ int main (argc, argv, envp)
 	omapi_object_t *listener;
 	isc_result_t result;
 	int persist = 0;
-	int omapi_port;
 	int no_dhclient_conf = 0;
 	int no_dhclient_db = 0;
 	int no_dhclient_pid = 0;
@@ -1170,7 +1171,6 @@ void state_selecting (cpp)
 			picked = lp;
 			picked -> next = (struct client_lease *)0;
 		} else {
-		      freeit:
 			destroy_client_lease (lp);
 		}
 	}
@@ -1229,7 +1229,6 @@ void dhcpack (packet)
 	struct client_lease *lease;
 	struct option_cache *oc;
 	struct data_string ds;
-	int i;
 	
 	/* If we're not receptive to an offer right now, or if the offer
 	   has an unrecognizable transaction id, then just drop it. */
@@ -1394,8 +1393,6 @@ void dhcpack (packet)
 void bind_lease (client)
 	struct client_state *client;
 {
-	struct interface_info *ip = client -> interface;
-
 	/* Remember the medium. */
 	client -> new -> medium = client -> medium;
 
@@ -1464,7 +1461,6 @@ void state_bound (cpp)
 	void *cpp;
 {
 	struct client_state *client = cpp;
-	int i;
 	struct option_cache *oc;
 	struct data_string ds;
 
@@ -1507,7 +1503,6 @@ void state_stop (cpp)
 	void *cpp;
 {
 	struct client_state *client = cpp;
-	int i;
 
 	/* Cancel all timeouts. */
 	cancel_timeout (state_selecting, client);
@@ -1642,8 +1637,6 @@ void dhcpoffer (packet)
 	int i;
 	int stop_selecting;
 	const char *name = packet -> packet_type ? "DHCPOFFER" : "BOOTREPLY";
-	struct iaddrlist *ap;
-	struct option_cache *oc;
 	char obuf [1024];
 	
 #ifdef DEBUG_PACKET
@@ -2492,7 +2485,6 @@ void make_discover (client, lease)
 	struct client_lease *lease;
 {
 	unsigned char discover = DHCPDISCOVER;
-	int i;
 	struct option_state *options = (struct option_state *)0;
 
 	memset (&client -> packet, 0, sizeof (client -> packet));
@@ -2557,9 +2549,6 @@ void make_request (client, lease)
 	struct client_lease *lease;
 {
 	unsigned char request = DHCPREQUEST;
-	int i, j;
-	unsigned char *tmp, *digest;
-	unsigned char *old_digest_loc;
 	struct option_cache *oc;
 
 	memset (&client -> packet, 0, sizeof (client -> packet));
@@ -2649,7 +2638,6 @@ void make_decline (client, lease)
 	struct client_lease *lease;
 {
 	unsigned char decline = DHCPDECLINE;
-	int i;
 	struct option_cache *oc;
 
 	struct option_state *options = (struct option_state *)0;
@@ -2709,7 +2697,6 @@ void make_release (client, lease)
 	struct client_lease *lease;
 {
 	unsigned char request = DHCPRELEASE;
-	int i;
 	struct option_cache *oc;
 
 	struct option_state *options = (struct option_state *)0;
@@ -2766,8 +2753,6 @@ void make_release (client, lease)
 void destroy_client_lease (lease)
 	struct client_lease *lease;
 {
-	int i;
-
 	if (lease -> server_name)
 		dfree (lease -> server_name, MDL);
 	if (lease -> filename)
@@ -2832,8 +2817,6 @@ void write_lease_option (struct option_c
 {
 	const char *name, *dot;
 	struct data_string ds;
-	int status;
-	struct client_state *client;
 
 	memset (&ds, 0, sizeof ds);
 
@@ -2862,11 +2845,8 @@ int write_client_lease (client, lease, r
 	int makesure;
 {
 	int i;
-	struct tm *t;
 	static int leases_written;
-	struct option_cache *oc;
 	struct data_string ds;
-	pair *hash;
 	int errors = 0;
 	char *s;
 	const char *tval;
@@ -3096,8 +3076,6 @@ void script_write_params (client, prefix
 	int i;
 	struct data_string data;
 	struct option_cache *oc;
-	pair *hash;
-	char *s, *t;
 	struct envadd_state es;
 
 	es.client = client;
@@ -3248,11 +3226,9 @@ int script_go (client)
 
 	return 0;
 #else
-	int rval;
 	char *scriptName;
 	char *argv [2];
 	char **envp;
-	char *epp [3];
 	char reason [] = "REASON=NBI";
 	static char client_path [] = CLIENT_PATH;
 	int i;
@@ -3334,7 +3310,7 @@ void client_envadd (struct client_state 
 {
 	char spbuf [1024];
 	char *s;
-	unsigned len, i;
+	unsigned len;
 	struct string_list *val;
 	va_list list;
 
@@ -3763,8 +3739,7 @@ void client_dns_update_timeout (void *cp
 
 isc_result_t client_dns_update (struct client_state *client, int addp, int ttl)
 {
-	struct data_string ddns_fqdn, ddns_fwd_name,
-	       ddns_dhcid, client_identifier;
+	struct data_string ddns_fwd_name, ddns_dhcid, client_identifier;
 	struct option_cache *oc;
 	int ignorep;
 	int result;
diff -rupN dhcp-3.1-ESV-R3_orig/client/dhclient.c.orig dhcp-3.1-ESV-R3/client/dhclient.c.orig
--- dhcp-3.1-ESV-R3_orig/client/dhclient.c.orig	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/client/dhclient.c.orig	2011-10-10 11:30:40.000000000 -0400
@@ -38,6 +38,12 @@ static char ocopyright[] =
 #include "dhcpd.h"
 #include "version.h"
 
+/*
+ * Defined in stdio.h when _GNU_SOURCE is set, but we don't want to define
+ * that when building ISC code.
+ */
+extern int asprintf(char **strp, const char *fmt, ...);
+
 TIME default_lease_time = 43200; /* 12 hours... */
 TIME max_lease_time = 86400; /* 24 hours... */
 
@@ -76,6 +82,9 @@ int client_env_count=0;
 int onetry=0;
 int quiet=0;
 int nowait=0;
+int bootp_broadcast_always = 0;
+
+extern u_int32_t default_requested_options[];
 
 #ifdef LIBDHCP
 FILE *leaseFile = NULL;
@@ -143,6 +152,15 @@ int main (argc, argv, envp)
 	int no_dhclient_pid = 0;
 	int no_dhclient_script = 0;
 	char *s;
+	char *dhcp_client_identifier_arg = NULL;
+	char *dhcp_host_name_arg = NULL;
+	char *dhcp_fqdn_arg = NULL;
+	char *dhcp_vendor_class_identifier_arg = NULL;
+	char *dhclient_request_options = NULL;
+
+	int timeout_arg = 0;
+	char *arg_conf = NULL;
+	int arg_conf_len = 0;
 
 #ifndef LIBDHCP
         /* Make sure that file descriptors 0 (stdin), 1, (stdout), and
@@ -255,6 +273,88 @@ int main (argc, argv, envp)
 		} else if (!strcmp (argv [i], "--version")) {
 			log_info ("isc-dhclient-%s", DHCP_VERSION);
 			exit (0);
+		} else if (!strcmp (argv [i], "-I")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_MAX_OPTION_LEN) {
+				log_error("-I option dhcp-client-identifier string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_MAX_OPTION_LEN-1);
+				exit(1);
+			}
+
+			dhcp_client_identifier_arg = argv[i];
+		} else if (!strcmp (argv [i], "-B")) {
+			bootp_broadcast_always = 1;
+		} else if (!strcmp (argv [i], "-H")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_MAX_OPTION_LEN) {
+				log_error("-H option host-name string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_MAX_OPTION_LEN-1);
+				exit(1);
+			}
+
+			if (dhcp_host_name_arg != NULL) {
+				log_error("The -H <host-name> and -F <fqdn> arguments are mutually exclusive");
+				exit(1);
+			}
+
+			dhcp_host_name_arg = argv[i];
+		} else if (!strcmp (argv [i], "-F")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_MAX_OPTION_LEN) {
+				log_error("-F option fqdn.fqdn string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_MAX_OPTION_LEN-1);
+				exit(1);
+			}
+
+			if (dhcp_fqdn_arg != NULL) {
+				log_error("Only one -F <fqdn> argument can be specified");
+				exit(1);
+			}
+
+			if (dhcp_host_name_arg != NULL) {
+				log_error("The -F <fqdn> and -H <host-name> arguments are mutually exclusive");
+				exit(1);
+			}
+
+			dhcp_fqdn_arg = argv[i];
+		} else if (!strcmp (argv [i], "-T")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if ((timeout_arg = atoi(argv[i])) <= 0) {
+				log_error("-T timeout option must be > 0 - bad value: %s",argv[i]);
+				exit(1);
+			}
+		} else if (!strcmp (argv [i], "-V")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_MAX_OPTION_LEN) {
+				log_error("-V option vendor-class-identifier string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_MAX_OPTION_LEN-1);
+				exit(1);
+			}
+
+			dhcp_vendor_class_identifier_arg = argv[i];
+		} else if (!strcmp (argv [i], "-R")) {
+			if ((++i == argc) || (argv[i] == NULL) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			dhclient_request_options=argv[i];
  		} else if (argv [i][0] == '-') {
  		    usage ();
 		} else {
@@ -463,6 +563,168 @@ int main (argc, argv, envp)
 	/* Parse the dhclient.conf file. */
 	read_client_conf ();
 
+
+    /* Parse any extra command line configuration arguments: */
+    if ((dhcp_client_identifier_arg != NULL) && (*dhcp_client_identifier_arg != '\0')) {
+        arg_conf_len = asprintf(&arg_conf, "send dhcp-client-identifier \"%s\";", dhcp_client_identifier_arg);
+
+        if ((arg_conf == 0) || (arg_conf_len <= 0))
+            log_fatal("Unable to send -I option dhcp-client-identifier");
+    }
+
+    if ((dhcp_host_name_arg != NULL) && (*dhcp_host_name_arg != '\0')) {
+        if (arg_conf == 0) {
+            arg_conf_len = asprintf(&arg_conf, "send host-name \"%s\";", dhcp_host_name_arg);
+
+                if ((arg_conf == 0) || (arg_conf_len <= 0))
+            log_fatal("Unable to send -H option host-name");
+        } else {
+        char *last_arg_conf = arg_conf;
+            arg_conf = NULL;
+            arg_conf_len = asprintf( &arg_conf, "%s\nsend host-name \"%s\";", last_arg_conf, dhcp_host_name_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to send -H option host-name");
+
+            free(last_arg_conf);
+        }
+    }
+
+    if ((dhcp_fqdn_arg != NULL) && (*dhcp_fqdn_arg != '\0')) {
+        if (arg_conf == 0) {
+            arg_conf_len = asprintf(&arg_conf,  "send fqdn.fqdn \"%s\";", dhcp_fqdn_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to send -F option fqdn.fqdn");
+        } else {
+            char *last_arg_conf = arg_conf;
+            arg_conf = NULL;
+            arg_conf_len = asprintf( &arg_conf, "%s\nsend fqdn.fqdn \"%s\";", last_arg_conf, dhcp_fqdn_arg);
+
+            if ((arg_conf == 0)  || (arg_conf_len <= 0))
+                log_fatal("Unable to send -F option fqdn.fqdn");
+
+            free(last_arg_conf);
+        }
+    }
+
+    if (timeout_arg) {
+        if (arg_conf == 0) {
+            arg_conf_len = asprintf(&arg_conf,  "timeout %d;", timeout_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to process -T timeout argument");
+        } else {
+            char *last_arg_conf = arg_conf;
+            arg_conf = NULL;
+            arg_conf_len = asprintf( &arg_conf, "%s\ntimeout %d;", last_arg_conf, timeout_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len == 0))
+                log_fatal("Unable to process -T timeout argument");
+
+            free(last_arg_conf);
+        }
+    }
+
+    if ((dhcp_vendor_class_identifier_arg != NULL) && (*dhcp_vendor_class_identifier_arg != '\0')) {
+        if (arg_conf == 0) {
+            arg_conf_len = asprintf(&arg_conf,  "send vendor-class-identifier \"%s\";", dhcp_vendor_class_identifier_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to send -V option vendor-class-identifier");
+        } else {
+            char *last_arg_conf = arg_conf;
+            arg_conf = NULL;
+            arg_conf_len = asprintf(&arg_conf, "%s\nsend vendor-class-identifier \"%s\";", last_arg_conf, dhcp_vendor_class_identifier_arg);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to send -V option vendor-class-identifier");
+
+            free(last_arg_conf);
+        }
+    }
+
+    if (dhclient_request_options != NULL) {
+        if (arg_conf == 0) {
+            arg_conf_len = asprintf(&arg_conf,  "request %s;", dhclient_request_options);
+
+            if ((arg_conf == 0) || (arg_conf_len <= 0))
+                log_fatal("Unable to parse -R <request options list> argument");
+        } else {
+            char *last_arg_conf = arg_conf;
+            arg_conf = NULL;
+            arg_conf_len = asprintf(&arg_conf, "%s\nrequest %s;", last_arg_conf, dhclient_request_options);
+
+            if ((arg_conf == 0)  || (arg_conf_len <= 0))
+                log_fatal("Unable to parse -R <request options list> argument");
+
+            free(last_arg_conf);
+        }
+    }
+
+    if (arg_conf) {
+        if (arg_conf_len == 0)
+            if ((arg_conf_len = strlen(arg_conf)) == 0)
+                /* huh ? cannot happen ! */
+                log_fatal("Unable to process -I/-H/-F/-T/-V/-R configuration arguments");
+
+        /* parse the extra dhclient.conf configuration arguments
+        * into top level config: */
+        struct parse *cfile = (struct parse *)0;
+        const char *val = NULL;
+        int token;
+
+        status = new_parse (&cfile, -1, arg_conf, arg_conf_len, "extra dhclient -I/-H/-F/-T/-V/-R configuration arguments", 0);
+
+        if ((status != ISC_R_SUCCESS) || (cfile -> warnings_occurred))
+            log_fatal("Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !");
+        /* more detailed parse failures will be logged */
+
+        do {
+            token = peek_token (&val, (unsigned *)0, cfile);
+            if (token == END_OF_FILE)
+                break;
+
+            parse_client_statement (cfile, (struct interface_info *)0, &top_level_config);
+        } while (1);
+
+        if (cfile -> warnings_occurred)
+            log_fatal ("Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !");
+        end_parse (&cfile);
+
+        if (timeout_arg) {
+            /* we just set the toplevel timeout, but per-client
+             * timeouts may still be at defaults. Also, it makes no
+             * sense having the reboot_timeout or backoff_cutoff
+             * greater than the timeout:
+             */
+            if ((top_level_config.backoff_cutoff == 15) && (top_level_config.backoff_cutoff > (timeout_arg / 2)))
+                top_level_config.backoff_cutoff = (((unsigned long)(timeout_arg / 2)) == 0) ? timeout_arg : (unsigned long)(timeout_arg / 2);
+
+            for (ip = interfaces; ip; ip = ip -> next) {
+                if (ip->client->config->timeout == 60)
+                    ip->client->config->timeout = timeout_arg;
+
+                if ((ip->client->config->reboot_timeout == 10) && (ip->client->config->reboot_timeout > ip->client->config->timeout))
+                    ip->client->config->reboot_timeout = ip->client->config->timeout;
+
+                if ((ip->client->config->backoff_cutoff == 15) && (ip->client->config->backoff_cutoff > top_level_config.backoff_cutoff))
+                    ip->client->config->backoff_cutoff = top_level_config.backoff_cutoff;
+            }
+        }
+
+        if ((dhclient_request_options != 0) && (top_level_config.requested_options != default_requested_options)) {
+            for (ip = interfaces; ip; ip = ip -> next) {
+                if (ip->client->config->requested_options == default_requested_options)
+                    ip->client->config->requested_options = top_level_config.requested_options;
+            }
+        }
+
+        free(arg_conf);
+        arg_conf = NULL;
+        arg_conf_len = 0;
+    }
+
 #ifdef LIBDHCP
 	if (libdhcp_control && (libdhcp_control->capability & DHCP_USE_LEASE_DATABASE)) {
 #endif
@@ -2266,7 +2528,8 @@ void make_discover (client, lease)
 	client -> packet.xid = random ();
 	client -> packet.secs = 0; /* filled in by send_discover. */
 
-	if (can_receive_unicast_unconfigured (client -> interface))
+	if ((!(bootp_broadcast_always || client->config->bootp_broadcast_always))
+	    && can_receive_unicast_unconfigured(client->interface))
 		client -> packet.flags = 0;
 	else
 		client -> packet.flags = htons (BOOTP_BROADCAST);
@@ -2353,7 +2616,9 @@ void make_request (client, lease)
 	} else {
 		memset (&client -> packet.ciaddr, 0,
 			sizeof client -> packet.ciaddr);
-		if (can_receive_unicast_unconfigured (client -> interface))
+		if ((!(bootp_broadcast_always ||
+		    client ->config->bootp_broadcast_always)) &&
+		    can_receive_unicast_unconfigured (client -> interface))
 			client -> packet.flags = 0;
 		else
 			client -> packet.flags = htons (BOOTP_BROADCAST);
@@ -2416,7 +2681,8 @@ void make_decline (client, lease)
 	client -> packet.hops = 0;
 	client -> packet.xid = client -> xid;
 	client -> packet.secs = 0; /* Filled in by send_request. */
-	if (can_receive_unicast_unconfigured (client -> interface))
+	if ((!(bootp_broadcast_always || client->config-> bootp_broadcast_always))
+	    && can_receive_unicast_unconfigured (client->interface))
 		client -> packet.flags = 0;
 	else
 		client -> packet.flags = htons (BOOTP_BROADCAST);
diff -rupN dhcp-3.1-ESV-R3_orig/common/alloc.c dhcp-3.1-ESV-R3/common/alloc.c
--- dhcp-3.1-ESV-R3_orig/common/alloc.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/alloc.c	2011-10-10 11:30:40.000000000 -0400
@@ -48,7 +48,6 @@ int option_chain_head_allocate (ptr, fil
 	const char *file;
 	int line;
 {
-	int size;
 	struct option_chain_head *h;
 
 	if (!ptr) {
@@ -109,7 +108,6 @@ int option_chain_head_dereference (ptr, 
 	const char *file;
 	int line;
 {
-	int i;
 	struct option_chain_head *option_chain_head;
 	pair car, cdr;
 
@@ -161,7 +159,6 @@ int group_allocate (ptr, file, line)
 	const char *file;
 	int line;
 {
-	int size;
 	struct group *g;
 
 	if (!ptr) {
@@ -222,7 +219,6 @@ int group_dereference (ptr, file, line)
 	const char *file;
 	int line;
 {
-	int i;
 	struct group *group;
 
 	if (!ptr || !*ptr) {
@@ -741,8 +737,6 @@ int buffer_dereference (ptr, file, line)
 	const char *file;
 	int line;
 {
-	struct buffer *bp;
-
 	if (!ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -830,8 +824,6 @@ int dns_host_entry_dereference (ptr, fil
 	const char *file;
 	int line;
 {
-	struct dns_host_entry *bp;
-
 	if (!ptr || !*ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -1037,7 +1029,6 @@ int packet_allocate (ptr, file, line)
 	const char *file;
 	int line;
 {
-	int size;
 	struct packet *p;
 
 	if (!ptr) {
@@ -1157,7 +1148,6 @@ int dns_zone_allocate (ptr, file, line)
 	const char *file;
 	int line;
 {
-	int size;
 	struct dns_zone *d;
 
 	if (!ptr) {
diff -rupN dhcp-3.1-ESV-R3_orig/common/comapi.c dhcp-3.1-ESV-R3/common/comapi.c
--- dhcp-3.1-ESV-R3_orig/common/comapi.c	2009-07-23 17:43:33.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/comapi.c	2011-10-10 11:30:40.000000000 -0400
@@ -143,7 +143,6 @@ isc_result_t dhcp_group_set_value  (omap
 {
 	struct group_object *group;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -217,7 +216,6 @@ isc_result_t dhcp_group_get_value (omapi
 {
 	struct group_object *group;
 	isc_result_t status;
-	struct data_string ip_addrs;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -240,7 +238,6 @@ isc_result_t dhcp_group_get_value (omapi
 isc_result_t dhcp_group_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct group_object *group, *t;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -271,7 +268,7 @@ isc_result_t dhcp_group_destroy (omapi_o
 isc_result_t dhcp_group_signal_handler (omapi_object_t *h,
 					const char *name, va_list ap)
 {
-	struct group_object *group, *t;
+	struct group_object *group;
 	isc_result_t status;
 	int updatep = 0;
 
@@ -453,7 +450,6 @@ isc_result_t dhcp_control_set_value  (om
 {
 	dhcp_control_object_t *control;
 	isc_result_t status;
-	int foo;
 	unsigned long newstate;
 
 	if (h -> type != dhcp_type_control)
@@ -488,7 +484,6 @@ isc_result_t dhcp_control_get_value (oma
 {
 	dhcp_control_object_t *control;
 	isc_result_t status;
-	struct data_string ip_addrs;
 
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
@@ -511,9 +506,6 @@ isc_result_t dhcp_control_get_value (oma
 isc_result_t dhcp_control_destroy (omapi_object_t *h,
 				   const char *file, int line)
 {
-	dhcp_control_object_t *control, *t;
-	isc_result_t status;
-
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
 
@@ -524,9 +516,8 @@ isc_result_t dhcp_control_destroy (omapi
 isc_result_t dhcp_control_signal_handler (omapi_object_t *h,
 					const char *name, va_list ap)
 {
-	dhcp_control_object_t *control, *t;
+	dhcp_control_object_t *control;
 	isc_result_t status;
-	int updatep = 0;
 
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
@@ -580,7 +571,6 @@ isc_result_t dhcp_control_lookup (omapi_
 {
 	omapi_value_t *tv = (omapi_value_t *)0;
 	isc_result_t status;
-	dhcp_control_object_t *control;
 
 	/* First see if we were sent a handle. */
 	if (ref) {
@@ -629,7 +619,6 @@ isc_result_t dhcp_subnet_set_value  (oma
 {
 	struct subnet *subnet;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_subnet)
 		return ISC_R_INVALIDARG;
@@ -675,7 +664,6 @@ isc_result_t dhcp_subnet_get_value (omap
 isc_result_t dhcp_subnet_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct subnet *subnet;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_subnet)
 		return ISC_R_INVALIDARG;
@@ -752,10 +740,6 @@ isc_result_t dhcp_subnet_lookup (omapi_o
 				 omapi_object_t *id,
 				 omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct subnet *subnet;
-
 	/* Can't look up subnets yet. */
 
 	/* If we get to here without finding a subnet, no valid key was
@@ -784,7 +768,6 @@ isc_result_t dhcp_shared_network_set_val
 {
 	struct shared_network *shared_network;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_shared_network)
 		return ISC_R_INVALIDARG;
@@ -832,7 +815,6 @@ isc_result_t dhcp_shared_network_destroy
 					  const char *file, int line)
 {
 	struct shared_network *shared_network;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_shared_network)
 		return ISC_R_INVALIDARG;
@@ -922,10 +904,6 @@ isc_result_t dhcp_shared_network_lookup 
 					 omapi_object_t *id,
 					 omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct shared_network *shared_network;
-
 	/* Can't look up shared_networks yet. */
 
 	/* If we get to here without finding a shared_network, no valid key was
diff -rupN dhcp-3.1-ESV-R3_orig/common/discover.c dhcp-3.1-ESV-R3/common/discover.c
--- dhcp-3.1-ESV-R3_orig/common/discover.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/discover.c	2011-10-10 11:30:40.000000000 -0400
@@ -129,16 +129,14 @@ int have_setup_fallback = 0;
 void discover_interfaces (state)
 	int state;
 {
-	struct interface_info *tmp, *ip;
+	struct interface_info *tmp;
 	struct interface_info *last, *next;
 	char buf [2048];
 	struct ifconf ic;
 	struct ifreq ifr;
 	int i;
 	int sock;
-	int address_count = 0;
 	struct subnet *subnet;
-	struct shared_network *share;
 	struct sockaddr_in foo;
 	int ir;
 	struct ifreq *tif;
@@ -442,7 +440,6 @@ void discover_interfaces (state)
 	for (tmp = interfaces; tmp; tmp = tmp -> next) {
 		struct ifreq ifr;
 		struct sockaddr sa;
-		int b, sk;
 		
 		if (!tmp -> ifp) {
 			/* Make up an ifreq structure. */
@@ -833,7 +830,6 @@ isc_result_t dhcp_interface_set_value  (
 {
 	struct interface_info *interface;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_interface)
 		return ISC_R_INVALIDARG;
@@ -876,7 +872,6 @@ isc_result_t dhcp_interface_destroy (oma
 					 const char *file, int line)
 {
 	struct interface_info *interface;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_interface)
 		return ISC_R_INVALIDARG;
@@ -906,8 +901,6 @@ isc_result_t dhcp_interface_signal_handl
 					    const char *name, va_list ap)
 {
 	struct interface_info *ip, *interface;
-	struct client_config *config;
-	struct client_state *client;
 	isc_result_t status;
 
 	if (h -> type != dhcp_type_interface)
diff -rupN dhcp-3.1-ESV-R3_orig/common/discover.c.orig dhcp-3.1-ESV-R3/common/discover.c.orig
--- dhcp-3.1-ESV-R3_orig/common/discover.c.orig	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/discover.c.orig	2011-10-10 11:30:40.000000000 -0400
@@ -122,6 +122,10 @@ isc_result_t interface_initialize (omapi
    register that interface with the network I/O software, figure out what
    subnet it's on, and add it to the list of interfaces. */
 
+#ifdef LIBDHCP
+int have_setup_fallback = 0;
+#endif
+
 void discover_interfaces (state)
 	int state;
 {
@@ -142,7 +146,9 @@ void discover_interfaces (state)
 	char *s;
 #endif
 	isc_result_t status;
+#ifndef LIBDHCP
 	static int setup_fallback = 0;
+#endif
 	int wifcount = 0;
 
 	/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on. */
@@ -696,10 +702,17 @@ void discover_interfaces (state)
 		log_fatal ("Not configured to listen on any interfaces!");
 	}
 
+#ifdef LIBDHCP
+	if (!have_setup_fallback) {
+		have_setup_fallback = 1;
+		maybe_setup_fallback ();
+	}
+#else
 	if (!setup_fallback) {
 		setup_fallback = 1;
 		maybe_setup_fallback ();
 	}
+#endif
 
 #if defined (HAVE_SETFD)
 	if (fallback_interface) {
diff -rupN dhcp-3.1-ESV-R3_orig/common/dns.c dhcp-3.1-ESV-R3/common/dns.c
--- dhcp-3.1-ESV-R3_orig/common/dns.c	2009-09-01 16:32:27.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/dns.c	2011-10-10 11:30:40.000000000 -0400
@@ -127,7 +127,6 @@ dns_zone_hash_t *dns_zone_hash;
 isc_result_t find_tsig_key (ns_tsig_key **key, const char *zname,
 			    struct dns_zone *zone)
 {
-	isc_result_t status;
 	ns_tsig_key *tkey;
 
 	if (!zone)
@@ -201,7 +200,6 @@ isc_result_t enter_dns_zone (struct dns_
 
 isc_result_t dns_zone_lookup (struct dns_zone **zone, const char *name)
 {
-	struct dns_zone *tz = (struct dns_zone *)0;
 	int len;
 	char *tname = (char *)0;
 	isc_result_t status;
@@ -234,7 +232,6 @@ int dns_zone_dereference (ptr, file, lin
 	const char *file;
 	int line;
 {
-	int i;
 	struct dns_zone *dns_zone;
 
 	if (!ptr || !*ptr) {
@@ -397,9 +394,7 @@ void repudiate_zone (struct dns_zone **z
 void cache_found_zone (ns_class class,
 		       char *zname, struct in_addr *addrs, int naddrs)
 {
-	isc_result_t status = ISC_R_NOTFOUND;
 	struct dns_zone *zone = (struct dns_zone *)0;
-	struct data_string nsaddrs;
 	int ix = strlen (zname);
 
 	if (zname [ix - 1] == '.')
@@ -678,7 +673,7 @@ ddns_update_a(struct data_string *ddns_f
 		/*
 		 * Conflict detection override: delete DHCID RRs.
 		 */
-		updrec = minires_mkupdrec(S_UPDATE, ddns_fwd_name->data,
+		updrec = minires_mkupdrec(S_UPDATE, (char *)ddns_fwd_name->data,
 					  C_IN, T_DHCID, 0);
 
 		if (!updrec) {
diff -rupN dhcp-3.1-ESV-R3_orig/common/execute.c dhcp-3.1-ESV-R3/common/execute.c
--- dhcp-3.1-ESV-R3_orig/common/execute.c	2009-07-23 17:43:33.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/execute.c	2011-10-10 13:52:32.000000000 -0400
@@ -54,8 +54,6 @@ int execute_statements (result, packet, 
 	struct executable_statement *r, *e, *next;
 	int rc;
 	int status;
-	unsigned long num;
-	struct binding_scope *outer;
 	struct binding *binding;
 	struct data_string ds;
 	struct binding_scope *ns;
@@ -363,7 +361,6 @@ int execute_statements (result, packet, 
 					binding -> next = (*scope) -> bindings;
 					(*scope) -> bindings = binding;
 				    } else {
-				       badalloc:
 					dfree (binding, MDL);
 					binding = (struct binding *)0;
 				    }
@@ -606,8 +603,6 @@ int executable_statement_dereference (pt
 	const char *file;
 	int line;
 {
-	struct executable_statement *bp;
-
 	if (!ptr || !*ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -739,8 +734,6 @@ void write_statements (file, statements,
 {
 	struct executable_statement *r, *x;
 	struct expression *expr;
-	int result;
-	int status;
 	const char *s, *t, *dot;
 	int col;
 
@@ -1014,10 +1007,8 @@ int find_matching_case (struct executabl
 {
 	int status, sub;
 	struct executable_statement *s;
-	unsigned long foo;
 
 	if (is_data_expression (expr)) {
-		struct executable_statement *e;
 		struct data_string cd, ds;
 		memset (&ds, 0, sizeof ds);
 		memset (&cd, 0, sizeof cd);
@@ -1091,7 +1082,6 @@ int executable_statement_foreach (struct
 {
 	struct executable_statement *foo;
 	int ok = 0;
-	int result;
 
 	for (foo = stmt; foo; foo = foo -> next) {
 	    if ((*callback) (foo, vp, condp) != 0)
diff -rupN dhcp-3.1-ESV-R3_orig/common/icmp.c dhcp-3.1-ESV-R3/common/icmp.c
--- dhcp-3.1-ESV-R3_orig/common/icmp.c	2009-07-23 17:43:33.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/icmp.c	2011-10-10 13:54:17.000000000 -0400
@@ -61,11 +61,7 @@ void icmp_startup (routep, handler)
 {
 	struct protoent *proto;
 	int protocol = 1;
-	struct sockaddr_in from;
-	int fd;
 	int state;
-	struct icmp_state *new;
-	omapi_object_t *h;
 	isc_result_t result;
 
 	/* Only initialize icmp once. */
@@ -284,7 +280,6 @@ isc_result_t icmp_echoreply (h)
 void trace_icmp_input_input (trace_type_t *ttype, unsigned length, char *buf)
 {
 	struct iaddr *ia;
-	unsigned len;
 	u_int8_t *icbuf;
 	ia = (struct iaddr *)buf;
 	ia->len = ntohl(ia->len);
diff -rupN dhcp-3.1-ESV-R3_orig/common/inet.c dhcp-3.1-ESV-R3/common/inet.c
--- dhcp-3.1-ESV-R3_orig/common/inet.c	2009-09-01 16:32:27.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/inet.c	2011-10-10 11:30:40.000000000 -0400
@@ -124,7 +124,7 @@ struct iaddr broadcast_addr (subnet, mas
 	struct iaddr subnet;
 	struct iaddr mask;
 {
-	int i, j, k;
+	int i;
 	struct iaddr rv;
 
 	if (subnet.len > sizeof(subnet.iabuf))
diff -rupN dhcp-3.1-ESV-R3_orig/common/memory.c dhcp-3.1-ESV-R3/common/memory.c
--- dhcp-3.1-ESV-R3_orig/common/memory.c	2009-07-23 17:43:33.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/memory.c	2011-10-10 11:30:40.000000000 -0400
@@ -84,8 +84,7 @@ isc_result_t delete_group (struct group_
 
 isc_result_t supersede_group (struct group_object *group, int writep)
 {
-	struct group_object *t, *u;
-	isc_result_t status;
+	struct group_object *t;
 
 	/* Register the group in the group name hash table,
 	   so we can look it up later. */
@@ -142,7 +141,6 @@ isc_result_t supersede_group (struct gro
 int clone_group (struct group **gp, struct group *group,
 		 const char *file, int line)
 {
-	isc_result_t status;
 	struct group *g = (struct group *)0;
 
 	/* Normally gp should contain the null pointer, but for convenience
diff -rupN dhcp-3.1-ESV-R3_orig/common/options.c dhcp-3.1-ESV-R3/common/options.c
--- dhcp-3.1-ESV-R3_orig/common/options.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/options.c	2011-10-10 14:01:47.000000000 -0400
@@ -43,9 +43,6 @@ static char copyright[] =
 
 struct option *vendor_cfg_option;
 
-static void do_option_set PROTO ((pair *,
-				  struct option_cache *,
-				  enum statement_op));
 static int pretty_text(char **, char *, const unsigned char **,
 			 const unsigned char *, int);
 static int pretty_domain(char **, char *, const unsigned char **,
@@ -56,7 +53,6 @@ static int pretty_domain(char **, char *
 int parse_options (packet)
 	struct packet *packet;
 {
-	int i;
 	struct option_cache *op = (struct option_cache *)0;
 
 	/* Allocate a new option state. */
@@ -136,8 +132,6 @@ int parse_option_buffer (options, buffer
 	unsigned length;
 	struct universe *universe;
 {
-	unsigned char *t;
-	const unsigned char *end = buffer + length;
 	unsigned len, offset;
 	unsigned code;
 	struct option_cache *op = (struct option_cache *)0;
@@ -317,7 +311,6 @@ int fqdn_universe_decode (struct option_
 			  const unsigned char *buffer,
 			  unsigned length, struct universe *u)
 {
-	char *name;
 	struct buffer *bp = (struct buffer *)0;
 
 	/* FQDN options have to be at least four bytes long. */
@@ -940,7 +933,6 @@ store_options(int *ocount,
 	    if ((option != NULL) &&
 		(((oc == NULL) && (option->format[0] == 'E')) ||
 		 ((oc != NULL) && (option->format[0] == 'e')))) {
-		int uix;
 		static char *s, *t;
 		struct option_cache *tmp;
 		struct data_string name;
@@ -1079,7 +1071,6 @@ store_options(int *ocount,
 	    toptstart = tix;
 	    while (length) {
 		    unsigned incr = length;
-		    int consumed = 0;
 		    int *pix;
 		    unsigned char *base;
 
@@ -1197,7 +1188,6 @@ format_has_text(format)
 	const char *format;
 {
 	const char *p;
-	int retval = 0;
 
 	p = format;
 	while (*p != '\0') {
@@ -2236,7 +2226,7 @@ store_option(struct data_string *result,
 						  "refers to unknown "
 						  "option space '%.*s'.",
 						  oc->option->code,
-						  end - start, start);
+						  (int) (end - start), start);
 					break;
 				}
 
@@ -2273,12 +2263,10 @@ int option_space_encapsulate (result, pa
 	struct binding_scope **scope;
 	struct data_string *name;
 {
-	struct data_string sub;
-	struct universe *u = NULL, *subu = NULL;
+	struct universe *u = NULL;
 	int status = 0;
-	int i;
 
-	universe_hash_lookup(&u, universe_hash, name->data, name->len, MDL);
+	universe_hash_lookup(&u, universe_hash, (char *)name->data, name->len, MDL);
 	if (u == NULL) {
 		log_error("option_space_encapsulate: option space %.*s does "
 			  "not exist, but is configured.",
@@ -2407,7 +2395,6 @@ int nwip_option_space_encapsulate (resul
 {
 	pair ocp;
 	int status;
-	int i;
 	static struct option_cache *no_nwip;
 	struct data_string ds;
 	struct option_chain_head *head;
@@ -2421,7 +2408,6 @@ int nwip_option_space_encapsulate (resul
 
 	status = 0;
 	for (ocp = head -> first; ocp; ocp = ocp -> cdr) {
-		struct option_cache *oc = (struct option_cache *)(ocp -> car);
 		if (store_option (result, universe, packet,
 				  lease, client_state, in_options,
 				  cfg_options, scope,
@@ -2614,7 +2600,6 @@ void suboption_foreach (struct packet *p
 {
 	struct universe *universe = find_option_universe (oc -> option,
 							  vsname);
-	int i;
 
 	if (universe -> foreach)
 		(*universe -> foreach) (packet, lease, client_state,
@@ -2664,7 +2649,6 @@ void save_linked_option (universe, optio
 	struct option_cache *oc;
 {
 	pair *tail;
-	pair np = (pair )0;
 	struct option_chain_head *head;
 
 	if (universe -> index >= options -> universe_count)
@@ -2839,7 +2823,6 @@ void do_packet (interface, packet, len, 
 	struct iaddr from;
 	struct hardware *hfrom;
 {
-	int i;
 	struct option_cache *op;
 	struct packet *decoded_packet;
 #if defined (DEBUG_MEMORY_LEAKAGE)
diff -rupN dhcp-3.1-ESV-R3_orig/common/parse.c dhcp-3.1-ESV-R3/common/parse.c
--- dhcp-3.1-ESV-R3_orig/common/parse.c	2010-03-17 15:32:13.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/parse.c	2011-10-10 14:13:33.000000000 -0400
@@ -311,9 +311,6 @@ int parse_ip_addr (cfile, addr)
 	struct parse *cfile;
 	struct iaddr *addr;
 {
-	const char *val;
-	enum dhcp_token token;
-
 	addr -> len = 4;
 	if (parse_numeric_aggregate (cfile, addr -> iabuf,
 				     &addr -> len, DOT, 10, 8))
@@ -614,7 +611,7 @@ void convert_num (cfile, buf, str, base,
 	int base;
 	unsigned size;
 {
-	const unsigned char *ptr = str;
+	const unsigned char *ptr = (const unsigned char *) str;
 	int negative = 0;
 	u_int32_t val = 0;
 	int tval;
@@ -742,7 +739,6 @@ void convert_num (cfile, buf, str, base,
 TIME parse_date (cfile)
 	struct parse *cfile;
 {
-	struct tm tm;
 	int guess;
 	int tzoff, wday, year, mon, mday, hour, min, sec;
 	const char *val;
@@ -1306,7 +1302,6 @@ int parse_option_code_definition (cfile,
 	char tokbuf [128];
 	unsigned tokix = 0;
 	char type;
-	int code;
 	int is_signed;
 	char *s;
 	int has_encapsulation = 0;
@@ -1816,7 +1811,6 @@ int parse_executable_statement (result, 
 	enum dhcp_token token;
 	const char *val;
 	unsigned len;
-	struct executable_statement base;
 	struct class *cta;
 	struct option *option=NULL;
 	struct option_cache *cache;
@@ -2156,7 +2150,6 @@ int parse_executable_statement (result, 
 		if (token != NAME && token != NUMBER_OR_NAME) {
 			parse_warn (cfile,
 				    "%s can't be a variable name", val);
-		      badunset:
 			skip_to_semi (cfile);
 			*lose = 1;
 			return 0;
@@ -3207,16 +3200,13 @@ int parse_non_binary (expr, cfile, lose,
 	enum dhcp_token token;
 	const char *val;
 	struct collection *col;
-	struct option *option;
 	struct expression *nexp, **ep;
 	int known;
 	enum expr_op opcode;
 	const char *s;
 	char *cptr;
-	struct executable_statement *stmt;
-	int i;
 	unsigned long u;
-	isc_result_t status, code;
+	isc_result_t status;
 	unsigned len;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
@@ -3744,7 +3734,6 @@ int parse_non_binary (expr, cfile, lose,
 					parse_warn
 						(cfile,
 						 "expecting dns expression.");
-			      badnstrans:
 				expression_dereference (expr, MDL);
 				*lose = 1;
 				return 0;
@@ -4655,8 +4644,6 @@ int parse_option_statement (result, cfil
 	struct expression *expr = (struct expression *)0;
 	struct expression *tmp;
 	int lose;
-	struct executable_statement *stmt;
-	int ftt = 1;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
 	if (token == SEMI) {
@@ -4773,9 +4760,7 @@ int parse_option_token (rv, cfile, fmt, 
 	struct expression *t = NULL;
 	unsigned char buf [4];
 	unsigned len;
-	unsigned char *ob;
 	struct iaddr addr;
-	int num;
 	const char *f, *g;
 	struct enumeration_value *e;
 
@@ -5032,8 +5017,6 @@ int parse_option_decl (oc, cfile)
 		/* Set a flag if this is an array of a simple type (i.e.,
 		   not an array of pairs of IP addresses, or something
 		   like that. */
-		int uniform = option -> format [1] == 'A';
-
 		for (fmt = option -> format; *fmt; fmt++) {
 			if (*fmt == 'A')
 				break;
@@ -5260,7 +5243,6 @@ int parse_X (cfile, buf, max)
 	int token;
 	const char *val;
 	unsigned len;
-	u_int8_t *s;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
 	if (token == NUMBER_OR_NAME || token == NUMBER) {
@@ -5304,6 +5286,7 @@ int parse_X (cfile, buf, max)
 
 int parse_warn (struct parse *cfile, const char *fmt, ...)
 {
+	int l;
 	va_list list;
 	char lexbuf [256];
 	char mbuf [1024];
@@ -5327,9 +5310,10 @@ int parse_warn (struct parse *cfile, con
 		if (lix < (sizeof lexbuf) - 1)
 			lexbuf [lix++] = ' ';
 		if (cfile -> token_line [i] == '\t') {
-			for (lix;
-			     lix < (sizeof lexbuf) - 1 && (lix & 7); lix++)
+			while (lix < (sizeof lexbuf) - 1 && (lix & 7)) {
 				lexbuf [lix] = ' ';
+				lix++;
+			}
 		}
 	}
 	lexbuf [lix] = 0;
diff -rupN dhcp-3.1-ESV-R3_orig/common/parse.c.orig dhcp-3.1-ESV-R3/common/parse.c.orig
--- dhcp-3.1-ESV-R3_orig/common/parse.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ dhcp-3.1-ESV-R3/common/parse.c.orig	2010-03-17 15:32:13.000000000 -0400
@@ -0,0 +1,5409 @@
+/* parse.c
+
+   Common parser code for dhcpd and dhclient. */
+
+/*
+ * Copyright (c) 2004-2010 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1995-2003 by Internet Software Consortium
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *   Internet Systems Consortium, Inc.
+ *   950 Charter Street
+ *   Redwood City, CA 94063
+ *   <info@isc.org>
+ *   https://www.isc.org/
+ *
+ * This software has been written for Internet Systems Consortium
+ * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.
+ * To learn more about Internet Systems Consortium, see
+ * ``https://www.isc.org/''.  To learn more about Vixie Enterprises,
+ * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see
+ * ``http://www.nominum.com''.
+ */
+
+#ifndef lint
+static char copyright[] =
+"$Id: parse.c,v 1.117.8.13 2010-03-17 19:32:13 sar Exp $ Copyright (c) 2004-2009 Internet Systems Consortium.  All rights reserved.\n";
+#endif /* not lint */
+
+#include "dhcpd.h"
+
+/* Enumerations can be specified in option formats, and are used for
+   parsing, so we define the routines that manage them here. */
+
+struct enumeration *enumerations;
+
+void add_enumeration (struct enumeration *enumeration)
+{
+	enumeration -> next = enumerations;
+	enumerations = enumeration;
+}
+
+struct enumeration *find_enumeration (const char *name, int length)
+{
+	struct enumeration *e;
+
+	for (e = enumerations; e; e = e -> next)
+		if (strlen (e -> name) == length &&
+		    !memcmp (e -> name, name, (unsigned)length))
+			return e;
+	return (struct enumeration *)0;
+}
+
+struct enumeration_value *find_enumeration_value (const char *name,
+						  int length,
+						  const char *value)
+{
+	struct enumeration *e;
+	int i;
+
+	e = find_enumeration (name, length);
+	if (e) {
+		for (i = 0; e -> values [i].name; i++) {
+			if (!strcmp (value, e -> values [i].name))
+				return &e -> values [i];
+		}
+	}
+	return (struct enumeration_value *)0;
+}
+
+/* Skip to the semicolon ending the current statement.   If we encounter
+   braces, the matching closing brace terminates the statement.   If we
+   encounter a right brace but haven't encountered a left brace, return
+   leaving the brace in the token buffer for the caller.   If we see a
+   semicolon and haven't seen a left brace, return.   This lets us skip
+   over:
+
+   	statement;
+	statement foo bar { }
+	statement foo bar { statement { } }
+	statement}
+ 
+	...et cetera. */
+
+void skip_to_semi (cfile)
+	struct parse *cfile;
+{
+	skip_to_rbrace (cfile, 0);
+}
+
+void skip_to_rbrace (cfile, brace_count)
+	struct parse *cfile;
+	int brace_count;
+{
+	enum dhcp_token token;
+	const char *val;
+
+#if defined (DEBUG_TOKEN)
+	log_error ("skip_to_rbrace: %d\n", brace_count);
+#endif
+	do {
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token == RBRACE) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (brace_count) {
+				if (!--brace_count)
+					return;
+			} else
+				return;
+		} else if (token == LBRACE) {
+			brace_count++;
+		} else if (token == SEMI && !brace_count) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			return;
+		} else if (token == EOL) {
+			/* EOL only happens when parsing /etc/resolv.conf,
+			   and we treat it like a semicolon because the
+			   resolv.conf file is line-oriented. */
+			token = next_token (&val, (unsigned *)0, cfile);
+			return;
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+	} while (token != END_OF_FILE);
+}
+
+int parse_semi (cfile)
+	struct parse *cfile;
+{
+	enum dhcp_token token;
+	const char *val;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != SEMI) {
+		parse_warn (cfile, "semicolon expected.");
+		skip_to_semi (cfile);
+		return 0;
+	}
+	return 1;
+}
+
+/* string-parameter :== STRING SEMI */
+
+int parse_string (cfile, sptr, lptr)
+	struct parse *cfile;
+	char **sptr;
+	unsigned *lptr;
+{
+	const char *val;
+	enum dhcp_token token;
+	char *s;
+	unsigned len;
+
+	token = next_token (&val, &len, cfile);
+	if (token != STRING) {
+		parse_warn (cfile, "expecting a string");
+		skip_to_semi (cfile);
+		return 0;
+	}
+	s = (char *)dmalloc (len + 1, MDL);
+	if (!s)
+		log_fatal ("no memory for string %s.", val);
+	memcpy (s, val, len + 1);
+
+	if (!parse_semi (cfile)) {
+		dfree (s, MDL);
+		return 0;
+	}
+	if (sptr)
+		*sptr = s;
+	else
+		dfree (s, MDL);
+	if (lptr)
+		*lptr = len;
+	return 1;
+}
+
+/*
+ * hostname :== IDENTIFIER
+ *		| IDENTIFIER DOT
+ *		| hostname DOT IDENTIFIER
+ */
+
+char *parse_host_name (cfile)
+	struct parse *cfile;
+{
+	const char *val;
+	enum dhcp_token token;
+	unsigned len = 0;
+	char *s;
+	char *t;
+	pair c = (pair)0;
+	int ltid = 0;
+	
+	/* Read a dotted hostname... */
+	do {
+		/* Read a token, which should be an identifier. */
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token) && token != NUMBER)
+			break;
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		/* Store this identifier... */
+		if (!(s = (char *)dmalloc (strlen (val) + 1, MDL)))
+			log_fatal ("can't allocate temp space for hostname.");
+		strcpy (s, val);
+		c = cons ((caddr_t)s, c);
+		len += strlen (s) + 1;
+		/* Look for a dot; if it's there, keep going, otherwise
+		   we're done. */
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token == DOT) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			ltid = 1;
+		} else
+			ltid = 0;
+	} while (token == DOT);
+
+	/* Should be at least one token. */
+	if (!len)
+		return (char *)0;
+
+	/* Assemble the hostname together into a string. */
+	if (!(s = (char *)dmalloc (len + ltid, MDL)))
+		log_fatal ("can't allocate space for hostname.");
+	t = s + len + ltid;
+	*--t = 0;
+	if (ltid)
+		*--t = '.';
+	while (c) {
+		pair cdr = c -> cdr;
+		unsigned l = strlen ((char *)(c -> car));
+		t -= l;
+		memcpy (t, (char *)(c -> car), l);
+		/* Free up temp space. */
+		dfree (c -> car, MDL);
+		dfree (c, MDL);
+		c = cdr;
+		if (t != s)
+			*--t = '.';
+	}
+	return s;
+}
+
+/* ip-addr-or-hostname :== ip-address | hostname
+   ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER
+   
+   Parse an ip address or a hostname.   If uniform is zero, put in
+   an expr_substring node to limit hostnames that evaluate to more
+   than one IP address. */
+
+int parse_ip_addr_or_hostname (expr, cfile, uniform)
+	struct expression **expr;
+	struct parse *cfile;
+	int uniform;
+{
+	const char *val;
+	enum dhcp_token token;
+	unsigned char addr [4];
+	unsigned len = sizeof addr;
+	char *name;
+	struct expression *x = (struct expression *)0;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (is_identifier (token)) {
+		name = parse_host_name (cfile);
+		if (!name)
+			return 0;
+		if (!make_host_lookup (expr, name)) {
+			dfree(name, MDL);
+			return 0;
+		}
+		dfree(name, MDL);
+		if (!uniform) {
+			if (!make_limit (&x, *expr, 4))
+				return 0;
+			expression_dereference (expr, MDL);
+			*expr = x;
+		}
+	} else if (token == NUMBER) {
+		if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
+			return 0;
+		return make_const_data (expr, addr, len, 0, 1, MDL);
+	} else {
+		if (token != RBRACE && token != LBRACE)
+			token = next_token (&val, (unsigned *)0, cfile);
+		parse_warn (cfile, "%s (%d): expecting IP address or hostname",
+			    val, token);
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return 0;
+	}
+
+	return 1;
+}	
+	
+/*
+ * ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER
+ */
+
+int parse_ip_addr (cfile, addr)
+	struct parse *cfile;
+	struct iaddr *addr;
+{
+	const char *val;
+	enum dhcp_token token;
+
+	addr -> len = 4;
+	if (parse_numeric_aggregate (cfile, addr -> iabuf,
+				     &addr -> len, DOT, 10, 8))
+		return 1;
+	return 0;
+}	
+
+/*
+ * ip-address-with-subnet :== ip-address |
+ *                          ip-address "/" NUMBER
+ */
+
+int
+parse_ip_addr_with_subnet(cfile, match)
+	struct parse *cfile;
+	struct iaddrmatch *match;
+{
+	const char *val, *orig;
+	enum dhcp_token token;
+	int prefixlen;
+	int fflen;
+	unsigned char newval, warnmask=0;
+
+	if (parse_ip_addr(cfile, &match->addr)) {
+		/* default to host mask */
+		prefixlen = match->addr.len * 8;
+
+		token = peek_token(&val, NULL, cfile);
+
+		if (token == SLASH) {
+			next_token(&val, NULL, cfile);
+			token = next_token(&val, NULL, cfile);
+
+			if (token != NUMBER) {
+				parse_warn(cfile, "Invalid CIDR prefix length:"
+						  " expecting a number.");
+				return 0;
+			}
+
+			prefixlen = atoi(val);
+
+			if (prefixlen < 0 ||
+			    prefixlen > (match->addr.len * 8)) {
+				parse_warn(cfile, "subnet prefix is out of "
+						  "range [0..%d].",
+						  match->addr.len * 8);
+				return 0;
+			}
+		}
+
+		/* construct a suitable mask field */
+
+		/* copy length */
+		match->mask.len = match->addr.len;
+
+		/* count of 0xff bytes in mask */
+		fflen = prefixlen / 8;
+
+		/* set leading mask */
+		memset(match->mask.iabuf, 0xff, fflen);
+
+		/* set zeroes */
+		if (fflen < match->mask.len) {
+			match->mask.iabuf[fflen] =
+			    "\x00\x80\xc0\xe0\xf0\xf8\xfc\xfe"[prefixlen % 8];
+
+			memset(match->mask.iabuf+fflen+1, 0x00, 
+			       match->mask.len - fflen - 1);
+
+			/* AND-out insignificant bits from supplied netmask. */
+			orig = piaddr(match->addr);
+			do {
+				newval = match->addr.iabuf[fflen] &
+					 match->mask.iabuf[fflen];
+
+				if (newval != match->addr.iabuf[fflen]) {
+					warnmask = 1;
+					match->addr.iabuf[fflen] = newval;
+				}
+			} while (++fflen < match->mask.len);
+
+			if (warnmask) {
+				log_error("Warning: Extraneous bits removed "
+					  "in address component of %s/%d.",
+					  orig, prefixlen);
+				log_error("New value: %s/%d.",
+					  piaddr(match->addr), prefixlen);
+			}
+		}
+
+		return 1;
+	}
+
+	parse_warn(cfile,
+		   "expecting ip-address or ip-address/prefixlen");
+
+	return 0;  /* let caller pick up pieces */ 
+}
+
+/*
+ * hardware-parameter :== HARDWARE hardware-type colon-separated-hex-list SEMI
+ * hardware-type :== ETHERNET | TOKEN_RING | FDDI
+ */
+
+void parse_hardware_param (cfile, hardware)
+	struct parse *cfile;
+	struct hardware *hardware;
+{
+	const char *val;
+	enum dhcp_token token;
+	unsigned hlen;
+	unsigned char *t;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	switch (token) {
+	      case ETHERNET:
+		hardware -> hbuf [0] = HTYPE_ETHER;
+		break;
+	      case TOKEN_RING:
+		hardware -> hbuf [0] = HTYPE_IEEE802;
+		break;
+	      case FDDI:
+		hardware -> hbuf [0] = HTYPE_FDDI;
+		break;
+	      default:
+		if (!strncmp (val, "unknown-", 8)) {
+			hardware -> hbuf [0] = atoi (&val [8]);
+		} else {
+			parse_warn (cfile,
+				    "expecting a network hardware type");
+			skip_to_semi (cfile);
+
+			return;
+		}
+	}
+
+	/* Parse the hardware address information.   Technically,
+	   it would make a lot of sense to restrict the length of the
+	   data we'll accept here to the length of a particular hardware
+	   address type.   Unfortunately, there are some broken clients
+	   out there that put bogus data in the chaddr buffer, and we accept
+	   that data in the lease file rather than simply failing on such
+	   clients.   Yuck. */
+	hlen = 0;
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == SEMI) {
+		hardware -> hlen = 1;
+		goto out;
+	}
+	t = parse_numeric_aggregate (cfile, (unsigned char *)0, &hlen,
+				     COLON, 16, 8);
+	if (!t) {
+		hardware -> hlen = 1;
+		return;
+	}
+	if (hlen + 1 > sizeof hardware -> hbuf) {
+		dfree (t, MDL);
+		parse_warn (cfile, "hardware address too long");
+	} else {
+		hardware -> hlen = hlen + 1;
+		memcpy ((unsigned char *)&hardware -> hbuf [1], t, hlen);
+		if (hlen + 1 < sizeof hardware -> hbuf)
+			memset (&hardware -> hbuf [hlen + 1], 0,
+				(sizeof hardware -> hbuf) - hlen - 1);
+		dfree (t, MDL);
+	}
+	
+      out:
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != SEMI) {
+		parse_warn (cfile, "expecting semicolon.");
+		skip_to_semi (cfile);
+	}
+}
+
+/* lease-time :== NUMBER SEMI */
+
+void parse_lease_time (cfile, timep)
+	struct parse *cfile;
+	TIME *timep;
+{
+	const char *val;
+	enum dhcp_token token;
+	u_int32_t num;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "Expecting numeric lease time");
+		skip_to_semi (cfile);
+		return;
+	}
+	convert_num(cfile, (unsigned char *)&num, val, 10, 32);
+	/* Unswap the number - convert_num returns stuff in NBO. */
+	*timep = ntohl(num);
+
+	parse_semi (cfile);
+}
+
+/* No BNF for numeric aggregates - that's defined by the caller.  What
+   this function does is to parse a sequence of numbers separated by
+   the token specified in separator.  If max is zero, any number of
+   numbers will be parsed; otherwise, exactly max numbers are
+   expected.  Base and size tell us how to internalize the numbers
+   once they've been tokenized. */
+
+unsigned char *parse_numeric_aggregate (cfile, buf,
+					max, separator, base, size)
+	struct parse *cfile;
+	unsigned char *buf;
+	unsigned *max;
+	int separator;
+	int base;
+	unsigned size;
+{
+	const char *val;
+	enum dhcp_token token;
+	unsigned char *bufp = buf, *s, *t;
+	unsigned count = 0;
+	pair c = (pair)0;
+
+	if (!bufp && *max) {
+		bufp = (unsigned char *)dmalloc (*max * size / 8, MDL);
+		if (!bufp)
+			log_fatal ("no space for numeric aggregate");
+		s = 0;
+	} else
+		s = bufp;
+
+	do {
+		if (count) {
+			token = peek_token (&val, (unsigned *)0, cfile);
+			if (token != separator) {
+				if (!*max)
+					break;
+				if (token != RBRACE && token != LBRACE)
+					token = next_token (&val,
+							    (unsigned *)0,
+							    cfile);
+				parse_warn (cfile, "too few numbers.");
+				if (token != SEMI)
+					skip_to_semi (cfile);
+				return (unsigned char *)0;
+			}
+			token = next_token (&val, (unsigned *)0, cfile);
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (token == END_OF_FILE) {
+			parse_warn (cfile, "unexpected end of file");
+			break;
+		}
+
+		/* Allow NUMBER_OR_NAME if base is 16. */
+		if (token != NUMBER &&
+		    (base != 16 || token != NUMBER_OR_NAME)) {
+			parse_warn (cfile, "expecting numeric value.");
+			skip_to_semi (cfile);
+			return (unsigned char *)0;
+		}
+		/* If we can, convert the number now; otherwise, build
+		   a linked list of all the numbers. */
+		if (s) {
+			convert_num (cfile, s, val, base, size);
+			s += size / 8;
+		} else {
+			t = (unsigned char *)dmalloc (strlen (val) + 1, MDL);
+			if (!t)
+				log_fatal ("no temp space for number.");
+			strcpy ((char *)t, val);
+			c = cons ((caddr_t)t, c);
+		}
+	} while (++count != *max);
+
+	/* If we had to cons up a list, convert it now. */
+	if (c) {
+		bufp = (unsigned char *)dmalloc (count * size / 8, MDL);
+		if (!bufp)
+			log_fatal ("no space for numeric aggregate.");
+		s = bufp + count - size / 8;
+		*max = count;
+	}
+	while (c) {
+		pair cdr = c -> cdr;
+		convert_num (cfile, s, (char *)(c -> car), base, size);
+		s -= size / 8;
+		/* Free up temp space. */
+		dfree (c -> car, MDL);
+		dfree (c, MDL);
+		c = cdr;
+	}
+	return bufp;
+}
+
+void convert_num (cfile, buf, str, base, size)
+	struct parse *cfile;
+	unsigned char *buf;
+	const char *str;
+	int base;
+	unsigned size;
+{
+	const unsigned char *ptr = str;
+	int negative = 0;
+	u_int32_t val = 0;
+	int tval;
+	int max;
+
+	if (*ptr == '-') {
+		negative = 1;
+		++ptr;
+	}
+
+	/* If base wasn't specified, figure it out from the data. */
+	if (!base) {
+		if (ptr [0] == '0') {
+			if (ptr [1] == 'x') {
+				base = 16;
+				ptr += 2;
+			} else if (isascii (ptr [1]) && isdigit (ptr [1])) {
+				base = 8;
+				ptr += 1;
+			} else {
+				base = 10;
+			}
+		} else {
+			base = 10;
+		}
+	}
+
+	do {
+		tval = *ptr++;
+		/* XXX assumes ASCII... */
+		if (tval >= 'a')
+			tval = tval - 'a' + 10;
+		else if (tval >= 'A')
+			tval = tval - 'A' + 10;
+		else if (tval >= '0')
+			tval -= '0';
+		else {
+			parse_warn (cfile, "Bogus number: %s.", str);
+			break;
+		}
+		if (tval >= base) {
+			parse_warn (cfile,
+				    "Bogus number %s: digit %d not in base %d",
+				    str, tval, base);
+			break;
+		}
+		val = val * base + tval;
+	} while (*ptr);
+
+	if (negative)
+		max = (1 << (size - 1));
+	else
+		max = (1 << (size - 1)) + ((1 << (size - 1)) - 1);
+	if (val > max) {
+		switch (base) {
+		      case 8:
+			parse_warn (cfile,
+				    "%s%lo exceeds max (%d) for precision.",
+				    negative ? "-" : "",
+				    (unsigned long)val, max);
+			break;
+		      case 16:
+			parse_warn (cfile,
+				    "%s%lx exceeds max (%d) for precision.",
+				    negative ? "-" : "",
+				    (unsigned long)val, max);
+			break;
+		      default:
+			parse_warn (cfile,
+				    "%s%lu exceeds max (%d) for precision.",
+				    negative ? "-" : "",
+				    (unsigned long)val, max);
+			break;
+		}
+	}
+
+	if (negative) {
+		switch (size) {
+		      case 8:
+			*buf = -(unsigned long)val;
+			break;
+		      case 16:
+			putShort (buf, -(long)val);
+			break;
+		      case 32:
+			putLong (buf, -(long)val);
+			break;
+		      default:
+			parse_warn (cfile,
+				    "Unexpected integer size: %d\n", size);
+			break;
+		}
+	} else {
+		switch (size) {
+		      case 8:
+			*buf = (u_int8_t)val;
+			break;
+		      case 16:
+			putUShort (buf, (u_int16_t)val);
+			break;
+		      case 32:
+			putULong (buf, val);
+			break;
+		      default:
+			parse_warn (cfile,
+				    "Unexpected integer size: %d\n", size);
+			break;
+		}
+	}
+}
+
+/*
+ * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER 
+ *		NUMBER COLON NUMBER COLON NUMBER SEMI |
+ *          NUMBER NUMBER SLASH NUMBER SLASH NUMBER 
+ *		NUMBER COLON NUMBER COLON NUMBER NUMBER SEMI |
+ *	    NEVER
+ *
+ * Dates are stored in GMT or with a timezone offset; first number is day
+ * of week; next is year/month/day; next is hours:minutes:seconds on a
+ * 24-hour clock, followed by the timezone offset in seconds, which is
+ * optional.
+ */
+
+TIME parse_date (cfile)
+	struct parse *cfile;
+{
+	struct tm tm;
+	int guess;
+	int tzoff, wday, year, mon, mday, hour, min, sec;
+	const char *val;
+	enum dhcp_token token;
+	static int months [11] = { 31, 59, 90, 120, 151, 181,
+					  212, 243, 273, 304, 334 };
+
+	/* Day of week, or "never"... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token == NEVER) {
+		if (!parse_semi (cfile))
+			return 0;
+		return MAX_TIME;
+	}
+
+	/* This indicates 'local' time format. */
+	if (token == EPOCH) {
+		token = next_token(&val, NULL, cfile);
+
+		if (token != NUMBER) {
+			parse_warn(cfile, "Seconds since epoch expected.");
+			if (token != SEMI)
+				skip_to_semi(cfile);
+			return (TIME)0;
+		}
+
+		guess = atoi(val);
+
+		if (!parse_semi(cfile))
+			return (TIME)0;
+
+		return guess;
+	}
+
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric day of week expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	wday = atoi (val);
+
+	/* Year... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric year expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+
+	/* Note: the following is not a Y2K bug - it's a Y1.9K bug.   Until
+	   somebody invents a time machine, I think we can safely disregard
+	   it.   This actually works around a stupid Y2K bug that was present
+	   in a very early beta release of dhcpd. */
+	year = atoi (val);
+	if (year > 1900)
+		year -= 1900;
+
+	/* Slash separating year from month... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != SLASH) {
+		parse_warn (cfile,
+			    "expected slash separating year from month.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+
+	/* Month... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric month expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	mon = atoi (val) - 1;
+
+	/* Slash separating month from day... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != SLASH) {
+		parse_warn (cfile,
+			    "expected slash separating month from day.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+
+	/* Day of month... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric day of month expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	mday = atoi (val);
+
+	/* Hour... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric hour expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	hour = atoi (val);
+
+	/* Colon separating hour from minute... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != COLON) {
+		parse_warn (cfile,
+			    "expected colon separating hour from minute.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+
+	/* Minute... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric minute expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	min = atoi (val);
+
+	/* Colon separating minute from second... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != COLON) {
+		parse_warn (cfile,
+			    "expected colon separating minute from second.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+
+	/* Second... */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "numeric second expected.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return (TIME)0;
+	}
+	sec = atoi (val);
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == NUMBER) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		tzoff = atoi (val);
+	} else
+		tzoff = 0;
+
+	/* Make sure the date ends in a semicolon... */
+	if (!parse_semi (cfile))
+		return 0;
+
+	/* Guess the time value... */
+	guess = ((((((365 * (year - 70) +	/* Days in years since '70 */
+		      (year - 69) / 4 +		/* Leap days since '70 */
+		      (mon			/* Days in months this year */
+		       ? months [mon - 1]
+		       : 0) +
+		      (mon > 1 &&		/* Leap day this year */
+		       !((year - 72) & 3)) +
+		      mday - 1) * 24) +		/* Day of month */
+		    hour) * 60) +
+		  min) * 60) + sec + tzoff;
+
+	/* This guess could be wrong because of leap seconds or other
+	   weirdness we don't know about that the system does.   For
+	   now, we're just going to accept the guess, but at some point
+	   it might be nice to do a successive approximation here to
+	   get an exact value.   Even if the error is small, if the
+	   server is restarted frequently (and thus the lease database
+	   is reread), the error could accumulate into something
+	   significant. */
+
+	return guess;
+}
+
+/*
+ * option-name :== IDENTIFIER |
+ 		   IDENTIFIER . IDENTIFIER
+ */
+
+isc_result_t
+parse_option_name (cfile, allocate, known, opt)
+	struct parse *cfile;
+	int allocate;
+	int *known;
+	struct option **opt;
+{
+	const char *val;
+	enum dhcp_token token;
+	char *uname;
+	struct universe *universe;
+	struct option *option;
+	unsigned code;
+
+	if (opt == NULL)
+		return ISC_R_INVALIDARG;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (!is_identifier (token)) {
+		parse_warn (cfile,
+			    "expecting identifier after option keyword.");
+		if (token != SEMI)
+			skip_to_semi (cfile);
+		return ISC_R_BADPARSE;
+	}
+	uname = dmalloc (strlen (val) + 1, MDL);
+	if (!uname)
+		log_fatal ("no memory for uname information.");
+	strcpy (uname, val);
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == DOT) {
+		/* Go ahead and take the DOT token... */
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		/* The next token should be an identifier... */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token)) {
+			parse_warn (cfile, "expecting identifier after '.'");
+			if (token != SEMI)
+				skip_to_semi (cfile);
+			return ISC_R_BADPARSE;
+		}
+
+		/* Look up the option name hash table for the specified
+		   uname. */
+		universe = (struct universe *)0;
+		if (!universe_hash_lookup (&universe, universe_hash,
+					   uname, 0, MDL)) {
+			parse_warn (cfile, "no option space named %s.", uname);
+			skip_to_semi (cfile);
+			return ISC_R_NOTFOUND;
+		}
+	} else {
+		/* Use the default hash table, which contains all the
+		   standard dhcp option names. */
+		val = uname;
+		universe = &dhcp_universe;
+	}
+
+	/* Look up the actual option info... */
+	option_name_hash_lookup(opt, universe->name_hash, val, 0, MDL);
+	option = *opt;
+
+	/* If we didn't get an option structure, it's an undefined option. */
+	if (option) {
+		if (known)
+			*known = 1;
+	/* If the option name is of the form unknown-[decimal], use
+	 * the trailing decimal value to find the option definition.
+	 * If there is no definition, construct one.  This is to
+	 * support legacy use of unknown options in config files or
+	 * lease databases.
+	 */
+	} else if (strncasecmp(val, "unknown-", 8) == 0) {
+		code = atoi(val+8);
+
+		/* Option code 0 is always illegal for us, thanks
+		 * to the option decoder.
+		 */
+		if (code == 0 || code == universe->end) {
+			parse_warn(cfile, "Option codes 0 and %u are illegal "
+					  "in the %s space.", universe->end,
+					  universe->name);
+			skip_to_semi(cfile);
+			dfree(uname, MDL);
+			return ISC_R_FAILURE;
+		}
+
+		/* It's odd to think of unknown option codes as
+		 * being known, but this means we know what the
+		 * parsed name is talking about.
+		 */
+		if (known)
+			*known = 1;
+
+		option_code_hash_lookup(opt, universe->code_hash,
+					&code, 0, MDL);
+		option = *opt;
+
+		/* If we did not find an option of that code,
+		 * manufacture an unknown-xxx option definition.
+		 * Its single reference will ensure that it is
+		 * deleted once the option is recycled out of
+		 * existence (by the parent).
+		 */
+		if (option == NULL) {
+			option = new_option(val, MDL);
+			option->universe = universe;
+			option->code = code;
+			option->format = default_option_format;
+			option_reference(opt, option, MDL);
+		} else
+			log_info("option %s has been redefined as option %s.  "
+				 "Please update your configs if neccessary.",
+				 val, option->name);
+	/* If we've been told to allocate, that means that this
+	 * (might) be an option code definition, so we'll create
+	 * an option structure and return it for the parent to
+	 * decide.
+	 */
+	} else if (allocate) {
+		option = new_option(val, MDL);
+		option -> universe = universe;
+		option_reference(opt, option, MDL);
+	} else {
+		parse_warn(cfile, "no option named %s in space %s",
+			   val, universe->name);
+		skip_to_semi (cfile);
+		dfree(uname, MDL);
+		return ISC_R_NOTFOUND;
+	}
+
+	/* Free the initial identifier token. */
+	dfree (uname, MDL);
+	return ISC_R_SUCCESS;
+}
+
+/* IDENTIFIER [WIDTHS] SEMI
+ *   WIDTHS ~= LENGTH WIDTH NUMBER
+ *             CODE WIDTH NUMBER
+ */
+
+void parse_option_space_decl (cfile)
+	struct parse *cfile;
+{
+	int token;
+	const char *val;
+	struct universe **ua, *nu;
+	char *nu_name;
+	int tsize=1, lsize=1, hsize = 0;
+
+	next_token (&val, (unsigned *)0, cfile);  /* Discard the SPACE token,
+						     which was checked by the
+						     caller. */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (!is_identifier (token)) {
+		parse_warn (cfile, "expecting identifier.");
+		skip_to_semi (cfile);
+		return;
+	}
+	nu = new_universe (MDL);
+	if (!nu)
+		log_fatal ("No memory for new option space.");
+
+	/* Set up the server option universe... */
+	nu_name = dmalloc (strlen (val) + 1, MDL);
+	if (!nu_name)
+		log_fatal ("No memory for new option space name.");
+	strcpy (nu_name, val);
+	nu -> name = nu_name;
+
+	do {
+		token = next_token(&val, NULL, cfile);
+		switch(token) {
+		      case SEMI:
+			break;
+
+		      case CODE:
+			token = next_token(&val, NULL, cfile);
+			if (token != WIDTH) {
+				parse_warn(cfile, "expecting width token.");
+				goto bad;
+			}
+
+			token = next_token(&val, NULL, cfile);
+			if (token != NUMBER) {
+				parse_warn(cfile, "expecting number 1, 2, 4.");
+				goto bad;
+			}
+
+			tsize = atoi(val);
+
+
+			switch (tsize) {
+			      case 1:
+				if (!hsize)
+					hsize = BYTE_NAME_HASH_SIZE;
+				break;
+			      case 2:
+				if (!hsize)
+					hsize = WORD_NAME_HASH_SIZE;
+				break;
+			      case 4:
+				if (!hsize)
+					hsize = QUAD_NAME_HASH_SIZE;
+				break;
+			      default:
+				parse_warn(cfile, "invalid code width (%d), "
+					          "expecting a 1, 2 or 4.",
+					   tsize);
+				goto bad;
+			}
+			break;
+
+		      case LENGTH:
+			token = next_token(&val, NULL, cfile);
+			if (token != WIDTH) {
+				parse_warn(cfile, "expecting width token.");
+				goto bad;
+			}
+
+			token = next_token(&val, NULL, cfile);
+			if (token != NUMBER) {
+				parse_warn(cfile, "expecting number 1 or 2.");
+				goto bad;
+			}
+
+			lsize = atoi(val);
+			if (lsize != 1 && lsize != 2) {
+				parse_warn(cfile, "invalid length width (%d) "
+						  "expecting 1 or 2.", lsize);
+				goto bad;
+			}
+
+			break;
+
+		      case HASH:
+			token = next_token(&val, NULL, cfile);
+			if (token != SIZE) {
+				parse_warn(cfile, "expecting size token.");
+				goto bad;
+			}
+
+			token = next_token(&val, NULL, cfile);
+			if (token != NUMBER) {
+				parse_warn(cfile, "expecting a 10base number");
+				goto bad;
+			}
+
+			/* (2^31)-1 is the highest Mersenne prime we should
+			 * probably allow...
+			 */
+			hsize = atoi(val);
+			if (hsize < 0 || hsize > 0x7FFFFFFF) {
+				parse_warn(cfile, "invalid hash length: %d",
+					   hsize);
+				goto bad;
+			}
+
+			break;
+
+		      default:
+			parse_warn(cfile, "Unexpected token.");
+		}
+	} while (token != SEMI);
+
+	if (!hsize)
+		hsize = DEFAULT_SPACE_HASH_SIZE;
+
+	nu -> lookup_func = lookup_hashed_option;
+	nu -> option_state_dereference = hashed_option_state_dereference;
+	nu -> foreach = hashed_option_space_foreach;
+	nu -> save_func = save_hashed_option;
+	nu -> delete_func = delete_hashed_option;
+	nu -> encapsulate = hashed_option_space_encapsulate;
+	nu -> decode = parse_option_buffer;
+	nu -> length_size = lsize;
+	nu -> tag_size = tsize;
+	switch(tsize) {
+	      case 1:
+		nu->get_tag = getUChar;
+		nu->store_tag = putUChar;
+		break;
+	      case 2:
+		nu->get_tag = getUShort;
+		nu->store_tag = putUShort;
+		break;
+	      case 4:
+		nu->get_tag = getULong;
+		nu->store_tag = putULong;
+		break;
+	      default:
+		log_fatal("Impossible condition at %s:%d.", MDL);
+	}
+	switch(lsize) {
+	     case 1:
+		nu->get_length = getUChar;
+		nu->store_length = putUChar;
+		break;
+	     case 2:
+		nu->get_length = getUShort;
+		nu->store_length = putUShort;
+		break;
+	     default:
+		log_fatal("Impossible condition at %s:%d.", MDL);
+	}
+	nu -> index = universe_count++;
+	if (nu -> index >= universe_max) {
+		ua = dmalloc (universe_max * 2 * sizeof *ua, MDL);
+		if (!ua)
+			log_fatal ("No memory to expand option space array.");
+		memcpy (ua, universes, universe_max * sizeof *ua);
+		universe_max *= 2;
+		dfree (universes, MDL);
+		universes = ua;
+	}
+	universes [nu -> index] = nu;
+	if (!option_name_new_hash(&nu->name_hash, hsize, MDL) ||
+	    !option_code_new_hash(&nu->code_hash, hsize, MDL))
+		log_fatal("Can't allocate %s option hash table.", nu->name);
+	universe_hash_add (universe_hash, nu -> name, 0, nu, MDL);
+	return;
+
+    bad:
+	dfree(nu_name, MDL);
+	dfree(nu, MDL);
+}
+
+/* This is faked up to look good right now.   Ideally, this should do a
+   recursive parse and allow arbitrary data structure definitions, but for
+   now it just allows you to specify a single type, an array of single types,
+   a sequence of types, or an array of sequences of types.
+
+   ocd :== NUMBER EQUALS ocsd SEMI
+
+   ocsd :== ocsd_type |
+	    ocsd_type_sequence |
+	    ARRAY OF ocsd_simple_type_sequence
+
+   ocsd_type_sequence :== LBRACE ocsd_types RBRACE
+
+   ocsd_simple_type_sequence :== LBRACE ocsd_simple_types RBRACE
+
+   ocsd_types :== ocsd_type |
+		  ocsd_types ocsd_type
+
+   ocsd_type :== ocsd_simple_type |
+		 ARRAY OF ocsd_simple_type
+
+   ocsd_simple_types :== ocsd_simple_type |
+			 ocsd_simple_types ocsd_simple_type
+
+   ocsd_simple_type :== BOOLEAN |
+			INTEGER NUMBER |
+			SIGNED INTEGER NUMBER |
+			UNSIGNED INTEGER NUMBER |
+			IP-ADDRESS |
+			TEXT |
+			STRING |
+			ENCAPSULATE identifier */
+
+int parse_option_code_definition (cfile, option)
+	struct parse *cfile;
+	struct option *option;
+{
+	const char *val;
+	enum dhcp_token token;
+	struct option *oldopt;
+	unsigned arrayp = 0;
+	int recordp = 0;
+	int no_more_in_record = 0;
+	char tokbuf [128];
+	unsigned tokix = 0;
+	char type;
+	int code;
+	int is_signed;
+	char *s;
+	int has_encapsulation = 0;
+	
+	/* Parse the option code. */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != NUMBER) {
+		parse_warn (cfile, "expecting option code number.");
+		skip_to_semi (cfile);
+		return 0;
+	}
+	option -> code = atoi (val);
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != EQUAL) {
+		parse_warn (cfile, "expecting \"=\"");
+		skip_to_semi (cfile);
+		return 0;
+	}
+
+	/* See if this is an array. */
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token == ARRAY) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != OF) {
+			parse_warn (cfile, "expecting \"of\".");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		arrayp = 1;
+		token = next_token (&val, (unsigned *)0, cfile);
+	}
+
+	if (token == LBRACE) {
+		recordp = 1;
+		token = next_token (&val, (unsigned *)0, cfile);
+	}
+
+	/* At this point we're expecting a data type. */
+      next_type:
+	if (has_encapsulation) {
+		parse_warn (cfile,
+			    "encapsulate must always be the last item.");
+		skip_to_semi (cfile);
+		return 0;
+	}
+
+	switch (token) {
+	      case ARRAY:
+		if (arrayp) {
+			parse_warn (cfile, "no nested arrays.");
+			skip_to_rbrace (cfile, recordp);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != OF) {
+			parse_warn (cfile, "expecting \"of\".");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		arrayp = recordp + 1;
+		token = next_token (&val, (unsigned *)0, cfile);
+		if ((recordp) && (token == LBRACE)) {
+			parse_warn (cfile,
+				    "only uniform array inside record.");
+			skip_to_rbrace (cfile, recordp + 1);
+			skip_to_semi (cfile);
+			return 0;
+		}
+		goto next_type;
+	      case BOOLEAN:
+		type = 'f';
+		break;
+	      case INTEGER:
+		is_signed = 1;
+	      parse_integer:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NUMBER) {
+			parse_warn (cfile, "expecting number.");
+			skip_to_rbrace (cfile, recordp);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+		switch (atoi (val)) {
+		      case 8:
+			type = is_signed ? 'b' : 'B';
+			break;
+		      case 16:
+			type = is_signed ? 's' : 'S';
+			break;
+		      case 32:
+			type = is_signed ? 'l' : 'L';
+			break;
+		      default:
+			parse_warn (cfile,
+				    "%s bit precision is not supported.", val);
+			skip_to_rbrace (cfile, recordp);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+		break;
+	      case SIGNED:
+		is_signed = 1;
+	      parse_signed:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != INTEGER) {
+			parse_warn (cfile, "expecting \"integer\" keyword.");
+			skip_to_rbrace (cfile, recordp);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+		goto parse_integer;
+	      case UNSIGNED:
+		is_signed = 0;
+		goto parse_signed;
+
+	      case IP_ADDRESS:
+		type = 'I';
+		break;
+	      case DOMAIN_NAME:
+		type = 'd';
+		goto no_arrays;
+	      case DOMAIN_LIST:
+		type = 'D';
+		goto no_arrays;
+	      case TEXT:
+		type = 't';
+	      no_arrays:
+		if (arrayp) {
+			parse_warn (cfile, "arrays of text strings not %s",
+				    "yet supported.");
+			skip_to_rbrace (cfile, recordp);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+		no_more_in_record = 1;
+		break;
+	      case STRING_TOKEN:
+		type = 'X';
+		goto no_arrays;
+
+	      case ENCAPSULATE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token)) {
+			parse_warn (cfile,
+				    "expecting option space identifier");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		if (strlen (val) + tokix + 2 > sizeof (tokbuf))
+			goto toobig;
+		tokbuf [tokix++] = 'E';
+		strcpy (&tokbuf [tokix], val);
+		tokix += strlen (val);
+		type = '.';
+		has_encapsulation = 1;
+		break;
+
+	      default:
+		parse_warn (cfile, "unknown data type %s", val);
+		skip_to_rbrace (cfile, recordp);
+		if (recordp)
+			skip_to_semi (cfile);
+		return 0;
+	}
+
+	if (tokix == sizeof tokbuf) {
+	      toobig:
+		parse_warn (cfile, "too many types in record.");
+		skip_to_rbrace (cfile, recordp);
+		if (recordp)
+			skip_to_semi (cfile);
+		return 0;
+	}
+	tokbuf [tokix++] = type;
+
+	if (recordp) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (arrayp > recordp) {
+			if (tokix == sizeof tokbuf) {
+				parse_warn (cfile,
+					    "too many types in record.");
+				skip_to_rbrace (cfile, 1);
+				skip_to_semi (cfile);
+				return 0;
+			}
+			arrayp = 0;
+			tokbuf[tokix++] = 'a';
+		}
+		if (token == COMMA) {
+			if (no_more_in_record) {
+				parse_warn (cfile,
+					    "%s must be at end of record.",
+					    type == 't' ? "text" : "string");
+				skip_to_rbrace (cfile, 1);
+				if (recordp)
+					skip_to_semi (cfile);
+				return 0;
+			}
+			token = next_token (&val, (unsigned *)0, cfile);
+			goto next_type;
+		}
+		if (token != RBRACE) {
+			parse_warn (cfile, "expecting right brace.");
+			skip_to_rbrace (cfile, 1);
+			if (recordp)
+				skip_to_semi (cfile);
+			return 0;
+		}
+	}
+	if (!parse_semi (cfile)) {
+		parse_warn (cfile, "semicolon expected.");
+		skip_to_semi (cfile);
+		if (recordp)
+			skip_to_semi (cfile);
+		return 0;
+	}
+	if (has_encapsulation && arrayp) {
+		parse_warn (cfile,
+			    "Arrays of encapsulations don't make sense.");
+		return 0;
+	}
+	if (has_encapsulation && tokbuf [0] == 'E')
+		has_encapsulation = 0;
+	s = dmalloc (tokix +
+		     (arrayp ? 1 : 0) +
+		     (has_encapsulation ? 1 : 0) + 1, MDL);
+	if (!s)
+		log_fatal ("no memory for option format.");
+	if (has_encapsulation)
+		s [0] = 'e';
+	memcpy (s + has_encapsulation, tokbuf, tokix);
+	tokix += has_encapsulation;
+	if (arrayp)
+		s [tokix++] = (arrayp > recordp) ? 'a' : 'A';
+	s [tokix] = 0;
+	option -> format = s;
+
+	oldopt = NULL;
+	option_code_hash_lookup(&oldopt, option->universe->code_hash,
+				&option->code, 0, MDL);
+	if (oldopt != NULL) {
+		/*
+		 * XXX: This illegalizes a configuration syntax that was
+		 * valid in 3.0.x, where multiple name->code mappings are
+		 * given, but only one code->name mapping survives.  It is
+		 * unclear what can or should be done at this point, but it
+		 * seems best to retain 3.0.x behaviour for upgrades to go
+		 * smoothly.
+		 *
+		option_name_hash_delete(option->universe->name_hash,
+					oldopt->name, 0, MDL);
+		 */
+		option_code_hash_delete(option->universe->code_hash,
+					&oldopt->code, 0, MDL);
+
+		option_dereference(&oldopt, MDL);
+	}
+	option_code_hash_add(option->universe->code_hash, &option->code, 0,
+			     option, MDL);
+	option_name_hash_add(option->universe->name_hash, option->name, 0,
+			     option, MDL);
+	return 1;
+}
+
+/*
+ * base64 :== NUMBER_OR_STRING
+ */
+
+int parse_base64 (data, cfile)
+	struct data_string *data;
+	struct parse *cfile;
+{
+	enum dhcp_token token;
+	const char *val;
+	int i, j, k;
+	unsigned acc = 0;
+	static unsigned char
+		from64 [] = {64, 64, 64, 64, 64, 64, 64, 64,  /*  \"#$%&' */
+			     64, 64, 64, 62, 64, 64, 64, 63,  /* ()*+,-./ */
+			     52, 53, 54, 55, 56, 57, 58, 59,  /* 01234567 */
+			     60, 61, 64, 64, 64, 64, 64, 64,  /* 89:;<=>? */
+			     64, 0, 1, 2, 3, 4, 5, 6,	      /* @ABCDEFG */
+			     7, 8, 9, 10, 11, 12, 13, 14,     /* HIJKLMNO */
+			     15, 16, 17, 18, 19, 20, 21, 22,  /* PQRSTUVW */
+			     23, 24, 25, 64, 64, 64, 64, 64,  /* XYZ[\]^_ */
+			     64, 26, 27, 28, 29, 30, 31, 32,  /* 'abcdefg */
+			     33, 34, 35, 36, 37, 38, 39, 40,  /* hijklmno */
+			     41, 42, 43, 44, 45, 46, 47, 48,  /* pqrstuvw */
+			     49, 50, 51, 64, 64, 64, 64, 64}; /* xyz{|}~  */
+	struct string_list *bufs = (struct string_list *)0,
+			   *last = (struct string_list *)0,
+			   *t;
+	int cc = 0;
+	int terminated = 0;
+	
+	/* It's possible for a + or a / to cause a base64 quantity to be
+	   tokenized into more than one token, so we have to parse them all
+	   in before decoding. */
+	do {
+		unsigned l;
+
+		token = next_token (&val, &l, cfile);
+		t = dmalloc (l + sizeof *t, MDL);
+		if (!t)
+			log_fatal ("no memory for base64 buffer.");
+		memset (t, 0, (sizeof *t) - 1);
+		memcpy (t -> string, val, l + 1);
+		cc += l;
+		if (last)
+			last -> next = t;
+		else
+			bufs = t;
+		last = t;
+		token = peek_token (&val, (unsigned *)0, cfile);
+	} while (token == NUMBER_OR_NAME || token == NAME || token == EQUAL ||
+		 token == NUMBER || token == PLUS || token == SLASH ||
+		 token == STRING);
+
+	data -> len = cc;
+	data -> len = (data -> len * 3) / 4;
+	if (!buffer_allocate (&data -> buffer, data -> len, MDL)) {
+		parse_warn (cfile, "can't allocate buffer for base64 data.");
+		data -> len = 0;
+		data -> data = (unsigned char *)0;
+		return 0;
+	}
+		
+	j = k = 0;
+	for (t = bufs; t; t = t -> next) {
+	    for (i = 0; t -> string [i]; i++) {
+		unsigned foo = t -> string [i];
+		if (terminated && foo != '=') {
+			parse_warn (cfile,
+				    "stuff after base64 '=' terminator: %s.",
+				    &t -> string [i]);
+			goto bad;
+		}
+		if (foo < ' ' || foo > 'z') {
+		      bad64:
+			parse_warn (cfile,
+				    "invalid base64 character %d.",
+				    t -> string [i]);
+		      bad:
+			data_string_forget (data, MDL);
+			goto out;
+		}
+		if (foo == '=')
+			terminated = 1;
+		else {
+			foo = from64 [foo - ' '];
+			if (foo == 64)
+				goto bad64;
+			acc = (acc << 6) + foo;
+			switch (k % 4) {
+			      case 0:
+				break;
+			      case 1:
+				data -> buffer -> data [j++] = (acc >> 4);
+				acc = acc & 0x0f;
+				break;
+				
+			      case 2:
+				data -> buffer -> data [j++] = (acc >> 2);
+				acc = acc & 0x03;
+				break;
+			      case 3:
+				data -> buffer -> data [j++] = acc;
+				acc = 0;
+				break;
+			}
+		}
+		k++;
+	    }
+	}
+	if (k % 4) {
+		if (acc) {
+			parse_warn (cfile,
+				    "partial base64 value left over: %d.",
+				    acc);
+		}
+	}
+	data -> len = j;
+	data -> data = data -> buffer -> data;
+      out:
+	for (t = bufs; t; t = last) {
+		last = t -> next;
+		dfree (t, MDL);
+	}
+	if (data -> len)
+		return 1;
+	else
+		return 0;
+}
+
+
+/*
+ * colon-separated-hex-list :== NUMBER |
+ *				NUMBER COLON colon-separated-hex-list
+ */
+
+int parse_cshl (data, cfile)
+	struct data_string *data;
+	struct parse *cfile;
+{
+	u_int8_t ibuf [128];
+	unsigned ilen = 0;
+	unsigned tlen = 0;
+	struct option_tag *sl = (struct option_tag *)0;
+	struct option_tag *next, **last = &sl;
+	enum dhcp_token token;
+	const char *val;
+	unsigned char *rvp;
+
+	do {
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NUMBER && token != NUMBER_OR_NAME) {
+			parse_warn (cfile, "expecting hexadecimal number.");
+			skip_to_semi (cfile);
+			for (; sl; sl = next) {
+				next = sl -> next;
+				dfree (sl, MDL);
+			}
+			return 0;
+		}
+		if (ilen == sizeof ibuf) {
+			next = (struct option_tag *)
+				dmalloc (ilen - 1 +
+					 sizeof (struct option_tag), MDL);
+			if (!next)
+				log_fatal ("no memory for string list.");
+			memcpy (next -> data, ibuf, ilen);
+			*last = next;
+			last = &next -> next;
+			tlen += ilen;
+			ilen = 0;
+		}
+		convert_num (cfile, &ibuf [ilen++], val, 16, 8);
+
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token != COLON)
+			break;
+		token = next_token (&val, (unsigned *)0, cfile);
+	} while (1);
+
+	if (!buffer_allocate (&data -> buffer, tlen + ilen, MDL))
+		log_fatal ("no memory to store octet data.");
+	data -> data = &data -> buffer -> data [0];
+	data -> len = tlen + ilen;
+	data -> terminated = 0;
+
+	rvp = &data -> buffer -> data [0];
+	while (sl) {
+		next = sl -> next;
+		memcpy (rvp, sl -> data, sizeof ibuf);
+		rvp += sizeof ibuf;
+		dfree (sl, MDL);
+		sl = next;
+	}
+	
+	memcpy (rvp, ibuf, ilen);
+	return 1;
+}
+
+/*
+ * executable-statements :== executable-statement executable-statements |
+ *			     executable-statement
+ *
+ * executable-statement :==
+ *	IF if-statement |
+ * 	ADD class-name SEMI |
+ *	BREAK SEMI |
+ *	OPTION option-parameter SEMI |
+ *	SUPERSEDE option-parameter SEMI |
+ *	PREPEND option-parameter SEMI |
+ *	APPEND option-parameter SEMI
+ */
+
+int parse_executable_statements (statements, cfile, lose, case_context)
+	struct executable_statement **statements;
+	struct parse *cfile;
+	int *lose;
+	enum expression_context case_context;
+{
+	struct executable_statement **next;
+
+	next = statements;
+	while (parse_executable_statement (next, cfile, lose, case_context))
+		next = &((*next) -> next);
+	if (!*lose)
+		return 1;
+	return 0;
+}
+
+int parse_executable_statement (result, cfile, lose, case_context)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int *lose;
+	enum expression_context case_context;
+{
+	enum dhcp_token token;
+	const char *val;
+	unsigned len;
+	struct executable_statement base;
+	struct class *cta;
+	struct option *option=NULL;
+	struct option_cache *cache;
+	struct expression **ep;
+	int known;
+	int flag;
+	int i;
+	struct dns_zone *zone;
+	isc_result_t status;
+	char *s;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	switch (token) {
+	      case DB_TIME_FORMAT:
+		next_token(&val, NULL, cfile);
+
+		token = next_token(&val, NULL, cfile);
+		if (token == DEFAULT) {
+			db_time_format = DEFAULT_TIME_FORMAT;
+		} else if (token == LOCAL) {
+			db_time_format = LOCAL_TIME_FORMAT;
+		} else {
+			parse_warn(cfile, "Expecting 'local' or 'default'.");
+			if (token != SEMI)
+				skip_to_semi(cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		token = next_token(&val, NULL, cfile);
+		if (token != SEMI) {
+			parse_warn(cfile, "Expecting a semicolon.");
+			*lose = 1;
+			return 0;
+		}
+
+		/* We're done here. */
+		return 1;
+
+	      case IF:
+		next_token (&val, (unsigned *)0, cfile);
+		return parse_if_statement (result, cfile, lose);
+
+	      case TOKEN_ADD:
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != STRING) {
+			parse_warn (cfile, "expecting class name.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+		cta = (struct class *)0;
+		status = find_class (&cta, val, MDL);
+		if (status != ISC_R_SUCCESS) {
+			parse_warn (cfile, "class %s: %s",
+				    val, isc_result_totext (status));
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			return 0;
+		}
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for new statement.");
+		(*result) -> op = add_statement;
+		(*result) -> data.add = cta;
+		break;
+
+	      case BREAK:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			return 0;
+		}
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for new statement.");
+		(*result) -> op = break_statement;
+		break;
+
+	      case SEND:
+		token = next_token (&val, (unsigned *)0, cfile);
+		known = 0;
+		status = parse_option_name (cfile, 0, &known, &option);
+		if (status != ISC_R_SUCCESS || option == NULL) {
+			*lose = 1;
+			return 0;
+		}
+		status = parse_option_statement(result, cfile, 1, option,
+						send_option_statement);
+		option_dereference(&option, MDL);
+		return status;
+
+	      case SUPERSEDE:
+	      case OPTION:
+		token = next_token (&val, (unsigned *)0, cfile);
+		known = 0;
+		status = parse_option_name (cfile, 0, &known, &option);
+		if (status != ISC_R_SUCCESS || option == NULL) {
+			*lose = 1;
+			return 0;
+		}
+		status = parse_option_statement(result, cfile, 1, option,
+						supersede_option_statement);
+		option_dereference(&option, MDL);
+		return status;
+
+	      case ALLOW:
+		flag = 1;
+		goto pad;
+	      case DENY:
+		flag = 0;
+		goto pad;
+	      case IGNORE:
+		flag = 2;
+	      pad:
+		token = next_token (&val, (unsigned *)0, cfile);
+		cache = (struct option_cache *)0;
+		if (!parse_allow_deny (&cache, cfile, flag))
+			return 0;
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for new statement.");
+		(*result) -> op = supersede_option_statement;
+		(*result) -> data.option = cache;
+		break;
+
+	      case DEFAULT:
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token == COLON)
+			goto switch_default;
+		known = 0;
+		status = parse_option_name (cfile, 0, &known, &option);
+		if (status != ISC_R_SUCCESS || option == NULL) {
+			*lose = 1;
+			return 0;
+		}
+		status = parse_option_statement(result, cfile, 1, option,
+						default_option_statement);
+		option_dereference(&option, MDL);
+		return status;
+
+	      case PREPEND:
+		token = next_token (&val, (unsigned *)0, cfile);
+		known = 0;
+		status = parse_option_name (cfile, 0, &known, &option);
+		if (status != ISC_R_SUCCESS || option == NULL) {
+			*lose = 1;
+			return 0;
+		}
+		status = parse_option_statement(result, cfile, 1, option,
+						prepend_option_statement);
+		option_dereference(&option, MDL);
+		return status;
+
+	      case APPEND:
+		token = next_token (&val, (unsigned *)0, cfile);
+		known = 0;
+		status = parse_option_name (cfile, 0, &known, &option);
+		if (status != ISC_R_SUCCESS || option == NULL) {
+			*lose = 1;
+			return 0;
+		}
+		status = parse_option_statement(result, cfile, 1, option,
+						append_option_statement);
+		option_dereference(&option, MDL);
+		return status;
+
+	      case ON:
+		token = next_token (&val, (unsigned *)0, cfile);
+		return parse_on_statement (result, cfile, lose);
+			
+	      case SWITCH:
+		token = next_token (&val, (unsigned *)0, cfile);
+		return parse_switch_statement (result, cfile, lose);
+
+	      case CASE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (case_context == context_any) {
+			parse_warn (cfile,
+				    "case statement in inappropriate scope.");
+			*lose = 1;
+			skip_to_semi (cfile);
+			return 0;
+		}
+		return parse_case_statement (result,
+					     cfile, lose, case_context);
+
+	      switch_default:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (case_context == context_any) {
+			parse_warn (cfile, "switch default statement in %s",
+				    "inappropriate scope.");
+		
+			*lose = 1;
+			return 0;
+		} else {
+			if (!executable_statement_allocate (result, MDL))
+				log_fatal ("no memory for default statement.");
+			(*result) -> op = default_statement;
+			return 1;
+		}
+			
+	      case DEFINE:
+	      case TOKEN_SET:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token == DEFINE)
+			flag = 1;
+		else
+			flag = 0;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NAME && token != NUMBER_OR_NAME) {
+			parse_warn (cfile,
+				    "%s can't be a variable name", val);
+		      badset:
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for set statement.");
+		(*result) -> op = flag ? define_statement : set_statement;
+		(*result) -> data.set.name = dmalloc (strlen (val) + 1, MDL);
+		if (!(*result)->data.set.name)
+			log_fatal ("can't allocate variable name");
+		strcpy ((*result) -> data.set.name, val);
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (token == LPAREN) {
+			struct string_list *head, *cur, *new;
+			struct expression *expr;
+			head = cur = (struct string_list *)0;
+			do {
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if (token == RPAREN)
+					break;
+				if (token != NAME && token != NUMBER_OR_NAME) {
+					parse_warn (cfile,
+						    "expecting argument name");
+					skip_to_rbrace (cfile, 0);
+					*lose = 1;
+					executable_statement_dereference
+						(result, MDL);
+					return 0;
+				}
+				new = ((struct string_list *)
+				       dmalloc (sizeof (struct string_list) +
+						strlen (val), MDL));
+				if (!new)
+					log_fatal ("can't allocate string.");
+				memset (new, 0, sizeof *new);
+				strcpy (new -> string, val);
+				if (cur) {
+					cur -> next = new;
+					cur = new;
+				} else {
+					head = cur = new;
+				}
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+			} while (token == COMMA);
+
+			if (token != RPAREN) {
+				parse_warn (cfile, "expecting right paren.");
+			      badx:
+				skip_to_semi (cfile);
+				*lose = 1;
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != LBRACE) {
+				parse_warn (cfile, "expecting left brace.");
+				goto badx;
+			}
+
+			expr = (struct expression *)0;
+			if (!(expression_allocate (&expr, MDL)))
+				log_fatal ("can't allocate expression.");
+			expr -> op = expr_function;
+			if (!fundef_allocate (&expr -> data.func, MDL))
+				log_fatal ("can't allocate fundef.");
+			expr -> data.func -> args = head;
+			(*result) -> data.set.expr = expr;
+
+			if (!(parse_executable_statements
+			      (&expr -> data.func -> statements, cfile, lose,
+			       case_context))) {
+				if (*lose)
+					goto badx;
+			}
+
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != RBRACE) {
+				parse_warn (cfile, "expecting rigt brace.");
+				goto badx;
+			}
+		} else {
+			if (token != EQUAL) {
+				parse_warn (cfile,
+					    "expecting '=' in %s statement.",
+					    flag ? "define" : "set");
+				goto badset;
+			}
+
+			if (!parse_expression (&(*result) -> data.set.expr,
+					       cfile, lose, context_any,
+					       (struct expression **)0,
+					       expr_none)) {
+				if (!*lose)
+					parse_warn (cfile,
+						    "expecting expression.");
+				else
+					*lose = 1;
+				skip_to_semi (cfile);
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+			if (!parse_semi (cfile)) {
+				*lose = 1;
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+		}
+		break;
+
+	      case UNSET:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NAME && token != NUMBER_OR_NAME) {
+			parse_warn (cfile,
+				    "%s can't be a variable name", val);
+		      badunset:
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for set statement.");
+		(*result) -> op = unset_statement;
+		(*result) -> data.unset = dmalloc (strlen (val) + 1, MDL);
+		if (!(*result)->data.unset)
+			log_fatal ("can't allocate variable name");
+		strcpy ((*result) -> data.unset, val);
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+		break;
+
+	      case EVAL:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for eval statement.");
+		(*result) -> op = eval_statement;
+
+		if (!parse_expression (&(*result) -> data.eval,
+				       cfile, lose, context_data, /* XXX */
+				       (struct expression **)0, expr_none)) {
+			if (!*lose)
+				parse_warn (cfile,
+					    "expecting data expression.");
+			else
+				*lose = 1;
+			skip_to_semi (cfile);
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+		}
+		break;
+
+	      case EXECUTE:
+#ifdef ENABLE_EXECUTE
+		token = next_token(&val, NULL, cfile);
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for execute statement.");
+		(*result)->op = execute_statement;
+
+		token = next_token(&val, NULL, cfile);
+		if (token != LPAREN) {
+			parse_warn(cfile, "left parenthesis expected.");
+			skip_to_semi(cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		token = next_token(&val, &len, cfile);
+		if (token != STRING) {
+			parse_warn(cfile, "Expecting a quoted string.");
+			skip_to_semi(cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		(*result)->data.execute.command = dmalloc(len + 1, MDL);
+		if ((*result)->data.execute.command == NULL)
+			log_fatal("can't allocate command name");
+		strcpy((*result)->data.execute.command, val);
+
+		ep = &(*result)->data.execute.arglist;
+		(*result)->data.execute.argc = 0;
+
+		while((token = next_token(&val, NULL, cfile)) == COMMA) {
+			if (!expression_allocate(ep, MDL))
+				log_fatal ("can't allocate expression");
+
+ 			if (!parse_data_expression (&(*ep) -> data.arg.val,
+ 					       cfile, lose)) {
+				if (!*lose) {
+					parse_warn (cfile,
+						    "expecting expression.");
+					*lose = 1;
+				}
+				skip_to_semi(cfile);
+				*lose = 1;
+				return 0;
+			}
+			ep = &(*ep)->data.arg.next;
+			(*result)->data.execute.argc++;
+		}
+
+		if (token != RPAREN) {
+			parse_warn(cfile, "right parenthesis expected.");
+			skip_to_semi(cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+		}
+#else /* ! ENABLE_EXECUTE */
+		parse_warn(cfile, "define ENABLE_EXECUTE in site.h to "
+				  "enable execute(); expressions.");
+		skip_to_semi(cfile);
+		*lose = 1;
+		return 0;
+#endif /* ENABLE_EXECUTE */
+		break;
+
+	      case RETURN:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for return statement.");
+		(*result) -> op = return_statement;
+
+		if (!parse_expression (&(*result) -> data.retval,
+				       cfile, lose, context_data,
+				       (struct expression **)0, expr_none)) {
+			if (!*lose)
+				parse_warn (cfile,
+					    "expecting data expression.");
+			else
+				*lose = 1;
+			skip_to_semi (cfile);
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+		if (!parse_semi (cfile)) {
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+		break;
+
+	      case LOG:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (!executable_statement_allocate (result, MDL))
+			log_fatal ("no memory for log statement.");
+		(*result) -> op = log_statement;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN) {
+			parse_warn (cfile, "left parenthesis expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		token = peek_token (&val, (unsigned *)0, cfile);
+		i = 1;
+		if (token == FATAL) {
+			(*result) -> data.log.priority = log_priority_fatal;
+		} else if (token == ERROR) {
+			(*result) -> data.log.priority = log_priority_error;
+		} else if (token == TOKEN_DEBUG) {
+			(*result) -> data.log.priority = log_priority_debug;
+		} else if (token == INFO) {
+			(*result) -> data.log.priority = log_priority_info;
+		} else {
+			(*result) -> data.log.priority = log_priority_debug;
+			i = 0;
+		}
+		if (i) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != COMMA) {
+				parse_warn (cfile, "comma expected.");
+				skip_to_semi (cfile);
+				*lose = 1;
+				return 0;
+			}
+		}
+
+		if (!(parse_data_expression
+		      (&(*result) -> data.log.expr, cfile, lose))) {
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+			parse_warn (cfile, "right parenthesis expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != SEMI) {
+			parse_warn (cfile, "semicolon expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+		break;
+
+		/* Not really a statement, but we parse it here anyway
+		   because it's appropriate for all DHCP agents with
+		   parsers. */
+	      case ZONE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		zone = (struct dns_zone *)0;
+		if (!dns_zone_allocate (&zone, MDL))
+			log_fatal ("no memory for new zone.");
+		zone -> name = parse_host_name (cfile);
+		if (!zone -> name) {
+			parse_warn (cfile, "expecting hostname.");
+		      badzone:
+			*lose = 1;
+			skip_to_semi (cfile);
+			dns_zone_dereference (&zone, MDL);
+			return 0;
+		}
+		i = strlen (zone -> name);
+		if (zone -> name [i - 1] != '.') {
+			s = dmalloc ((unsigned)i + 2, MDL);
+			if (!s) {
+				parse_warn (cfile, "no trailing '.' on zone");
+				goto badzone;
+			}
+			strcpy (s, zone -> name);
+			s [i] = '.';
+			s [i + 1] = 0;
+			dfree (zone -> name, MDL);
+			zone -> name = s;
+		}
+		if (!parse_zone (zone, cfile))
+			goto badzone;
+		status = enter_dns_zone (zone);
+		if (status != ISC_R_SUCCESS) {
+			parse_warn (cfile, "dns zone key %s: %s",
+				    zone -> name, isc_result_totext (status));
+			dns_zone_dereference (&zone, MDL);
+			return 0;
+		}
+		dns_zone_dereference (&zone, MDL);
+		return 1;
+		
+		/* Also not really a statement, but same idea as above. */
+	      case KEY:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!parse_key (cfile)) {
+			*lose = 1;
+			return 0;
+		}
+		return 1;
+
+	      default:
+		if (config_universe && is_identifier (token)) {
+			option = (struct option *)0;
+			option_name_hash_lookup(&option,
+						config_universe->name_hash,
+						val, 0, MDL);
+			if (option) {
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				status = parse_option_statement
+						(result, cfile, 1, option,
+						 supersede_option_statement);
+				option_dereference(&option, MDL);
+				return status;
+			}
+		}
+
+		if (token == NUMBER_OR_NAME || token == NAME) {
+			/* This is rather ugly.  Since function calls are
+			   data expressions, fake up an eval statement. */
+			if (!executable_statement_allocate (result, MDL))
+				log_fatal ("no memory for eval statement.");
+			(*result) -> op = eval_statement;
+
+			if (!parse_expression (&(*result) -> data.eval,
+					       cfile, lose, context_data,
+					       (struct expression **)0,
+					       expr_none)) {
+				if (!*lose)
+					parse_warn (cfile, "expecting "
+						    "function call.");
+				else
+					*lose = 1;
+				skip_to_semi (cfile);
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+			if (!parse_semi (cfile)) {
+				*lose = 1;
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+			break;
+		}
+
+		*lose = 0;
+		return 0;
+	}
+
+	return 1;
+}
+
+/* zone-statements :== zone-statement |
+		       zone-statement zone-statements
+   zone-statement :==
+	PRIMARY ip-addresses SEMI |
+	SECONDARY ip-addresses SEMI |
+	key-reference SEMI
+   ip-addresses :== ip-addr-or-hostname |
+		  ip-addr-or-hostname COMMA ip-addresses
+   key-reference :== KEY STRING |
+		    KEY identifier */
+
+int parse_zone (struct dns_zone *zone, struct parse *cfile)
+{
+	int token;
+	const char *val;
+	char *key_name;
+	struct option_cache *oc;
+	int done = 0;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != LBRACE) {
+		parse_warn (cfile, "expecting left brace");
+		return 0;
+	}
+
+	do {
+	    token = peek_token (&val, (unsigned *)0, cfile);
+	    switch (token) {
+		  case PRIMARY:
+		    if (zone -> primary) {
+			    parse_warn (cfile,
+					"more than one primary.");
+			    skip_to_semi (cfile);
+			    return 0;
+		    }
+		    if (!option_cache_allocate (&zone -> primary, MDL))
+			    log_fatal ("can't allocate primary option cache.");
+		    oc = zone -> primary;
+		    goto consemup;
+		    
+		  case SECONDARY:
+		    if (zone -> secondary) {
+			    parse_warn (cfile, "more than one secondary.");
+			skip_to_semi (cfile);
+			return 0;
+		    }
+		    if (!option_cache_allocate (&zone -> secondary, MDL))
+			    log_fatal ("can't allocate secondary.");
+		    oc = zone -> secondary;
+		  consemup:
+		    token = next_token (&val, (unsigned *)0, cfile);
+		    do {
+			    struct expression *expr = (struct expression *)0;
+			    if (!parse_ip_addr_or_hostname (&expr, cfile, 0)) {
+				parse_warn (cfile,
+					    "expecting IP addr or hostname.");
+				skip_to_semi (cfile);
+				return 0;
+			    }
+			    if (oc -> expression) {
+				    struct expression *old =
+					    (struct expression *)0;
+				    expression_reference (&old,
+							  oc -> expression,
+							  MDL);
+				    expression_dereference (&oc -> expression,
+							    MDL);
+				    if (!make_concat (&oc -> expression,
+						      old, expr))
+					log_fatal ("no memory for concat.");
+				    expression_dereference (&expr, MDL);
+				    expression_dereference (&old, MDL);
+			    } else {
+				    expression_reference (&oc -> expression,
+							  expr, MDL);
+				    expression_dereference (&expr, MDL);
+			    }
+			    token = next_token (&val, (unsigned *)0, cfile);
+		    } while (token == COMMA);
+		    if (token != SEMI) {
+			    parse_warn (cfile, "expecting semicolon.");
+			    skip_to_semi (cfile);
+			    return 0;
+		    }
+		    break;
+
+		  case KEY:
+		    token = next_token (&val, (unsigned *)0, cfile);
+		    token = peek_token (&val, (unsigned *)0, cfile);
+		    if (token == STRING) {
+			    token = next_token (&val, (unsigned *)0, cfile);
+			    key_name = (char *)0;
+		    } else {
+			    key_name = parse_host_name (cfile);
+			    if (!key_name) {
+				    parse_warn (cfile, "expecting key name.");
+				    skip_to_semi (cfile);
+				    return 0;
+			    }
+			    val = key_name;
+		    }
+		    if (omapi_auth_key_lookup_name (&zone -> key, val) !=
+			ISC_R_SUCCESS)
+			    parse_warn (cfile, "unknown key %s", val);
+		    if (key_name)
+			    dfree (key_name, MDL);
+		    if (!parse_semi (cfile))
+			    return 0;
+		    break;
+		    
+		  default:
+		    done = 1;
+		    break;
+	    }
+	} while (!done);
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != RBRACE) {
+		parse_warn (cfile, "expecting right brace.");
+		return 0;
+	}
+	return 1;
+}
+
+/* key-statements :== key-statement |
+		      key-statement key-statements
+   key-statement :==
+	ALGORITHM host-name SEMI |
+	secret-definition SEMI
+   secret-definition :== SECRET base64val |
+			 SECRET STRING */
+
+int parse_key (struct parse *cfile)
+{
+	int token;
+	const char *val;
+	int done = 0;
+	struct auth_key *key;
+	struct data_string ds;
+	isc_result_t status;
+	char *s;
+
+	key = (struct auth_key *)0;
+	if (omapi_auth_key_new (&key, MDL) != ISC_R_SUCCESS)
+		log_fatal ("no memory for key");
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == STRING) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		key -> name = dmalloc (strlen (val) + 1, MDL);
+		if (!key -> name)
+			log_fatal ("no memory for key name.");
+		strcpy (key -> name, val);
+
+	} else {
+		key -> name = parse_host_name (cfile);
+		if (!key -> name) {
+			parse_warn (cfile, "expecting key name.");
+			skip_to_semi (cfile);
+			goto bad;
+		}
+	}
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != LBRACE) {
+		parse_warn (cfile, "expecting left brace");
+		goto bad;
+	}
+
+	do {
+		token = next_token (&val, (unsigned *)0, cfile);
+		switch (token) {
+		      case ALGORITHM:
+			if (key -> algorithm) {
+				parse_warn (cfile,
+					    "key %s: too many algorithms",
+					    key -> name);
+				goto rbad;
+			}
+			key -> algorithm = parse_host_name (cfile);
+			if (!key -> algorithm) {
+				parse_warn (cfile,
+					    "expecting key algorithm name.");
+				goto rbad;
+			}
+			if (!parse_semi (cfile))
+				goto rbad;
+			/* If the algorithm name isn't an FQDN, tack on
+			   the .SIG-ALG.REG.NET. domain. */
+			s = strrchr (key -> algorithm, '.');
+			if (!s) {
+			    static char add [] = ".SIG-ALG.REG.INT.";
+			    s = dmalloc (strlen (key -> algorithm) +
+					 sizeof (add), MDL);
+			    if (!s) {
+				log_error ("no memory for key %s.",
+					   "algorithm");
+				goto rbad;
+			    }
+			    strcpy (s, key -> algorithm);
+			    strcat (s, add);
+			    dfree (key -> algorithm, MDL);
+			    key -> algorithm = s;
+			} else if (s [1]) {
+			    /* If there is no trailing '.', hack one in. */
+			    s = dmalloc (strlen (key -> algorithm) + 2, MDL);
+			    if (!s) {
+				    log_error ("no memory for key %s.",
+					       key -> algorithm);
+				    goto rbad;
+			    }
+			    strcpy (s, key -> algorithm);
+			    strcat (s, ".");
+			    dfree (key -> algorithm, MDL);
+			    key -> algorithm = s;
+			}
+			break;
+
+		      case SECRET:
+			if (key -> key) {
+				parse_warn (cfile, "key %s: too many secrets",
+					    key -> name);
+				goto rbad;
+			}
+
+			memset (&ds, 0, sizeof(ds));
+			if (!parse_base64 (&ds, cfile))
+				goto rbad;
+			status = omapi_data_string_new (&key -> key, ds.len,
+							MDL);
+			if (status != ISC_R_SUCCESS)
+				goto rbad;
+			memcpy (key -> key -> value,
+				ds.buffer -> data, ds.len);
+			data_string_forget (&ds, MDL);
+
+			if (!parse_semi (cfile))
+				goto rbad;
+			break;
+
+		      default:
+			done = 1;
+			break;
+		}
+	} while (!done);
+	if (token != RBRACE) {
+		parse_warn (cfile, "expecting right brace.");
+		goto rbad;
+	}
+	/* Allow the BIND 8 syntax, which has a semicolon after each
+	   closing brace. */
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == SEMI)
+		token = next_token (&val, (unsigned *)0, cfile);
+
+	/* Remember the key. */
+	status = omapi_auth_key_enter (key);
+	if (status != ISC_R_SUCCESS) {
+		parse_warn (cfile, "tsig key %s: %s",
+			    key -> name, isc_result_totext (status));
+		goto bad;
+	}
+	omapi_auth_key_dereference (&key, MDL);
+	return 1;
+
+      rbad:
+	skip_to_rbrace (cfile, 1);
+      bad:
+	omapi_auth_key_dereference (&key, MDL);
+	return 0;
+}
+
+/*
+ * on-statement :== event-types LBRACE executable-statements RBRACE
+ * event-types :== event-type OR event-types |
+ *		   event-type
+ * event-type :== EXPIRY | COMMIT | RELEASE
+ */
+
+int parse_on_statement (result, cfile, lose)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int *lose;
+{
+	enum dhcp_token token;
+	const char *val;
+
+	if (!executable_statement_allocate (result, MDL))
+		log_fatal ("no memory for new statement.");
+	(*result) -> op = on_statement;
+
+	do {
+		token = next_token (&val, (unsigned *)0, cfile);
+		switch (token) {
+		      case EXPIRY:
+			(*result) -> data.on.evtypes |= ON_EXPIRY;
+			break;
+		
+		      case COMMIT:
+			(*result) -> data.on.evtypes |= ON_COMMIT;
+			break;
+			
+		      case RELEASE:
+			(*result) -> data.on.evtypes |= ON_RELEASE;
+			break;
+			
+		      case TRANSMISSION:
+			(*result) -> data.on.evtypes |= ON_TRANSMISSION;
+			break;
+
+		      default:
+			parse_warn (cfile, "expecting a lease event type");
+			skip_to_semi (cfile);
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+	} while (token == OR);
+		
+	/* Semicolon means no statements. */
+	if (token == SEMI)
+		return 1;
+
+	if (token != LBRACE) {
+		parse_warn (cfile, "left brace expected.");
+		skip_to_semi (cfile);
+		*lose = 1;
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+	if (!parse_executable_statements (&(*result) -> data.on.statements,
+					  cfile, lose, context_any)) {
+		if (*lose) {
+			/* Try to even things up. */
+			do {
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+			} while (token != END_OF_FILE && token != RBRACE);
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+	}
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != RBRACE) {
+		parse_warn (cfile, "right brace expected.");
+		skip_to_semi (cfile);
+		*lose = 1;
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * switch-statement :== LPAREN expr RPAREN LBRACE executable-statements RBRACE
+ *
+ */
+
+int parse_switch_statement (result, cfile, lose)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int *lose;
+{
+	enum dhcp_token token;
+	const char *val;
+
+	if (!executable_statement_allocate (result, MDL))
+		log_fatal ("no memory for new statement.");
+	(*result) -> op = switch_statement;
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != LPAREN) {
+		parse_warn (cfile, "expecting left brace.");
+	      pfui:
+		*lose = 1;
+		skip_to_semi (cfile);
+	      gnorf:
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+
+	if (!parse_expression (&(*result) -> data.s_switch.expr,
+			       cfile, lose, context_data_or_numeric,
+			       (struct expression **)0, expr_none)) {
+		if (!*lose) {
+			parse_warn (cfile,
+				    "expecting data or numeric expression.");
+			goto pfui;
+		}
+		goto gnorf;
+	}
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != RPAREN) {
+		parse_warn (cfile, "right paren expected.");
+		goto pfui;
+	}
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != LBRACE) {
+		parse_warn (cfile, "left brace expected.");
+		goto pfui;
+	}
+	if (!(parse_executable_statements
+	      (&(*result) -> data.s_switch.statements, cfile, lose,
+	       (is_data_expression ((*result) -> data.s_switch.expr)
+		? context_data : context_numeric)))) {
+		if (*lose) {
+			skip_to_rbrace (cfile, 1);
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+	}
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != RBRACE) {
+		parse_warn (cfile, "right brace expected.");
+		goto pfui;
+	}
+	return 1;
+}
+
+/*
+ * case-statement :== CASE expr COLON
+ *
+ */
+
+int parse_case_statement (result, cfile, lose, case_context)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int *lose;
+	enum expression_context case_context;
+{
+	enum dhcp_token token;
+	const char *val;
+
+	if (!executable_statement_allocate (result, MDL))
+		log_fatal ("no memory for new statement.");
+	(*result) -> op = case_statement;
+
+	if (!parse_expression (&(*result) -> data.c_case,
+			       cfile, lose, case_context,
+			       (struct expression **)0, expr_none))
+	{
+		if (!*lose) {
+			parse_warn (cfile, "expecting %s expression.",
+				    (case_context == context_data
+				     ? "data" : "numeric"));
+		}
+	      pfui:
+		*lose = 1;
+		skip_to_semi (cfile);
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != COLON) {
+		parse_warn (cfile, "colon expected.");
+		goto pfui;
+	}
+	return 1;
+}
+
+/*
+ * if-statement :== boolean-expression LBRACE executable-statements RBRACE
+ *						else-statement
+ *
+ * else-statement :== <null> |
+ *		      ELSE LBRACE executable-statements RBRACE |
+ *		      ELSE IF if-statement |
+ *		      ELSIF if-statement
+ */
+
+int parse_if_statement (result, cfile, lose)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int *lose;
+{
+	enum dhcp_token token;
+	const char *val;
+	int parenp;
+
+	if (!executable_statement_allocate (result, MDL))
+		log_fatal ("no memory for if statement.");
+
+	(*result) -> op = if_statement;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == LPAREN) {
+		parenp = 1;
+		next_token (&val, (unsigned *)0, cfile);
+	} else
+		parenp = 0;
+
+
+	if (!parse_boolean_expression (&(*result) -> data.ie.expr,
+				       cfile, lose)) {
+		if (!*lose)
+			parse_warn (cfile, "boolean expression expected.");
+		executable_statement_dereference (result, MDL);
+		*lose = 1;
+		return 0;
+	}
+#if defined (DEBUG_EXPRESSION_PARSE)
+	print_expression ("if condition", (*result) -> data.ie.expr);
+#endif
+	if (parenp) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+			parse_warn (cfile, "expecting right paren.");
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+	}
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != LBRACE) {
+		parse_warn (cfile, "left brace expected.");
+		skip_to_semi (cfile);
+		*lose = 1;
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+	if (!parse_executable_statements (&(*result) -> data.ie.tc,
+					  cfile, lose, context_any)) {
+		if (*lose) {
+			/* Try to even things up. */
+			do {
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+			} while (token != END_OF_FILE && token != RBRACE);
+			executable_statement_dereference (result, MDL);
+			return 0;
+		}
+	}
+	token = next_token (&val, (unsigned *)0, cfile);
+	if (token != RBRACE) {
+		parse_warn (cfile, "right brace expected.");
+		skip_to_semi (cfile);
+		*lose = 1;
+		executable_statement_dereference (result, MDL);
+		return 0;
+	}
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == ELSE) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token == IF) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (!parse_if_statement (&(*result) -> data.ie.fc,
+						 cfile, lose)) {
+				if (!*lose)
+					parse_warn (cfile,
+						    "expecting if statement");
+				executable_statement_dereference (result, MDL);
+				*lose = 1;
+				return 0;
+			}
+		} else if (token != LBRACE) {
+			parse_warn (cfile, "left brace or if expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			executable_statement_dereference (result, MDL);
+			return 0;
+		} else {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (!(parse_executable_statements
+			      (&(*result) -> data.ie.fc,
+			       cfile, lose, context_any))) {
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != RBRACE) {
+				parse_warn (cfile, "right brace expected.");
+				skip_to_semi (cfile);
+				*lose = 1;
+				executable_statement_dereference (result, MDL);
+				return 0;
+			}
+		}
+	} else if (token == ELSIF) {
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!parse_if_statement (&(*result) -> data.ie.fc,
+					 cfile, lose)) {
+			if (!*lose)
+				parse_warn (cfile,
+					    "expecting conditional.");
+			executable_statement_dereference (result, MDL);
+			*lose = 1;
+			return 0;
+		}
+	} else
+		(*result) -> data.ie.fc = (struct executable_statement *)0;
+	
+	return 1;
+}
+
+/*
+ * boolean_expression :== CHECK STRING |
+ *  			  NOT boolean-expression |
+ *			  data-expression EQUAL data-expression |
+ *			  data-expression BANG EQUAL data-expression |
+ *			  boolean-expression AND boolean-expression |
+ *			  boolean-expression OR boolean-expression
+ *			  EXISTS OPTION-NAME
+ */
+   			  
+int parse_boolean_expression (expr, cfile, lose)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+{
+	/* Parse an expression... */
+	if (!parse_expression (expr, cfile, lose, context_boolean,
+			       (struct expression **)0, expr_none))
+		return 0;
+
+	if (!is_boolean_expression (*expr) &&
+	    (*expr) -> op != expr_variable_reference &&
+	    (*expr) -> op != expr_funcall) {
+		parse_warn (cfile, "Expecting a boolean expression.");
+		*lose = 1;
+		expression_dereference (expr, MDL);
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * data_expression :== SUBSTRING LPAREN data-expression COMMA
+ *					numeric-expression COMMA
+ *					numeric-expression RPAREN |
+ *		       CONCAT LPAREN data-expression COMMA 
+ *					data-expression RPAREN
+ *		       SUFFIX LPAREN data_expression COMMA
+ *		       		     numeric-expression RPAREN |
+ *		       LCASE LPAREN data_expression RPAREN |
+ *		       UCASE LPAREN data_expression RPAREN |
+ *		       OPTION option_name |
+ *		       HARDWARE |
+ *		       PACKET LPAREN numeric-expression COMMA
+ *				     numeric-expression RPAREN |
+ *		       STRING |
+ *		       colon_separated_hex_list
+ */
+
+int parse_data_expression (expr, cfile, lose)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+{
+	/* Parse an expression... */
+	if (!parse_expression (expr, cfile, lose, context_data,
+			       (struct expression **)0, expr_none))
+		return 0;
+
+	if (!is_data_expression (*expr) &&
+	    (*expr) -> op != expr_variable_reference &&
+	    (*expr) -> op != expr_funcall) {
+		expression_dereference (expr, MDL);
+		parse_warn (cfile, "Expecting a data expression.");
+		*lose = 1;
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * numeric-expression :== EXTRACT_INT LPAREN data-expression
+ *					     COMMA number RPAREN |
+ *			  NUMBER
+ */
+
+int parse_numeric_expression (expr, cfile, lose)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+{
+	/* Parse an expression... */
+	if (!parse_expression (expr, cfile, lose, context_numeric,
+			       (struct expression **)0, expr_none))
+		return 0;
+
+	if (!is_numeric_expression (*expr) &&
+	    (*expr) -> op != expr_variable_reference &&
+	    (*expr) -> op != expr_funcall) {
+		expression_dereference (expr, MDL);
+		parse_warn (cfile, "Expecting a numeric expression.");
+		*lose = 1;
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * dns-expression :==
+ *	UPDATE LPAREN ns-class COMMA ns-type COMMA data-expression COMMA
+ *				data-expression COMMA numeric-expression RPAREN
+ *	DELETE LPAREN ns-class COMMA ns-type COMMA data-expression COMMA
+ *				data-expression RPAREN
+ *	EXISTS LPAREN ns-class COMMA ns-type COMMA data-expression COMMA
+ *				data-expression RPAREN
+ *	NOT EXISTS LPAREN ns-class COMMA ns-type COMMA data-expression COMMA
+ *				data-expression RPAREN
+ * ns-class :== IN | CHAOS | HS | NUMBER
+ * ns-type :== A | PTR | MX | TXT | NUMBER
+ */
+
+int parse_dns_expression (expr, cfile, lose)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+{
+	/* Parse an expression... */
+	if (!parse_expression (expr, cfile, lose, context_dns,
+			       (struct expression **)0, expr_none))
+		return 0;
+
+	if (!is_dns_expression (*expr) &&
+	    (*expr) -> op != expr_variable_reference &&
+	    (*expr) -> op != expr_funcall) {
+		expression_dereference (expr, MDL);
+		parse_warn (cfile, "Expecting a dns update subexpression.");
+		*lose = 1;
+		return 0;
+	}
+	return 1;
+}
+
+/* Parse a subexpression that does not contain a binary operator. */
+
+int parse_non_binary (expr, cfile, lose, context)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+	enum expression_context context;
+{
+	enum dhcp_token token;
+	const char *val;
+	struct collection *col;
+	struct option *option;
+	struct expression *nexp, **ep;
+	int known;
+	enum expr_op opcode;
+	const char *s;
+	char *cptr;
+	struct executable_statement *stmt;
+	int i;
+	unsigned long u;
+	isc_result_t status, code;
+	unsigned len;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+
+	/* Check for unary operators... */
+	switch (token) {
+	      case CHECK:
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != STRING) {
+			parse_warn (cfile, "string expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+		for (col = collections; col; col = col -> next)
+			if (!strcmp (col -> name, val))
+				break;
+		if (!col) {
+			parse_warn (cfile, "unknown collection.");
+			*lose = 1;
+			return 0;
+		}
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_check;
+		(*expr) -> data.check = col;
+		break;
+
+	      case TOKEN_NOT:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (context == context_dns) {
+			token = peek_token (&val, (unsigned *)0, cfile);
+			goto not_exists;
+		}
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_not;
+		if (!parse_non_binary (&(*expr) -> data.not,
+				       cfile, lose, context_boolean)) {
+			if (!*lose) {
+				parse_warn (cfile, "expression expected");
+				skip_to_semi (cfile);
+			}
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		if (!is_boolean_expression ((*expr) -> data.not)) {
+			*lose = 1;
+			parse_warn (cfile, "boolean expression expected");
+			skip_to_semi (cfile);
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+
+	      case LPAREN:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!parse_expression (expr, cfile, lose, context,
+				       (struct expression **)0, expr_none)) {
+			if (!*lose) {
+				parse_warn (cfile, "expression expected");
+				skip_to_semi (cfile);
+			}
+			*lose = 1;
+			return 0;
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+			*lose = 1;
+			parse_warn (cfile, "right paren expected");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		break;
+
+	      case EXISTS:
+		if (context == context_dns)
+			goto ns_exists;
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_exists;
+		known = 0;
+		/* Pass reference directly to expression structure. */
+		status = parse_option_name(cfile, 0, &known,
+					   &(*expr)->data.option);
+		if (status != ISC_R_SUCCESS ||
+		    (*expr)->data.option == NULL) {
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+
+	      case STATIC:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_static;
+		break;
+
+	      case KNOWN:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_known;
+		break;
+
+	      case SUBSTRING:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_substring;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN) {
+		      nolparen:
+			expression_dereference (expr, MDL);
+			parse_warn (cfile, "left parenthesis expected.");
+			*lose = 1;
+			return 0;
+		}
+
+		if (!parse_data_expression (&(*expr) -> data.substring.expr,
+					    cfile, lose)) {
+		      nodata:
+			expression_dereference (expr, MDL);
+			if (!*lose) {
+				parse_warn (cfile,
+					    "expecting data expression.");
+				skip_to_semi (cfile);
+				*lose = 1;
+			}
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA) {
+		      nocomma:
+			expression_dereference (expr, MDL);
+			parse_warn (cfile, "comma expected.");
+			*lose = 1;
+
+			return 0;
+		}
+
+		if (!parse_numeric_expression
+		    (&(*expr) -> data.substring.offset,cfile, lose)) {
+		      nonum:
+			if (!*lose) {
+				parse_warn (cfile,
+					    "expecting numeric expression.");
+				skip_to_semi (cfile);
+				*lose = 1;
+			}
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_numeric_expression
+		    (&(*expr) -> data.substring.len, cfile, lose))
+			goto nonum;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+		      norparen:
+			parse_warn (cfile, "right parenthesis expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+
+	      case SUFFIX:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_suffix;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_data_expression (&(*expr) -> data.suffix.expr,
+					    cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_numeric_expression (&(*expr) -> data.suffix.len,
+					       cfile, lose))
+			goto nonum;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case LCASE:
+		token = next_token(&val, (unsigned *)0, cfile);
+		if (!expression_allocate(expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr)->op = expr_lcase;
+
+		token = next_token(&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_data_expression(&(*expr)->data.lcase, cfile, lose))
+			goto nodata;
+
+		token = next_token(&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case UCASE:
+		token = next_token(&val, (unsigned *)0, cfile);
+		if (!expression_allocate(expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr)->op = expr_ucase;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_data_expression(&(*expr)->data.ucase,
+					   cfile, lose))
+			goto nodata;
+
+		token = next_token(&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case CONCAT:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_concat;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_data_expression (&(*expr) -> data.concat [0],
+					    cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+	      concat_another:
+		if (!parse_data_expression (&(*expr) -> data.concat [1],
+					    cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		if (token == COMMA) {
+			nexp = (struct expression *)0;
+			if (!expression_allocate (&nexp, MDL))
+				log_fatal ("can't allocate at CONCAT2");
+			nexp -> op = expr_concat;
+			expression_reference (&nexp -> data.concat [0],
+					      *expr, MDL);
+			expression_dereference (expr, MDL);
+			expression_reference (expr, nexp, MDL);
+			expression_dereference (&nexp, MDL);
+			goto concat_another;
+		}
+
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case BINARY_TO_ASCII:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_binary_to_ascii;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_numeric_expression (&(*expr) -> data.b2a.base,
+					       cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_numeric_expression (&(*expr) -> data.b2a.width,
+					       cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_data_expression (&(*expr) -> data.b2a.separator,
+					    cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_data_expression (&(*expr) -> data.b2a.buffer,
+					    cfile, lose))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case REVERSE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_reverse;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!(parse_numeric_expression
+		      (&(*expr) -> data.reverse.width, cfile, lose)))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!(parse_data_expression
+		      (&(*expr) -> data.reverse.buffer, cfile, lose)))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case PICK:
+		/* pick (a, b, c) actually produces an internal representation
+		   that looks like pick (a, pick (b, pick (c, nil))). */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!(expression_allocate (expr, MDL)))
+			log_fatal ("can't allocate expression");
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		nexp = (struct expression *)0;
+		expression_reference (&nexp, *expr, MDL);
+		do {
+		    nexp -> op = expr_pick_first_value;
+		    if (!(parse_data_expression
+			  (&nexp -> data.pick_first_value.car,
+			   cfile, lose)))
+			goto nodata;
+
+		    token = next_token (&val, (unsigned *)0, cfile);
+		    if (token == COMMA) {
+			struct expression *foo = (struct expression *)0;
+			if (!expression_allocate (&foo, MDL))
+			    log_fatal ("can't allocate expr");
+			expression_reference
+				(&nexp -> data.pick_first_value.cdr, foo, MDL);
+			expression_dereference (&nexp, MDL);
+			expression_reference (&nexp, foo, MDL);
+			expression_dereference (&foo, MDL);
+		    }
+		} while (token == COMMA);
+		expression_dereference (&nexp, MDL);
+
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+		/* dns-update and dns-delete are present for historical
+		   purposes, but are deprecated in favor of ns-update
+		   in combination with update, delete, exists and not
+		   exists. */
+	      case DNS_UPDATE:
+	      case DNS_DELETE:
+#if !defined (NSUPDATE)
+		parse_warn (cfile,
+			    "Please rebuild dhcpd with --with-nsupdate.");
+#endif
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token == DNS_UPDATE)
+			opcode = expr_ns_add;
+		else
+			opcode = expr_ns_delete;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != STRING) {
+			parse_warn (cfile,
+				    "parse_expression: expecting string.");
+		      badnsupdate:
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+			
+		if (!strcasecmp (val, "a"))
+			u = T_A;
+		else if (!strcasecmp (val, "ptr"))
+			u = T_PTR;
+		else if (!strcasecmp (val, "mx"))
+			u = T_MX;
+		else if (!strcasecmp (val, "cname"))
+			u = T_CNAME;
+		else if (!strcasecmp (val, "TXT"))
+			u = T_TXT;
+		else {
+			parse_warn (cfile, "unexpected rrtype: %s", val);
+			goto badnsupdate;
+		}
+
+		s = (opcode == expr_ns_add
+		     ? "old-dns-update"
+		     : "old-dns-delete");
+		cptr = dmalloc (strlen (s) + 1, MDL);
+		if (!cptr)
+			log_fatal ("can't allocate name for %s", s);
+		strcpy (cptr, s);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_funcall;
+		(*expr) -> data.funcall.name = cptr;
+
+		/* Fake up a function call. */
+		ep = &(*expr) -> data.funcall.arglist;
+		if (!expression_allocate (ep, MDL))
+			log_fatal ("can't allocate expression");
+		(*ep) -> op = expr_arg;
+		if (!make_const_int (&(*ep) -> data.arg.val, u))
+			log_fatal ("can't allocate rrtype value.");
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+		ep = &((*ep) -> data.arg.next);
+		if (!expression_allocate (ep, MDL))
+			log_fatal ("can't allocate expression");
+		(*ep) -> op = expr_arg;
+		if (!(parse_data_expression (&(*ep) -> data.arg.val,
+					     cfile, lose)))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		ep = &((*ep) -> data.arg.next);
+		if (!expression_allocate (ep, MDL))
+			log_fatal ("can't allocate expression");
+		(*ep) -> op = expr_arg;
+		if (!(parse_data_expression (&(*ep) -> data.arg.val,
+					     cfile, lose)))
+			goto nodata;
+
+		if (opcode == expr_ns_add) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != COMMA)
+				goto nocomma;
+			
+			ep = &((*ep) -> data.arg.next);
+			if (!expression_allocate (ep, MDL))
+				log_fatal ("can't allocate expression");
+			(*ep) -> op = expr_arg;
+			if (!(parse_numeric_expression (&(*ep) -> data.arg.val,
+							cfile, lose))) {
+				parse_warn (cfile,
+					    "expecting numeric expression.");
+				goto badnsupdate;
+			}
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case NS_UPDATE:
+#if !defined (NSUPDATE)
+		parse_warn (cfile,
+			    "Please rebuild dhcpd with --with-nsupdate.");
+#endif
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		nexp = *expr;
+		do {
+			nexp -> op = expr_dns_transaction;
+			if (!(parse_dns_expression
+			      (&nexp -> data.dns_transaction.car,
+			       cfile, lose)))
+			{
+				if (!*lose)
+					parse_warn
+						(cfile,
+						 "expecting dns expression.");
+			      badnstrans:
+				expression_dereference (expr, MDL);
+				*lose = 1;
+				return 0;
+			}
+
+			token = next_token (&val, (unsigned *)0, cfile);
+			
+			if (token == COMMA) {
+				if (!(expression_allocate
+				      (&nexp -> data.dns_transaction.cdr,
+				       MDL)))
+					log_fatal
+						("can't allocate expression");
+				nexp = nexp -> data.dns_transaction.cdr;
+			}
+		} while (token == COMMA);
+
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+		/* NOT EXISTS is special cased above... */
+	      not_exists:
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token != EXISTS) {
+			parse_warn (cfile, "expecting DNS prerequisite.");
+			*lose = 1;
+			return 0;
+		}
+		opcode = expr_ns_not_exists;
+		goto nsupdatecode;
+	      case TOKEN_ADD:
+		opcode = expr_ns_add;
+		goto nsupdatecode;
+	      case TOKEN_DELETE:
+		opcode = expr_ns_delete;
+		goto nsupdatecode;
+	      ns_exists:
+		opcode = expr_ns_exists;
+	      nsupdatecode:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+#if !defined (NSUPDATE)
+		parse_warn (cfile,
+			    "Please rebuild dhcpd with --with-nsupdate.");
+#endif
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = opcode;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token) && token != NUMBER) {
+			parse_warn (cfile, "expecting identifier or number.");
+		      badnsop:
+			expression_dereference (expr, MDL);
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+			
+		if (token == NUMBER)
+			(*expr) -> data.ns_add.rrclass = atoi (val);
+		else if (!strcasecmp (val, "in"))
+			(*expr) -> data.ns_add.rrclass = C_IN;
+		else if (!strcasecmp (val, "chaos"))
+			(*expr) -> data.ns_add.rrclass = C_CHAOS;
+		else if (!strcasecmp (val, "hs"))
+			(*expr) -> data.ns_add.rrclass = C_HS;
+		else {
+			parse_warn (cfile, "unexpected rrclass: %s", val);
+			goto badnsop;
+		}
+		
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token) && token != NUMBER) {
+			parse_warn (cfile, "expecting identifier or number.");
+			goto badnsop;
+		}
+			
+		if (token == NUMBER)
+			(*expr) -> data.ns_add.rrtype = atoi (val);
+		else if (!strcasecmp (val, "a"))
+			(*expr) -> data.ns_add.rrtype = T_A;
+		else if (!strcasecmp (val, "ptr"))
+			(*expr) -> data.ns_add.rrtype = T_PTR;
+		else if (!strcasecmp (val, "mx"))
+			(*expr) -> data.ns_add.rrtype = T_MX;
+		else if (!strcasecmp (val, "cname"))
+			(*expr) -> data.ns_add.rrtype = T_CNAME;
+		else if (!strcasecmp (val, "TXT"))
+			(*expr) -> data.ns_add.rrtype = T_TXT;
+		else {
+			parse_warn (cfile, "unexpected rrtype: %s", val);
+			goto badnsop;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!(parse_data_expression
+		      (&(*expr) -> data.ns_add.rrname, cfile, lose)))
+			goto nodata;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!(parse_data_expression
+		      (&(*expr) -> data.ns_add.rrdata, cfile, lose)))
+			goto nodata;
+
+		if (opcode == expr_ns_add) {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != COMMA)
+				goto nocomma;
+			
+			if (!(parse_numeric_expression
+			      (&(*expr) -> data.ns_add.ttl, cfile,
+			       lose))) {
+			    if (!*lose)
+				parse_warn (cfile,
+					    "expecting numeric expression.");
+			    goto badnsupdate;
+			}
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+	      case OPTION:
+	      case CONFIG_OPTION:
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = (token == OPTION
+				 ? expr_option
+				 : expr_config_option);
+		token = next_token (&val, (unsigned *)0, cfile);
+		known = 0;
+		/* Pass reference directly to expression structure. */
+		status = parse_option_name(cfile, 0, &known,
+					   &(*expr)->data.option);
+		if (status != ISC_R_SUCCESS ||
+		    (*expr)->data.option == NULL) {
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+
+	      case HARDWARE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_hardware;
+		break;
+
+	      case LEASED_ADDRESS:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_leased_address;
+		break;
+
+	      case CLIENT_STATE:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_client_state;
+		break;
+
+	      case FILENAME:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_filename;
+		break;
+
+	      case SERVER_NAME:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_sname;
+		break;
+
+	      case LEASE_TIME:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_lease_time;
+		break;
+
+	      case TOKEN_NULL:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_null;
+		break;
+
+	      case HOST_DECL_NAME:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_host_decl_name;
+		break;
+
+	      case UPDATED_DNS_RR:
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != STRING) {
+			parse_warn (cfile, "expecting string.");
+		      bad_rrtype:
+			*lose = 1;
+			return 0;
+		}
+		if (!strcasecmp (val, "a"))
+			s = "ddns-fwd-name";
+		else if (!strcasecmp (val, "ptr"))
+			s = "ddns-rev-name";
+		else {
+			parse_warn (cfile, "invalid DNS rrtype: %s", val);
+			goto bad_rrtype;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_variable_reference;
+		(*expr) -> data.variable =
+			dmalloc (strlen (s) + 1, MDL);
+		if (!(*expr) -> data.variable)
+			log_fatal ("can't allocate variable name.");
+		strcpy ((*expr) -> data.variable, s);
+		break;
+
+	      case PACKET:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_packet;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		if (!parse_numeric_expression (&(*expr) -> data.packet.offset,
+					       cfile, lose))
+			goto nonum;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA)
+			goto nocomma;
+
+		if (!parse_numeric_expression (&(*expr) -> data.packet.len,
+					       cfile, lose))
+			goto nonum;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+		
+	      case STRING:
+		token = next_token (&val, &len, cfile);
+		if (!make_const_data (expr, (const unsigned char *)val,
+				      len, 1, 1, MDL))
+			log_fatal ("can't make constant string expression.");
+		break;
+
+	      case EXTRACT_INT:
+		token = next_token (&val, (unsigned *)0, cfile);	
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN) {
+			parse_warn (cfile, "left parenthesis expected.");
+			*lose = 1;
+			return 0;
+		}
+
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+
+		if (!parse_data_expression (&(*expr) -> data.extract_int,
+					    cfile, lose)) {
+			if (!*lose) {
+				parse_warn (cfile,
+					    "expecting data expression.");
+				skip_to_semi (cfile);
+				*lose = 1;
+			}
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA) {
+			parse_warn (cfile, "comma expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NUMBER) {
+			parse_warn (cfile, "number expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		switch (atoi (val)) {
+		      case 8:
+			(*expr) -> op = expr_extract_int8;
+			break;
+
+		      case 16:
+			(*expr) -> op = expr_extract_int16;
+			break;
+
+		      case 32:
+			(*expr) -> op = expr_extract_int32;
+			break;
+
+		      default:
+			parse_warn (cfile,
+				    "unsupported integer size %d", atoi (val));
+			*lose = 1;
+			skip_to_semi (cfile);
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+			parse_warn (cfile, "right parenthesis expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+	
+	      case ENCODE_INT:
+		token = next_token (&val, (unsigned *)0, cfile);	
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN) {
+			parse_warn (cfile, "left parenthesis expected.");
+			*lose = 1;
+			return 0;
+		}
+
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+
+		if (!parse_numeric_expression (&(*expr) -> data.encode_int,
+					       cfile, lose)) {
+			parse_warn (cfile, "expecting numeric expression.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != COMMA) {
+			parse_warn (cfile, "comma expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NUMBER) {
+			parse_warn (cfile, "number expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		switch (atoi (val)) {
+		      case 8:
+			(*expr) -> op = expr_encode_int8;
+			break;
+
+		      case 16:
+			(*expr) -> op = expr_encode_int16;
+			break;
+
+		      case 32:
+			(*expr) -> op = expr_encode_int32;
+			break;
+
+		      default:
+			parse_warn (cfile,
+				    "unsupported integer size %d", atoi (val));
+			*lose = 1;
+			skip_to_semi (cfile);
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN) {
+			parse_warn (cfile, "right parenthesis expected.");
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+	
+	      case NUMBER:
+		/* If we're in a numeric context, this should just be a
+		   number, by itself. */
+		if (context == context_numeric ||
+		    context == context_data_or_numeric) {
+			next_token (&val, (unsigned *)0, cfile);
+			if (!expression_allocate (expr, MDL))
+				log_fatal ("can't allocate expression");
+			(*expr) -> op = expr_const_int;
+			(*expr) -> data.const_int = atoi (val);
+			break;
+		}
+
+	      case NUMBER_OR_NAME:
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+
+		(*expr) -> op = expr_const_data;
+		if (!parse_cshl (&(*expr) -> data.const_data, cfile)) {
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+
+	      case NS_FORMERR:
+		known = FORMERR;
+		goto ns_const;
+	      ns_const:
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_const_int;
+		(*expr) -> data.const_int = known;
+		break;
+		
+	      case NS_NOERROR:
+		known = ISC_R_SUCCESS;
+		goto ns_const;
+
+	      case NS_NOTAUTH:
+		known = ISC_R_NOTAUTH;
+		goto ns_const;
+
+	      case NS_NOTIMP:
+		known = ISC_R_NOTIMPLEMENTED;
+		goto ns_const;
+
+	      case NS_NOTZONE:
+		known = ISC_R_NOTZONE;
+		goto ns_const;
+
+	      case NS_NXDOMAIN:
+		known = ISC_R_NXDOMAIN;
+		goto ns_const;
+
+	      case NS_NXRRSET:
+		known = ISC_R_NXRRSET;
+		goto ns_const;
+
+	      case NS_REFUSED:
+		known = ISC_R_REFUSED;
+		goto ns_const;
+
+	      case NS_SERVFAIL:
+		known = ISC_R_SERVFAIL;
+		goto ns_const;
+
+	      case NS_YXDOMAIN:
+		known = ISC_R_YXDOMAIN;
+		goto ns_const;
+
+	      case NS_YXRRSET:
+		known = ISC_R_YXRRSET;
+		goto ns_const;
+
+	      case BOOTING:
+		known = S_INIT;
+		goto ns_const;
+
+	      case REBOOT:
+		known = S_REBOOTING;
+		goto ns_const;
+
+	      case SELECT:
+		known = S_SELECTING;
+		goto ns_const;
+
+	      case REQUEST:
+		known = S_REQUESTING;
+		goto ns_const;
+
+	      case BOUND:
+		known = S_BOUND;
+		goto ns_const;
+
+	      case RENEW:
+		known = S_RENEWING;
+		goto ns_const;
+
+	      case REBIND:
+		known = S_REBINDING;
+		goto ns_const;
+
+	      case DEFINED:
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN)
+			goto nolparen;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != NAME && token != NUMBER_OR_NAME) {
+			parse_warn (cfile, "%s can't be a variable name", val);
+			skip_to_semi (cfile);
+			*lose = 1;
+			return 0;
+		}
+
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_variable_exists;
+		(*expr) -> data.variable = dmalloc (strlen (val) + 1, MDL);
+		if (!(*expr)->data.variable)
+			log_fatal ("can't allocate variable name");
+		strcpy ((*expr) -> data.variable, val);
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != RPAREN)
+			goto norparen;
+		break;
+
+		/* Not a valid start to an expression... */
+	      default:
+		if (token != NAME && token != NUMBER_OR_NAME)
+			return 0;
+
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		/* Save the name of the variable being referenced. */
+		cptr = dmalloc (strlen (val) + 1, MDL);
+		if (!cptr)
+			log_fatal ("can't allocate variable name");
+		strcpy (cptr, val);
+
+		/* Simple variable reference, as far as we can tell. */
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token != LPAREN) {
+			if (!expression_allocate (expr, MDL))
+				log_fatal ("can't allocate expression");
+			(*expr) -> op = expr_variable_reference;
+			(*expr) -> data.variable = cptr;
+			break;
+		}
+
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("can't allocate expression");
+		(*expr) -> op = expr_funcall;
+		(*expr) -> data.funcall.name = cptr;
+
+		/* Now parse the argument list. */
+		ep = &(*expr) -> data.funcall.arglist;
+		do {
+			if (!expression_allocate (ep, MDL))
+				log_fatal ("can't allocate expression");
+			(*ep) -> op = expr_arg;
+			if (!parse_expression (&(*ep) -> data.arg.val,
+					       cfile, lose, context_any,
+					       (struct expression **)0,
+					       expr_none)) {
+				if (!*lose) {
+					parse_warn (cfile,
+						    "expecting expression.");
+					*lose = 1;
+				}
+				skip_to_semi (cfile);
+				expression_dereference (expr, MDL);
+				return 0;
+			}
+			ep = &((*ep) -> data.arg.next);
+			token = next_token (&val, (unsigned *)0, cfile);
+		} while (token == COMMA);
+		if (token != RPAREN) {
+			parse_warn (cfile, "Right parenthesis expected.");
+			skip_to_semi (cfile);
+			*lose = 1;
+			expression_dereference (expr, MDL);
+			return 0;
+		}
+		break;
+	}
+	return 1;
+}
+
+/* Parse an expression. */
+
+int parse_expression (expr, cfile, lose, context, plhs, binop)
+	struct expression **expr;
+	struct parse *cfile;
+	int *lose;
+	enum expression_context context;
+	struct expression **plhs;
+	enum expr_op binop;
+{
+	enum dhcp_token token;
+	const char *val;
+	struct expression *rhs = (struct expression *)0, *tmp;
+	struct expression *lhs = (struct expression *)0;
+	enum expr_op next_op;
+	enum expression_context
+		lhs_context = context_any,
+		rhs_context = context_any;
+
+	/* Consume the left hand side we were passed. */
+	if (plhs) {
+		expression_reference (&lhs, *plhs, MDL);
+		expression_dereference (plhs, MDL);
+	}
+
+      new_rhs:
+	if (!parse_non_binary (&rhs, cfile, lose, context)) {
+		/* If we already have a left-hand side, then it's not
+		   okay for there not to be a right-hand side here, so
+		   we need to flag it as an error. */
+		if (lhs) {
+			if (!*lose) {
+				parse_warn (cfile,
+					    "expecting right-hand side.");
+				*lose = 1;
+				skip_to_semi (cfile);
+			}
+			expression_dereference (&lhs, MDL);
+		}
+		return 0;
+	}
+
+	/* At this point, rhs contains either an entire subexpression,
+	   or at least a left-hand-side.   If we do not see a binary token
+	   as the next token, we're done with the expression. */
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	switch (token) {
+	      case BANG:
+		token = next_token (&val, (unsigned *)0, cfile);
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token != EQUAL) {
+			parse_warn (cfile, "! in boolean context without =");
+			*lose = 1;
+			skip_to_semi (cfile);
+			if (lhs)
+				expression_dereference (&lhs, MDL);
+			return 0;
+		}
+		next_op = expr_not_equal;
+		context = expression_context (rhs);
+		break;
+
+	      case EQUAL:
+		next_op = expr_equal;
+		context = expression_context (rhs);
+		break;
+
+	      case AND:
+		next_op = expr_and;
+		context = expression_context (rhs);
+		break;
+
+	      case OR:
+		next_op = expr_or;
+		context = expression_context (rhs);
+		break;
+
+	      case PLUS:
+		next_op = expr_add;
+		context = expression_context (rhs);
+		break;
+
+	      case MINUS:
+		next_op = expr_subtract;
+		context = expression_context (rhs);
+		break;
+
+	      case SLASH:
+		next_op = expr_divide;
+		context = expression_context (rhs);
+		break;
+
+	      case ASTERISK:
+		next_op = expr_multiply;
+		context = expression_context (rhs);
+		break;
+
+	      case PERCENT:
+		next_op = expr_remainder;
+		context = expression_context (rhs);
+		break;
+
+	      case AMPERSAND:
+		next_op = expr_binary_and;
+		context = expression_context (rhs);
+		break;
+
+	      case PIPE:
+		next_op = expr_binary_or;
+		context = expression_context (rhs);
+		break;
+
+	      case CARET:
+		next_op = expr_binary_xor;
+		context = expression_context (rhs);
+		break;
+
+	      default:
+		next_op = expr_none;
+	}
+
+	/* If we have no lhs yet, we just parsed it. */
+	if (!lhs) {
+		/* If there was no operator following what we just parsed,
+		   then we're done - return it. */
+		if (next_op == expr_none) {
+			*expr = rhs;
+			return 1;
+		}
+		lhs = rhs;
+		rhs = (struct expression *)0;
+		binop = next_op;
+		next_token (&val, (unsigned *)0, cfile);
+		goto new_rhs;
+	}
+
+	/* If the next binary operator is of greater precedence than the
+	 * current operator, then rhs we have parsed so far is actually
+	 * the lhs of the next operator.  To get this value, we have to
+	 * recurse.
+	 */
+	if (binop != expr_none && next_op != expr_none &&
+	    op_precedence (binop, next_op) < 0) {
+
+		/* Eat the subexpression operator token, which we pass to
+		 * parse_expression...we only peek()'d earlier.
+		 */
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		/* Continue parsing of the right hand side with that token. */
+		tmp = rhs;
+		rhs = (struct expression *)0;
+		if (!parse_expression (&rhs, cfile, lose, op_context (next_op),
+				       &tmp, next_op)) {
+			if (!*lose) {
+				parse_warn (cfile,
+					    "expecting a subexpression");
+				*lose = 1;
+			}
+			return 0;
+		}
+		next_op = expr_none;
+	}
+
+	if (binop != expr_none) {
+	  rhs_context = expression_context(rhs);
+	  lhs_context = expression_context(lhs);
+
+	  if ((rhs_context != context_any) && (lhs_context != context_any) &&
+			(rhs_context != lhs_context)) {
+	    parse_warn (cfile, "illegal expression relating different types");
+	    skip_to_semi (cfile);
+	    expression_dereference (&rhs, MDL);
+	    expression_dereference (&lhs, MDL);
+	    *lose = 1;
+	    return 0;
+	  }
+
+	  switch(binop) {
+	    case expr_not_equal:
+	    case expr_equal:
+		if ((rhs_context != context_data_or_numeric) &&
+		    (rhs_context != context_data) &&
+		    (rhs_context != context_numeric) &&
+		    (rhs_context != context_any)) {
+			parse_warn (cfile, "expecting data/numeric expression");
+			skip_to_semi (cfile);
+			expression_dereference (&rhs, MDL);
+			*lose = 1;
+			return 0;
+		}
+		break;
+
+	    case expr_and:
+	    case expr_or:
+		if ((rhs_context != context_boolean) &&
+		    (rhs_context != context_any)) {
+			parse_warn (cfile, "expecting boolean expressions");
+			skip_to_semi (cfile);
+			expression_dereference (&rhs, MDL);
+			*lose = 1;
+			return 0;
+		}
+		break;
+
+	    case expr_add:
+	    case expr_subtract:
+	    case expr_divide:
+	    case expr_multiply:
+	    case expr_remainder:
+	    case expr_binary_and:
+	    case expr_binary_or:
+	    case expr_binary_xor:
+		if ((rhs_context != context_numeric) &&
+		    (rhs_context != context_any)) {
+			parse_warn (cfile, "expecting numeric expressions");
+                        skip_to_semi (cfile);
+                        expression_dereference (&rhs, MDL);
+                        *lose = 1;
+                        return 0;
+		}
+		break;
+
+	    default:
+		break;
+	  }
+	}
+
+	/* Now, if we didn't find a binary operator, we're done parsing
+	   this subexpression, so combine it with the preceding binary
+	   operator and return the result. */
+	if (next_op == expr_none) {
+		if (!expression_allocate (expr, MDL))
+			log_fatal ("Can't allocate expression!");
+
+		(*expr) -> op = binop;
+		/* All the binary operators' data union members
+		   are the same, so we'll cheat and use the member
+		   for the equals operator. */
+		(*expr) -> data.equal [0] = lhs;
+		(*expr) -> data.equal [1] = rhs;
+		return 1;
+	}
+
+	/* Eat the operator token - we now know it was a binary operator... */
+	token = next_token (&val, (unsigned *)0, cfile);
+
+	/* Now combine the LHS and the RHS using binop. */
+	tmp = (struct expression *)0;
+	if (!expression_allocate (&tmp, MDL))
+		log_fatal ("No memory for equal precedence combination.");
+	
+	/* Store the LHS and RHS. */
+	tmp -> data.equal [0] = lhs;
+	tmp -> data.equal [1] = rhs;
+	tmp -> op = binop;
+	
+	lhs = tmp;
+	tmp = (struct expression *)0;
+	rhs = (struct expression *)0;
+
+	/* Recursions don't return until we have parsed the end of the
+	   expression, so if we recursed earlier, we can now return what
+	   we got. */
+	if (next_op == expr_none) {
+		*expr = lhs;
+		return 1;
+	}
+
+	binop = next_op;
+	goto new_rhs;
+}	
+
+/* option-statement :== identifier DOT identifier <syntax> SEMI
+		      | identifier <syntax> SEMI
+
+   Option syntax is handled specially through format strings, so it
+   would be painful to come up with BNF for it.   However, it always
+   starts as above and ends in a SEMI. */
+
+int parse_option_statement (result, cfile, lookups, option, op)
+	struct executable_statement **result;
+	struct parse *cfile;
+	int lookups;
+	struct option *option;
+	enum statement_op op;
+{
+	const char *val;
+	enum dhcp_token token;
+	const char *fmt = NULL;
+	struct expression *expr = (struct expression *)0;
+	struct expression *tmp;
+	int lose;
+	struct executable_statement *stmt;
+	int ftt = 1;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == SEMI) {
+		/* Eat the semicolon... */
+		token = next_token (&val, (unsigned *)0, cfile);
+		goto done;
+	}
+
+	if (token == EQUAL) {
+		/* Eat the equals sign. */
+		token = next_token (&val, (unsigned *)0, cfile);
+
+		/* Parse a data expression and use its value for the data. */
+		if (!parse_data_expression (&expr, cfile, &lose)) {
+			/* In this context, we must have an executable
+			   statement, so if we found something else, it's
+			   still an error. */
+			if (!lose) {
+				parse_warn (cfile,
+					    "expecting a data expression.");
+				skip_to_semi (cfile);
+			}
+			return 0;
+		}
+
+		/* We got a valid expression, so use it. */
+		goto done;
+	}
+
+	/* Parse the option data... */
+	do {
+		/* Set a flag if this is an array of a simple type (i.e.,
+		   not an array of pairs of IP addresses, or something
+		   like that. */
+		int uniform = option -> format [1] == 'A';
+
+	      and_again:
+		/* Set fmt to start of format for 'A' and one char back
+		 * for 'a'.
+		 */
+		if ((fmt != NULL) && (fmt != option->format) && (*fmt == 'a'))
+			fmt -= 1;
+		else if ((fmt == NULL) || (*fmt == 'A'))
+			fmt = option->format;
+
+		/* 'a' means always uniform */
+		uniform |= (fmt [1] == 'a');
+
+		for ( ; *fmt; fmt++) {
+			if ((*fmt == 'A') || (*fmt == 'a'))
+				break;
+			if (*fmt == 'o')
+				continue;
+			tmp = expr;
+			expr = (struct expression *)0;
+			if (!parse_option_token (&expr, cfile, &fmt,
+						 tmp, uniform, lookups)) {
+				if (fmt [1] != 'o') {
+					if (tmp)
+						expression_dereference (&tmp,
+									MDL);
+					return 0;
+				}
+				expr = tmp;
+				tmp = (struct expression *)0;
+			}
+			if (tmp)
+				expression_dereference (&tmp, MDL);
+		}
+		if ((*fmt == 'A') || (*fmt == 'a')) {
+			token = peek_token (&val, (unsigned *)0, cfile);
+			/* Comma means: continue with next element in array */
+			if (token == COMMA) {
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				continue;
+			}
+			/* no comma: end of array.
+			   'A' or end of string means: leave the loop */
+			if ((*fmt == 'A') || (fmt[1] == '\0'))
+				break;
+			/* 'a' means: go on with next char */
+			if (*fmt == 'a') {
+				fmt++;
+				goto and_again;
+			}
+		}
+	} while ((*fmt == 'A') || (*fmt == 'a'));
+
+      done:
+	if (!parse_semi (cfile))
+		return 0;
+	if (!executable_statement_allocate (result, MDL))
+		log_fatal ("no memory for option statement.");
+	(*result) -> op = op;
+	if (expr && !option_cache (&(*result) -> data.option,
+				   (struct data_string *)0, expr, option, MDL))
+		log_fatal ("no memory for option cache");
+	if (expr)
+		expression_dereference (&expr, MDL);
+	return 1;
+}
+
+int parse_option_token (rv, cfile, fmt, expr, uniform, lookups)
+	struct expression **rv;
+	struct parse *cfile;
+	const char **fmt;
+	struct expression *expr;
+	int uniform;
+	int lookups;
+{
+	const char *val;
+	enum dhcp_token token;
+	struct expression *t = NULL;
+	unsigned char buf [4];
+	unsigned len;
+	unsigned char *ob;
+	struct iaddr addr;
+	int num;
+	const char *f, *g;
+	struct enumeration_value *e;
+
+	switch (**fmt) {
+	      case 'U':
+		token = next_token (&val, &len, cfile);
+		if (!is_identifier (token)) {
+			if ((*fmt) [1] != 'o') {
+				parse_warn (cfile, "expecting identifier.");
+				if (token != SEMI)
+					skip_to_semi (cfile);
+			}
+			return 0;
+		}
+		if (!make_const_data (&t, (const unsigned char *)val,
+				      len, 1, 1, MDL))
+			log_fatal ("No memory for %s", val);
+		break;
+
+	      case 'E':
+		g = strchr (*fmt, '.');
+		if (!g) {
+			parse_warn (cfile,
+				    "malformed encapsulation format (bug!)");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		*fmt = g;
+	      case 'X':
+		token = peek_token (&val, (unsigned *)0, cfile);
+		if (token == NUMBER_OR_NAME || token == NUMBER) {
+			if (!expression_allocate (&t, MDL))
+				return 0;
+			if (!parse_cshl (&t -> data.const_data, cfile)) {
+				expression_dereference (&t, MDL);
+				return 0;
+			}
+			t -> op = expr_const_data;
+		} else {
+			token = next_token (&val, &len, cfile);
+
+			if(token == STRING) {
+				if (!make_const_data (&t,
+						(const unsigned char *)val,
+							len, 1, 1, MDL))
+					log_fatal ("No memory for \"%s\"", val);
+			} else {
+				if ((*fmt) [1] != 'o') {
+					parse_warn(cfile, "expecting string "
+						   "or hexadecimal data");
+					skip_to_semi (cfile);
+				}
+				return 0;
+			}
+		}
+		break;
+
+              case 'D': /* Domain list... */
+		t = parse_domain_list(cfile);
+
+		if (!t) {
+			if ((*fmt)[1] != 'o')
+				skip_to_semi(cfile);
+			return 0;
+		}
+
+		break;
+
+	      case 'd': /* Domain name... */
+		val = parse_host_name (cfile);
+		if (!val) {
+			parse_warn (cfile, "not a valid domain name.");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		len = strlen (val);
+		goto make_string;
+
+	      case 't': /* Text string... */
+		token = next_token (&val, &len, cfile);
+		if (token != STRING && !is_identifier (token)) {
+			if ((*fmt) [1] != 'o') {
+				parse_warn (cfile, "expecting string.");
+				if (token != SEMI)
+					skip_to_semi (cfile);
+			}
+			return 0;
+		}
+	      make_string:
+		if (!make_const_data (&t, (const unsigned char *)val,
+				      len, 1, 1, MDL))
+			log_fatal ("No memory for concatenation");
+		break;
+		
+	      case 'N':
+		f = (*fmt) + 1;
+		g = strchr (*fmt, '.');
+		if (!g) {
+			parse_warn (cfile, "malformed %s (bug!)",
+				    "enumeration format");
+		      foo:
+			skip_to_semi (cfile);
+			return 0;
+		}
+		*fmt = g;
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token)) {
+			parse_warn (cfile,
+				    "identifier expected");
+			goto foo;
+		}
+		e = find_enumeration_value (f, (*fmt) - f, val);
+		if (!e) {
+			parse_warn (cfile, "unknown value");
+			goto foo;
+		}
+		if (!make_const_data (&t, &e -> value, 1, 0, 1, MDL))
+			return 0;
+		break;
+
+	      case 'I': /* IP address or hostname. */
+		if (lookups) {
+			if (!parse_ip_addr_or_hostname (&t, cfile, uniform))
+				return 0;
+		} else {
+			if (!parse_ip_addr (cfile, &addr))
+				return 0;
+			if (!make_const_data (&t, addr.iabuf, addr.len,
+					      0, 1, MDL))
+				return 0;
+		}
+		break;
+		
+	      case 'T':	/* Lease interval. */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (token != INFINITE)
+			goto check_number;
+		putLong (buf, -1);
+		if (!make_const_data (&t, buf, 4, 0, 1, MDL))
+			return 0;
+		break;
+
+	      case 'L': /* Unsigned 32-bit integer... */
+	      case 'l':	/* Signed 32-bit integer... */
+		token = next_token (&val, (unsigned *)0, cfile);
+	      check_number:
+		if ((token != NUMBER) && (token != NUMBER_OR_NAME)) {
+		      need_number:
+			if ((*fmt) [1] != 'o') {
+				parse_warn (cfile, "expecting number.");
+				if (token != SEMI)
+					skip_to_semi (cfile);
+			}
+			return 0;
+		}
+		convert_num (cfile, buf, val, 0, 32);
+		if (!make_const_data (&t, buf, 4, 0, 1, MDL))
+			return 0;
+		break;
+
+	      case 's':	/* Signed 16-bit integer. */
+	      case 'S':	/* Unsigned 16-bit integer. */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if ((token != NUMBER) && (token != NUMBER_OR_NAME))
+			goto need_number;
+		convert_num (cfile, buf, val, 0, 16);
+		if (!make_const_data (&t, buf, 2, 0, 1, MDL))
+			return 0;
+		break;
+
+	      case 'b':	/* Signed 8-bit integer. */
+	      case 'B':	/* Unsigned 8-bit integer. */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if ((token != NUMBER) && (token != NUMBER_OR_NAME))
+			goto need_number;
+		convert_num (cfile, buf, val, 0, 8);
+		if (!make_const_data (&t, buf, 1, 0, 1, MDL))
+			return 0;
+		break;
+
+	      case 'f': /* Boolean flag. */
+		token = next_token (&val, (unsigned *)0, cfile);
+		if (!is_identifier (token)) {
+			if ((*fmt) [1] != 'o')
+				parse_warn (cfile, "expecting identifier.");
+		      bad_flag:
+			if ((*fmt) [1] != 'o') {
+				if (token != SEMI)
+					skip_to_semi (cfile);
+			}
+			return 0;
+		}
+		if (!strcasecmp (val, "true")
+		    || !strcasecmp (val, "on"))
+			buf [0] = 1;
+		else if (!strcasecmp (val, "false")
+			 || !strcasecmp (val, "off"))
+			buf [0] = 0;
+		else if (!strcasecmp (val, "ignore"))
+			buf [0] = 2;
+		else {
+			if ((*fmt) [1] != 'o')
+				parse_warn (cfile, "expecting boolean.");
+			goto bad_flag;
+		}
+		if (!make_const_data (&t, buf, 1, 0, 1, MDL))
+			return 0;
+		break;
+
+	      default:
+		parse_warn (cfile, "Bad format %c in parse_option_token.",
+			    **fmt);
+		skip_to_semi (cfile);
+		return 0;
+	}
+
+	if (!make_concat (rv, expr, t))
+		return 0;
+
+	if (t != NULL)
+		expression_dereference (&t, MDL);
+
+	return 1;
+}
+
+int parse_option_decl (oc, cfile)
+	struct option_cache **oc;
+	struct parse *cfile;
+{
+	const char *val;
+	int token;
+	u_int8_t buf [4];
+	u_int8_t hunkbuf [1024];
+	unsigned hunkix = 0;
+	const char *fmt, *f;
+	struct option *option=NULL;
+	struct iaddr ip_addr;
+	u_int8_t *dp;
+	const u_int8_t *cdp;
+	unsigned len;
+	int nul_term = 0;
+	struct buffer *bp;
+	int known = 0;
+	struct expression *express = NULL;
+	struct enumeration_value *e;
+	isc_result_t status;
+
+	status = parse_option_name (cfile, 0, &known, &option);
+	if (status != ISC_R_SUCCESS || option == NULL)
+		return 0;
+
+	/* Parse the option data... */
+	do {
+		/* Set a flag if this is an array of a simple type (i.e.,
+		   not an array of pairs of IP addresses, or something
+		   like that. */
+		int uniform = option -> format [1] == 'A';
+
+		for (fmt = option -> format; *fmt; fmt++) {
+			if (*fmt == 'A')
+				break;
+			switch (*fmt) {
+			      case 'E':
+				fmt = strchr (fmt, '.');
+				if (!fmt) {
+					parse_warn (cfile,
+						    "malformed %s (bug!)",
+						    "encapsulation format");
+					goto parse_exit;
+				}
+			      case 'X':
+				len = parse_X (cfile, &hunkbuf [hunkix],
+					       sizeof hunkbuf - hunkix);
+				hunkix += len;
+				break;
+					
+			      case 't': /* Text string... */
+				token = next_token (&val,
+						    &len, cfile);
+				if (token != STRING) {
+					parse_warn (cfile,
+						    "expecting string.");
+					goto parse_exit;
+				}
+				if (hunkix + len + 1 > sizeof hunkbuf) {
+					parse_warn (cfile,
+						    "option data buffer %s",
+						    "overflow");
+					goto parse_exit;
+				}
+				memcpy (&hunkbuf [hunkix], val, len + 1);
+				nul_term = 1;
+				hunkix += len;
+				break;
+
+			      case 'D':
+				express = parse_domain_list(cfile);
+
+				if (express == NULL)
+					goto exit;
+
+				if (express->op != expr_const_data) {
+					parse_warn(cfile, "unexpected "
+							  "expression");
+					goto parse_exit;
+				}
+
+				len = express->data.const_data.len;
+				cdp = express->data.const_data.data;
+
+				if ((hunkix + len) > sizeof(hunkbuf)) {
+					parse_warn(cfile, "option data buffer "
+							  "overflow");
+					goto parse_exit;
+				}
+				memcpy(&hunkbuf[hunkix], cdp, len);
+				hunkix += len;
+
+				expression_dereference(&express, MDL);
+				break;
+
+			      case 'N':
+				f = fmt;
+				fmt = strchr (fmt, '.');
+				if (!fmt) {
+					parse_warn (cfile,
+						    "malformed %s (bug!)",
+						    "enumeration format");
+					goto parse_exit;
+				}
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if (!is_identifier (token)) {
+					parse_warn (cfile,
+						    "identifier expected");
+					goto parse_exit;
+				}
+				e = find_enumeration_value (f, fmt - f, val);
+				if (!e) {
+					parse_warn (cfile,
+						    "unknown value");
+					goto parse_exit;
+				}
+				len = 1;
+				dp = &e -> value;
+				goto alloc;
+
+			      case 'I': /* IP address. */
+				if (!parse_ip_addr (cfile, &ip_addr))
+					goto exit;
+				len = ip_addr.len;
+				dp = ip_addr.iabuf;
+
+			      alloc:
+				if (hunkix + len > sizeof hunkbuf) {
+					parse_warn (cfile,
+						    "option data buffer %s",
+						    "overflow");
+					goto parse_exit;
+				}
+				memcpy (&hunkbuf [hunkix], dp, len);
+				hunkix += len;
+				break;
+
+			      case 'L': /* Unsigned 32-bit integer... */
+			      case 'l':	/* Signed 32-bit integer... */
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if ((token != NUMBER) &&
+				    (token != NUMBER_OR_NAME)) {
+				      need_number:
+					parse_warn (cfile,
+						    "expecting number.");
+					if (token != SEMI)
+						goto parse_exit;
+					else
+						goto exit;
+				}
+				convert_num (cfile, buf, val, 0, 32);
+				len = 4;
+				dp = buf;
+				goto alloc;
+
+			      case 's':	/* Signed 16-bit integer. */
+			      case 'S':	/* Unsigned 16-bit integer. */
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if ((token != NUMBER) &&
+				    (token != NUMBER_OR_NAME))
+					goto need_number;
+				convert_num (cfile, buf, val, 0, 16);
+				len = 2;
+				dp = buf;
+				goto alloc;
+
+			      case 'b':	/* Signed 8-bit integer. */
+			      case 'B':	/* Unsigned 8-bit integer. */
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if ((token != NUMBER) &&
+				    (token != NUMBER_OR_NAME))
+					goto need_number;
+				convert_num (cfile, buf, val, 0, 8);
+				len = 1;
+				dp = buf;
+				goto alloc;
+
+			      case 'f': /* Boolean flag. */
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+				if (!is_identifier (token)) {
+					parse_warn (cfile,
+						    "expecting identifier.");
+				      bad_flag:
+					if (token != SEMI)
+						goto parse_exit;
+					else
+						goto exit;
+				}
+				if (!strcasecmp (val, "true")
+				    || !strcasecmp (val, "on"))
+					buf [0] = 1;
+				else if (!strcasecmp (val, "false")
+					 || !strcasecmp (val, "off"))
+					buf [0] = 0;
+				else {
+					parse_warn (cfile,
+						    "expecting boolean.");
+					goto bad_flag;
+				}
+				len = 1;
+				dp = buf;
+				goto alloc;
+
+			      default:
+				log_error ("parse_option_param: Bad format %c",
+				      *fmt);
+				goto parse_exit;
+			}
+		}
+		token = next_token (&val, (unsigned *)0, cfile);
+	} while (*fmt == 'A' && token == COMMA);
+
+	if (token != SEMI) {
+		parse_warn (cfile, "semicolon expected.");
+		goto parse_exit;
+	}
+
+	bp = (struct buffer *)0;
+	if (!buffer_allocate (&bp, hunkix + nul_term, MDL))
+		log_fatal ("no memory to store option declaration.");
+	if (!bp -> data)
+		log_fatal ("out of memory allocating option data.");
+	memcpy (bp -> data, hunkbuf, hunkix + nul_term);
+	
+	if (!option_cache_allocate (oc, MDL))
+		log_fatal ("out of memory allocating option cache.");
+
+	(*oc) -> data.buffer = bp;
+	(*oc) -> data.data = &bp -> data [0];
+	(*oc) -> data.terminated = nul_term;
+	(*oc) -> data.len = hunkix;
+	option_reference(&(*oc)->option, option, MDL);
+	option_dereference(&option, MDL);
+	return 1;
+
+parse_exit:
+	skip_to_semi (cfile);
+exit:
+	option_dereference(&option, MDL);
+
+	return 0;
+}
+
+/* Consider merging parse_cshl into this. */
+
+int parse_X (cfile, buf, max)
+	struct parse *cfile;
+	u_int8_t *buf;
+	unsigned max;
+{
+	int token;
+	const char *val;
+	unsigned len;
+	u_int8_t *s;
+
+	token = peek_token (&val, (unsigned *)0, cfile);
+	if (token == NUMBER_OR_NAME || token == NUMBER) {
+		len = 0;
+		do {
+			token = next_token (&val, (unsigned *)0, cfile);
+			if (token != NUMBER && token != NUMBER_OR_NAME) {
+				parse_warn (cfile,
+					    "expecting hexadecimal constant.");
+				skip_to_semi (cfile);
+				return 0;
+			}
+			convert_num (cfile, &buf [len], val, 16, 8);
+			if (len++ > max) {
+				parse_warn (cfile,
+					    "hexadecimal constant too long.");
+				skip_to_semi (cfile);
+				return 0;
+			}
+			token = peek_token (&val, (unsigned *)0, cfile);
+			if (token == COLON)
+				token = next_token (&val,
+						    (unsigned *)0, cfile);
+		} while (token == COLON);
+		val = (char *)buf;
+	} else if (token == STRING) {
+		token = next_token (&val, &len, cfile);
+		if (len + 1 > max) {
+			parse_warn (cfile, "string constant too long.");
+			skip_to_semi (cfile);
+			return 0;
+		}
+		memcpy (buf, val, len + 1);
+	} else {
+		parse_warn (cfile, "expecting string or hexadecimal data");
+		skip_to_semi (cfile);
+		return 0;
+	}
+	return len;
+}
+
+int parse_warn (struct parse *cfile, const char *fmt, ...)
+{
+	va_list list;
+	char lexbuf [256];
+	char mbuf [1024];
+	char fbuf [1024];
+	unsigned i, lix;
+	
+	do_percentm (mbuf, fmt);
+	/* %Audit% This is log output. %2004.06.17,Safe%
+	 * If we truncate we hope the user can get a hint from the log.
+	 */
+	snprintf (fbuf, sizeof fbuf, "%s line %d: %s",
+		  cfile -> tlname, cfile -> lexline, mbuf);
+	
+	va_start (list, fmt);
+	vsnprintf (mbuf, sizeof mbuf, fbuf, list);
+	va_end (list);
+
+	lix = 0;
+	for (i = 0;
+	     cfile -> token_line [i] && i < (cfile -> lexchar - 1); i++) {
+		if (lix < (sizeof lexbuf) - 1)
+			lexbuf [lix++] = ' ';
+		if (cfile -> token_line [i] == '\t') {
+			for (lix;
+			     lix < (sizeof lexbuf) - 1 && (lix & 7); lix++)
+				lexbuf [lix] = ' ';
+		}
+	}
+	lexbuf [lix] = 0;
+
+#ifndef DEBUG
+	syslog (log_priority | LOG_ERR, "%s", mbuf);
+	syslog (log_priority | LOG_ERR, "%s", cfile -> token_line);
+	if (cfile -> lexchar < 81)
+		syslog (log_priority | LOG_ERR, "%s^", lexbuf);
+#endif
+
+	if (log_perror) {
+		IGNORE_RET(write(STDERR_FILENO, mbuf, strlen (mbuf)));
+		IGNORE_RET(write(STDERR_FILENO, "\n", 1));
+		IGNORE_RET(write(STDERR_FILENO, cfile -> token_line,
+				  strlen (cfile -> token_line)));
+		IGNORE_RET(write(STDERR_FILENO, "\n", 1));
+		if (cfile -> lexchar < 81)
+			IGNORE_RET(write(STDERR_FILENO, lexbuf, lix));
+		IGNORE_RET(write(STDERR_FILENO, "^\n", 2));
+	}
+
+	cfile -> warnings_occurred = 1;
+
+	return 0;
+}
+
+struct expression *
+parse_domain_list (cfile)
+	struct parse *cfile;
+{
+	const char *val;
+	enum dhcp_token token = SEMI;
+	struct expression *t = NULL;
+	unsigned len, clen = 0;
+	int result;
+	unsigned char compbuf[256 * NS_MAXCDNAME];
+	const unsigned char *dnptrs[256], **lastdnptr;
+
+	memset(compbuf, 0, sizeof(compbuf));
+	memset(dnptrs, 0, sizeof(dnptrs));
+	dnptrs[0] = compbuf;
+	lastdnptr = &dnptrs[255];
+
+	do {
+		/* Consume the COMMA token if peeked. */
+		if (token == COMMA)
+			next_token(&val, NULL, cfile);
+
+		/* Get next (or first) value. */
+		token = next_token(&val, &len, cfile);
+
+		if (token != STRING) {
+			parse_warn(cfile, "Expecting a domain string.");
+			return NULL;
+		}
+
+		result = MRns_name_compress(val, compbuf + clen,
+					    sizeof(compbuf) - clen,
+					    dnptrs, lastdnptr);
+
+		if (result < 0) {
+			parse_warn(cfile, "Error compressing domain list: %m");
+			return NULL;
+		}
+
+		clen += result;
+
+		token = peek_token(&val, NULL, cfile);
+	} while (token == COMMA);
+
+	if (!make_const_data(&t, compbuf, clen, 1, 1, MDL))
+		log_fatal("No memory for domain list object.");
+
+	return t;
+}
+
diff -rupN dhcp-3.1-ESV-R3_orig/common/parse.c.rej dhcp-3.1-ESV-R3/common/parse.c.rej
--- dhcp-3.1-ESV-R3_orig/common/parse.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ dhcp-3.1-ESV-R3/common/parse.c.rej	2011-10-10 11:30:40.000000000 -0400
@@ -0,0 +1,31 @@
+***************
+*** 5342,5355 ****
+  #endif
+  
+  	if (log_perror) {
+- 		write (STDERR_FILENO, mbuf, strlen (mbuf));
+- 		write (STDERR_FILENO, "\n", 1);
+- 		write (STDERR_FILENO, cfile -> token_line,
+  		       strlen (cfile -> token_line));
+- 		write (STDERR_FILENO, "\n", 1);
+  		if (cfile -> lexchar < 81)
+- 			write (STDERR_FILENO, lexbuf, lix);
+- 		write (STDERR_FILENO, "^\n", 2);
+  	}
+  
+  	cfile -> warnings_occurred = 1;
+--- 5326,5339 ----
+  #endif
+  
+  	if (log_perror) {
++ 		l = write (STDERR_FILENO, mbuf, strlen (mbuf));
++ 		l = write (STDERR_FILENO, "\n", 1);
++ 		l = write (STDERR_FILENO, cfile -> token_line,
+  		       strlen (cfile -> token_line));
++ 		l = write (STDERR_FILENO, "\n", 1);
+  		if (cfile -> lexchar < 81)
++ 			l = write (STDERR_FILENO, lexbuf, lix);
++ 		l = write (STDERR_FILENO, "^\n", 2);
+  	}
+  
+  	cfile -> warnings_occurred = 1;
diff -rupN dhcp-3.1-ESV-R3_orig/common/print.c dhcp-3.1-ESV-R3/common/print.c
--- dhcp-3.1-ESV-R3_orig/common/print.c	2011-10-10 11:28:22.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/print.c	2011-10-10 14:15:37.000000000 -0400
@@ -48,7 +48,7 @@ char *quotify_string (const char *s, con
 	const unsigned char *sp;
 	char *buf, *nsp;
 
-	for (sp = s; sp && *sp; sp++) {
+	for (sp = (unsigned char *)s; sp && *sp; sp++) {
 		if (*sp == ' ')
 			len++;
 		else if (!isascii (*sp) || !isprint (*sp))
@@ -62,7 +62,7 @@ char *quotify_string (const char *s, con
 	buf = dmalloc (len + 1, file, line);
 	if (buf) {
 		nsp = buf;
-		for (sp = s; sp && *sp; sp++) {
+		for (sp = (unsigned char *)s; sp && *sp; sp++) {
 			if (*sp == ' ')
 				*nsp++ = ' ';
 			else if (!isascii (*sp) || !isprint (*sp)) {
@@ -462,7 +462,6 @@ static unsigned print_subexpression (exp
 {
 	unsigned rv, left;
 	const char *s;
-	struct expression *next_arg;
 
 	switch (expr -> op) {
 	      case expr_none:
@@ -1077,7 +1076,6 @@ int token_print_indent_concat (FILE *fil
 			       const char *suffix, ...)
 {
 	va_list list;
-	char *buf;
 	unsigned len;
 	char *s, *t, *u;
 
@@ -1116,7 +1114,6 @@ int token_indent_data_string (FILE *file
 			      struct data_string *data)
 {
 	int i;
-	char *buf;
 	char obuf [3];
 
 	/* See if this is just ASCII. */
diff -rupN dhcp-3.1-ESV-R3_orig/common/print.c.orig dhcp-3.1-ESV-R3/common/print.c.orig
--- dhcp-3.1-ESV-R3_orig/common/print.c.orig	2010-03-17 15:32:13.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/print.c.orig	2011-10-10 11:30:38.000000000 -0400
@@ -169,9 +169,9 @@ char *print_base64 (const unsigned char 
 }
 
 char *print_hw_addr (htype, hlen, data)
-	int htype;
-	int hlen;
-	unsigned char *data;
+	const int htype;
+	const int hlen;
+	const unsigned char *data;
 {
 	static char habuf [49];
 	char *s;
diff -rupN dhcp-3.1-ESV-R3_orig/common/resolv.c dhcp-3.1-ESV-R3/common/resolv.c
--- dhcp-3.1-ESV-R3_orig/common/resolv.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/resolv.c	2011-10-10 14:16:50.000000000 -0400
@@ -50,10 +50,8 @@ void read_resolv_conf (parse_time)
 	struct parse *cfile;
 	const char *val;
 	int token;
-	int declaration = 0;
 	struct name_server *sp, *sl, *ns;
 	struct domain_search_list *dp, *dl, *nd;
-	struct iaddr *iaddr;
 
 	if ((file = open (path_resolv_conf, O_RDONLY)) < 0) {
 		log_error ("Can't open %s: %m", path_resolv_conf);
@@ -179,7 +177,6 @@ void read_resolv_conf (parse_time)
 
 struct name_server *first_name_server ()
 {
-	FILE *rc;
 	static TIME rcdate;
 	struct stat st;
 
@@ -190,8 +187,6 @@ struct name_server *first_name_server ()
 			return (struct name_server *)0;
 		}
 		if (st.st_mtime > rcdate) {
-			char rcbuf [512];
-			char *s, *t, *u;
 			rcdate = cur_time + 1;
 			
 			read_resolv_conf (rcdate);
diff -rupN dhcp-3.1-ESV-R3_orig/common/socket.c dhcp-3.1-ESV-R3/common/socket.c
--- dhcp-3.1-ESV-R3_orig/common/socket.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/socket.c	2011-10-10 14:17:28.000000000 -0400
@@ -55,8 +55,6 @@ static char copyright[] =
 # endif
 #endif
 
-static int once = 0;
-
 /* Reinitializes the specified interface after an address change.   This
    is not required for packet-filter APIs. */
 
diff -rupN dhcp-3.1-ESV-R3_orig/common/tree.c dhcp-3.1-ESV-R3/common/tree.c
--- dhcp-3.1-ESV-R3_orig/common/tree.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/common/tree.c	2011-10-10 14:20:29.000000000 -0400
@@ -51,61 +51,6 @@ struct __res_state resolver_state;
 int resolver_inited = 0;
 #endif
 
-static void
-append_to_ary(char **ary_ptr, int *ary_size, int ary_capacity,
-	      char *new_element)
-{
-	/* INSIST(ary_ptr != NULL); */
-	/* INSIST(ary_size != NULL); */
-	/* INSIST(ary_capacity > 1); */
-
-	if (new_element == NULL)
-		return;
-
-	if (*ary_size >= ary_capacity) {
-		log_fatal("Improbable error at %s:%d.", MDL);
-		return;
-	}
-
-	ary_ptr[(*ary_size)++] = new_element;
-}
-
-static char *
-data_string_to_char_string(struct data_string *d)
-{
-	char *str, *start, *end;
-	const unsigned char *pos;
-	int len;
-
-	if (d == NULL);
-		return NULL;
-
-	pos = d->data;
-
-	if (pos == NULL)
-		return NULL;
-
-	/* Per byte could be "\777" at worst, plus null terminator. */
-	len = (d->len * 4) + 1;
-	str = dmalloc(len, MDL);
-	if (!str)
-		return NULL;
-
-	start = str;
-	end = start + len;
-
-	if (pretty_escape(&start, end, &pos, pos + d->len) < 0) {
-		dfree(str, MDL);
-		return NULL;
-	}
-
-	/* dmalloc() sets the buffer to zero - there is no need to null
-	 * terminate.
-	 */
-
-	return str;
-}
-
 pair cons (car, cdr)
 	caddr_t car;
 	pair cdr;
@@ -305,8 +250,6 @@ int make_limit (new, expr, limit)
 	struct expression *expr;
 	int limit;
 {
-	struct expression *rv;
-
 	/* Allocate a node to enforce a limit on evaluation. */
 	if (!expression_allocate (new, MDL))
 		log_error ("no memory for limit expression");
@@ -700,11 +643,10 @@ int evaluate_dns_expression (result, pac
 	struct binding_scope **scope;
 	struct expression *expr;
 {
-	ns_updrec *foo;
 	unsigned long ttl = 0;
 	char *tname;
 	struct data_string name, data;
-	int r0, r1, r2, r3;
+	int r0, r1, r2;
 
 	if (!result || *result) {
 		log_error ("evaluate_dns_expression called with non-null %s",
@@ -961,10 +903,7 @@ int evaluate_boolean_expression (result,
 	struct binding_scope **scope;
 	struct expression *expr;
 {
-	struct data_string left, right;
-	struct data_string rrtype, rrname, rrdata;
-	unsigned long ttl;
-	int srrtype, srrname, srrdata, sttl;
+	struct data_string left;
 	int bleft, bright;
 	int sleft, sright;
 	struct binding *binding;
@@ -1957,7 +1896,6 @@ int evaluate_data_expression (result, pa
 					       MDL);
 
 		if (s0 && s1) {
-			char *upper;
 			int i;
 
 			/* The buffer must be a multiple of the number's
@@ -3280,8 +3218,6 @@ static int op_val (op)
 int op_precedence (op1, op2)
 	enum expr_op op1, op2;
 {
-	int ov1, ov2;
-
 	return op_val (op1) - op_val (op2);
 }
 
@@ -3382,7 +3318,6 @@ int write_expression (file, expr, col, i
 	int firstp;
 {
 	struct expression *e;
-	struct expression *next_arg;
 	const char *s;
 	char obuf [65];
 	int scol;
@@ -3913,7 +3848,6 @@ int binding_scope_dereference (ptr, file
 	const char *file;
 	int line;
 {
-	int i;
 	struct binding_scope *binding_scope;
 
 	if (!ptr || !*ptr) {
diff -rupN dhcp-3.1-ESV-R3_orig/dhcpctl/callback.c dhcp-3.1-ESV-R3/dhcpctl/callback.c
--- dhcp-3.1-ESV-R3_orig/dhcpctl/callback.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/dhcpctl/callback.c	2011-10-10 11:30:40.000000000 -0400
@@ -59,7 +59,6 @@ dhcpctl_status dhcpctl_set_callback (dhc
 {
 	dhcpctl_callback_object_t *callback;
 	omapi_object_t *inner;
-	isc_result_t status;
 
 	callback = dmalloc (sizeof *callback, MDL);
 	if (!callback)
@@ -162,8 +161,6 @@ isc_result_t dhcpctl_callback_stuff_valu
 					    omapi_object_t *id,
 					    omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcpctl_callback_type)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/dhcpctl/cltest.c dhcp-3.1-ESV-R3/dhcpctl/cltest.c
--- dhcp-3.1-ESV-R3_orig/dhcpctl/cltest.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/dhcpctl/cltest.c	2011-10-10 14:23:38.000000000 -0400
@@ -60,9 +60,8 @@ int main (argc, argv)
 	isc_result_t status, waitstatus;
 	dhcpctl_handle authenticator;
 	dhcpctl_handle connection;
-	dhcpctl_handle host_handle, group_handle, interface_handle;
-	dhcpctl_data_string cid;
-	dhcpctl_data_string result, groupname, identifier;
+	dhcpctl_handle interface_handle;
+	dhcpctl_data_string result;
 	int i;
 	int mode = undefined;
 	const char *interface = 0;
diff -rupN dhcp-3.1-ESV-R3_orig/dhcpctl/dhcpctl.c dhcp-3.1-ESV-R3/dhcpctl/dhcpctl.c
--- dhcp-3.1-ESV-R3_orig/dhcpctl/dhcpctl.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/dhcpctl/dhcpctl.c	2011-10-10 11:30:40.000000000 -0400
@@ -101,7 +101,6 @@ dhcpctl_status dhcpctl_connect (dhcpctl_
 				dhcpctl_handle authinfo)
 {
 	isc_result_t status;
-	dhcpctl_status waitstatus;
 
 	status = omapi_generic_new (connection, MDL);
 	if (status != ISC_R_SUCCESS) {
@@ -171,7 +170,6 @@ dhcpctl_status dhcpctl_get_value (dhcpct
 {
 	isc_result_t status;
 	omapi_value_t *tv = (omapi_value_t *)0;
-	omapi_data_string_t *value = (omapi_data_string_t *)0;
 	unsigned len;
 	int ip;
 
@@ -263,7 +261,6 @@ dhcpctl_status dhcpctl_set_value (dhcpct
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -297,7 +294,6 @@ dhcpctl_status dhcpctl_set_string_value 
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -386,7 +382,6 @@ dhcpctl_status dhcpctl_set_boolean_value
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -416,7 +411,6 @@ dhcpctl_status dhcpctl_set_int_value (dh
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
diff -rupN dhcp-3.1-ESV-R3_orig/dhcpctl/omshell.c dhcp-3.1-ESV-R3/dhcpctl/omshell.c
--- dhcp-3.1-ESV-R3_orig/dhcpctl/omshell.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/dhcpctl/omshell.c	2011-10-10 11:30:40.000000000 -0400
@@ -82,11 +82,9 @@ int main (int argc, char **argv, char **
 	dhcpctl_handle connection;
 	dhcpctl_handle authenticator;
 	dhcpctl_handle oh;
-	dhcpctl_data_string cid, ip_addr;
-	dhcpctl_data_string result, groupname, identifier;
 	struct data_string secret;
 	const char *name = 0, *algorithm = "hmac-md5";
-	int i, j;
+	int i;
 	int port = 7911;
 	const char *server = "127.0.0.1";
 	struct parse *cfile;
@@ -481,7 +479,6 @@ int main (int argc, char **argv, char **
 				val = buf;
 				do {
 				    int intval = atoi (val);
-				dotiszero:
 				    if (intval > 255) {
 					parse_warn (cfile,
 						    "dotted octet > 255: %s",
diff -rupN dhcp-3.1-ESV-R3_orig/dhcpctl/remote.c dhcp-3.1-ESV-R3/dhcpctl/remote.c
--- dhcp-3.1-ESV-R3_orig/dhcpctl/remote.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/dhcpctl/remote.c	2011-10-10 11:30:40.000000000 -0400
@@ -354,8 +354,6 @@ isc_result_t dhcpctl_remote_stuff_values
 					  omapi_object_t *id,
 					  omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcpctl_remote_type)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/dst/dst_api.c dhcp-3.1-ESV-R3/dst/dst_api.c
--- dhcp-3.1-ESV-R3_orig/dst/dst_api.c	2011-10-10 11:28:23.000000000 -0400
+++ dhcp-3.1-ESV-R3/dst/dst_api.c	2011-10-10 14:27:35.000000000 -0400
@@ -476,7 +476,7 @@ dst_s_read_public_key(const char *in_nam
 	int proto, alg, dlen;
 	int c;
 	char name[PATH_MAX], enckey[RAW_KEY_SIZE];
-        unsigned char *notspace;
+	char *notspace;
 	u_char deckey[RAW_KEY_SIZE];
 	FILE *fp;
 
diff -rupN dhcp-3.1-ESV-R3_orig/dst/dst_api.c.orig dhcp-3.1-ESV-R3/dst/dst_api.c.orig
--- dhcp-3.1-ESV-R3_orig/dst/dst_api.c.orig	2010-03-17 15:32:13.000000000 -0400
+++ dhcp-3.1-ESV-R3/dst/dst_api.c.orig	2011-10-10 11:30:39.000000000 -0400
@@ -59,6 +59,10 @@ static const char rcsid[] = "$Header: /p
 
 #include "dst_internal.h"
 
+/* prototypes */
+extern int b64_pton(char const *src, u_char *target, size_t targsize);
+extern int b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize);
+
 /* static variables */
 static int done_init = 0;
 dst_func *dst_t_func[DST_MAX_ALGS];
diff -rupN dhcp-3.1-ESV-R3_orig/dst/dst_api.c.rej dhcp-3.1-ESV-R3/dst/dst_api.c.rej
--- dhcp-3.1-ESV-R3_orig/dst/dst_api.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ dhcp-3.1-ESV-R3/dst/dst_api.c.rej	2011-10-10 11:30:40.000000000 -0400
@@ -0,0 +1,18 @@
+***************
+*** 549,555 ****
+  		return (NULL);
+  	}
+  	/* read in the key string */
+- 	fgets(enckey, sizeof(enckey), fp);
+  
+  	/* If we aren't at end-of-file, something is wrong.  */
+  	while ((c = getc(fp)) != EOF)
+--- 549,556 ----
+  		return (NULL);
+  	}
+  	/* read in the key string */
++ 	char *r;
++ 	r = fgets(enckey, sizeof(enckey), fp);
+  
+  	/* If we aren't at end-of-file, something is wrong.  */
+  	while ((c = getc(fp)) != EOF)
diff -rupN dhcp-3.1-ESV-R3_orig/dst/prandom.c dhcp-3.1-ESV-R3/dst/prandom.c
--- dhcp-3.1-ESV-R3_orig/dst/prandom.c	2001-02-22 02:22:09.000000000 -0500
+++ dhcp-3.1-ESV-R3/dst/prandom.c	2011-10-10 11:30:40.000000000 -0400
@@ -335,7 +335,7 @@ unix_cmd(dst_work *work)
 		cnt += do_time(work);
 	}
 	while ((n = fread(buffer, sizeof(char), sizeof(buffer), pipe)) > 0)
-		NULL; /* drain the pipe */
+		continue; /* drain the pipe */
 	pclose(pipe);
 	return (cnt);		/* read how many bytes where read in */
 }
diff -rupN dhcp-3.1-ESV-R3_orig/minires/ns_date.c dhcp-3.1-ESV-R3/minires/ns_date.c
--- dhcp-3.1-ESV-R3_orig/minires/ns_date.c	2009-07-23 17:43:34.000000000 -0400
+++ dhcp-3.1-ESV-R3/minires/ns_date.c	2011-10-10 14:29:12.000000000 -0400
@@ -48,7 +48,7 @@ static const char rcsid[] = "$Id: ns_dat
 
 /* Forward. */
 
-static int	datepart(const unsigned char *, int, int, int, int *);
+static int	datepart(const char *, int, int, int, int *);
 
 /* Public. */
 
@@ -118,7 +118,7 @@ ns_datetosecs(const char *cp, int *errp)
  * Don't reset the flag if there is no error.
  */
 static int
-datepart(const unsigned char *buf, int size, int min, int max, int *errp) {
+datepart(const char *buf, int size, int min, int max, int *errp) {
 	int result = 0;
 	int i;
 
diff -rupN dhcp-3.1-ESV-R3_orig/minires/res_init.c dhcp-3.1-ESV-R3/minires/res_init.c
--- dhcp-3.1-ESV-R3_orig/minires/res_init.c	2011-10-10 11:28:23.000000000 -0400
+++ dhcp-3.1-ESV-R3/minires/res_init.c	2011-10-10 14:39:15.000000000 -0400
@@ -155,7 +155,7 @@ res_ninit(res_state statp) {
 int
 minires_vinit(res_state statp, int preinit) {
 	register FILE *fp;
-	register unsigned char *cp;
+	char *cp;
 	register char **pp;
 	register int n;
 	char buf[BUFSIZ];
diff -rupN dhcp-3.1-ESV-R3_orig/minires/res_mkupdate.c dhcp-3.1-ESV-R3/minires/res_mkupdate.c
--- dhcp-3.1-ESV-R3_orig/minires/res_mkupdate.c	2011-10-10 11:28:23.000000000 -0400
+++ dhcp-3.1-ESV-R3/minires/res_mkupdate.c	2011-10-10 14:39:35.000000000 -0400
@@ -112,7 +112,7 @@ res_nmkupdate(res_state statp,
 	u_int16_t rtype, rclass;
 	u_int32_t n1, rttl;
 	u_char *dnptrs[20], **dpp, **lastdnptr;
-	unsigned siglen, certlen;
+	unsigned certlen;
 	int keylen;
 	unsigned buflen = *blp;
 	u_char *buf = (unsigned char *)bp;
diff -rupN dhcp-3.1-ESV-R3_orig/minires/res_query.c dhcp-3.1-ESV-R3/minires/res_query.c
--- dhcp-3.1-ESV-R3_orig/minires/res_query.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/minires/res_query.c	2011-10-10 14:40:19.000000000 -0400
@@ -384,7 +384,7 @@ res_nquerydomain(res_state statp,
 const char *
 res_hostalias(const res_state statp, const char *name, char *dst, size_t siz) {
 	char *file;
-        unsigned char *cp1, *cp2;
+	char *cp1, *cp2;
 	char buf[BUFSIZ];
 	FILE *fp;
 
diff -rupN dhcp-3.1-ESV-R3_orig/minires/res_update.c dhcp-3.1-ESV-R3/minires/res_update.c
--- dhcp-3.1-ESV-R3_orig/minires/res_update.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/minires/res_update.c	2011-10-10 14:40:34.000000000 -0400
@@ -88,7 +88,7 @@ res_nupdate(res_state statp, ns_updrec *
 	double answer[PACKETSZ / sizeof (double)];
 	double packet[2*PACKETSZ / sizeof (double)];
 	struct zonegrp *zptr, tgrp;
-	int nzones = 0, nscount = 0;
+	int nscount = 0;
 	unsigned n;
 	unsigned rval;
 	struct sockaddr_in nsaddrs[MAXNS];
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/alloc.c dhcp-3.1-ESV-R3/omapip/alloc.c
--- dhcp-3.1-ESV-R3_orig/omapip/alloc.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/alloc.c	2011-10-10 14:41:14.000000000 -0400
@@ -93,7 +93,6 @@ VOIDPTR dmalloc (size, file, line)
 {
 	unsigned char *foo;
 	unsigned len;
-	int i;
 	VOIDPTR *bar;
 #if defined (DEBUG_MEMORY_LEAKAGE) || defined (DEBUG_MALLOC_POOL) || \
 		defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/array.c dhcp-3.1-ESV-R3/omapip/array.c
--- dhcp-3.1-ESV-R3_orig/omapip/array.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/array.c	2011-10-10 14:41:36.000000000 -0400
@@ -46,7 +46,6 @@ isc_result_t omapi_array_allocate (omapi
 				   omapi_array_deref_t deref,
 				   const char *file, int line)
 {
-	isc_result_t status;
 	omapi_array_t *aptr;
 
 	if (!array || *array)
@@ -63,7 +62,6 @@ isc_result_t omapi_array_allocate (omapi
 isc_result_t omapi_array_free (omapi_array_t **array,
 			       const char *file, int line)
 {
-	isc_result_t status;
 	omapi_array_t *aptr;
 	int i;
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/buffer.c dhcp-3.1-ESV-R3/omapip/buffer.c
--- dhcp-3.1-ESV-R3_orig/omapip/buffer.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/buffer.c	2011-10-10 14:42:18.000000000 -0400
@@ -438,7 +438,6 @@ isc_result_t omapi_connection_writer (om
 	int bytes_written;
 	unsigned first_byte;
 	omapi_buffer_t *buffer;
-	unsigned char *bufp;
 	omapi_connection_object_t *c;
 	isc_result_t status;
 
@@ -575,7 +574,6 @@ isc_result_t omapi_connection_put_uint32
 					  u_int32_t value)
 {
 	u_int32_t inbuf;
-	isc_result_t status;
 
 	inbuf = htonl (value);
 	
@@ -602,7 +600,6 @@ isc_result_t omapi_connection_put_uint16
 					  u_int32_t value)
 {
 	u_int16_t inbuf;
-	isc_result_t status;
 
 	inbuf = htons (value);
 	
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/connection.c dhcp-3.1-ESV-R3/omapip/connection.c
--- dhcp-3.1-ESV-R3_orig/omapip/connection.c	2010-03-17 19:20:59.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/connection.c	2011-10-10 14:43:00.000000000 -0400
@@ -111,10 +111,6 @@ isc_result_t omapi_connect_list (omapi_o
 	omapi_connection_object_t *obj;
 	int flag;
 	struct sockaddr_in local_sin;
-#if defined (TRACING)
-	trace_addr_t *addrs;
-	u_int16_t naddrs;
-#endif
 
 	obj = (omapi_connection_object_t *)0;
 	status = omapi_connection_allocate (&obj, MDL);
@@ -1027,8 +1023,6 @@ isc_result_t omapi_connection_stuff_valu
 					    omapi_object_t *id,
 					    omapi_object_t *m)
 {
-	int i;
-
 	if (m -> type != omapi_type_connection)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/convert.c dhcp-3.1-ESV-R3/omapip/convert.c
--- dhcp-3.1-ESV-R3_orig/omapip/convert.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/convert.c	2011-10-10 14:43:21.000000000 -0400
@@ -165,7 +165,7 @@ int binary_to_ascii (outbuf, inbuf, base
 	u_int32_t number;
 	static char h2a [] = "0123456789abcdef";
 	int power = converted_length (inbuf, base, width);
-	int i, j;
+	int i;
 
 	if (base > 16)
 		return 0;
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/errwarn.c dhcp-3.1-ESV-R3/omapip/errwarn.c
--- dhcp-3.1-ESV-R3_orig/omapip/errwarn.c	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/errwarn.c	2011-10-10 14:45:36.000000000 -0400
@@ -66,7 +66,7 @@ void log_fatal (const char * fmt, ... )
   va_list list;
 
   do_percentm (fbuf, fmt);
-  
+
 #ifdef LIBDHCP
   if (libdhcp_control && (libdhcp_control->eh)) {
       va_start (list, fmt);
@@ -76,6 +76,7 @@ void log_fatal (const char * fmt, ... )
       return;
   }
 #else
+  int r;
 
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
@@ -127,6 +128,8 @@ int log_error (const char * fmt, ...)
       va_end(list);
   }
 #else
+  int r;
+
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
@@ -161,6 +164,8 @@ int log_info (const char *fmt, ...)
       va_end(list);
   }
 #else
+  int r;
+
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
@@ -194,6 +199,8 @@ int log_debug (const char *fmt, ...)
       va_end(list);
   }
 #else
+  int r;
+
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/errwarn.c.orig dhcp-3.1-ESV-R3/omapip/errwarn.c.orig
--- dhcp-3.1-ESV-R3_orig/omapip/errwarn.c.orig	2011-10-10 11:28:24.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/errwarn.c.orig	2011-10-10 11:30:40.000000000 -0400
@@ -40,6 +40,11 @@ static char copyright[] =
 #include <omapip/omapip_p.h>
 #include <errno.h>
 
+#ifdef LIBDHCP
+#include <isc-dhcp/libdhcp_control.h>
+extern LIBDHCP_Control *libdhcp_control;
+#endif
+
 #ifdef DEBUG
 int log_perror = -1;
 #else
@@ -49,7 +54,9 @@ int log_priority;
 void (*log_cleanup) (void);
 
 #define CVT_BUF_MAX 1023
+#ifndef LIBDHCP
 static char mbuf [CVT_BUF_MAX + 1];
+#endif
 static char fbuf [CVT_BUF_MAX + 1];
 
 /* Log an error message, then exit... */
@@ -59,6 +66,16 @@ void log_fatal (const char * fmt, ... )
   va_list list;
 
   do_percentm (fbuf, fmt);
+  
+#ifdef LIBDHCP
+  if (libdhcp_control && (libdhcp_control->eh)) {
+      va_start (list, fmt);
+      libdhcp_control->eh(libdhcp_control, LOG_FATAL, fbuf, list);
+      va_end(list);
+      libdhcp_control->finished = 1;
+      return;
+  }
+#else
 
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
@@ -92,6 +109,7 @@ void log_fatal (const char * fmt, ... )
   if (log_cleanup)
 	  (*log_cleanup) ();
   exit (1);
+#endif
 }
 
 /* Log an error message... */
@@ -102,6 +120,13 @@ int log_error (const char * fmt, ...)
 
   do_percentm (fbuf, fmt);
 
+#ifdef LIBDHCP
+  if (libdhcp_control && libdhcp_control->eh) {
+      va_start (list, fmt);
+      libdhcp_control->eh(libdhcp_control, LOG_ERR, fbuf, list);
+      va_end(list);
+  }
+#else
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
@@ -117,7 +142,7 @@ int log_error (const char * fmt, ...)
 	  IGNORE_RET(write(STDERR_FILENO, mbuf, strlen (mbuf)));
 	  IGNORE_RET(write(STDERR_FILENO, "\n", 1));
   }
-
+#endif
   return 0;
 }
 
@@ -129,6 +154,13 @@ int log_info (const char *fmt, ...)
 
   do_percentm (fbuf, fmt);
 
+#ifdef LIBDHCP
+  if (libdhcp_control && libdhcp_control->eh) {
+      va_start (list, fmt);
+      libdhcp_control->eh(libdhcp_control, LOG_INFO, fbuf, list);
+      va_end(list);
+  }
+#else
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
@@ -144,7 +176,7 @@ int log_info (const char *fmt, ...)
 	  IGNORE_RET(write(STDERR_FILENO, mbuf, strlen (mbuf)));
 	  IGNORE_RET(write(STDERR_FILENO, "\n", 1));
   }
-
+#endif
   return 0;
 }
 
@@ -155,7 +187,13 @@ int log_debug (const char *fmt, ...)
   va_list list;
 
   do_percentm (fbuf, fmt);
-
+#ifdef LIBDHCP
+  if (libdhcp_control && libdhcp_control->eh) {
+      va_start (list, fmt);
+      libdhcp_control->eh(libdhcp_control, LOG_DEBUG, fbuf, list);
+      va_end(list);
+  }
+#else
   /* %Audit% This is log output. %2004.06.17,Safe%
    * If we truncate we hope the user can get a hint from the log.
    */
@@ -171,7 +209,7 @@ int log_debug (const char *fmt, ...)
 	  IGNORE_RET(write(STDERR_FILENO, mbuf, strlen (mbuf)));
 	  IGNORE_RET(write(STDERR_FILENO, "\n", 1));
   }
-
+#endif
   return 0;
 }
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/errwarn.c.rej dhcp-3.1-ESV-R3/omapip/errwarn.c.rej
--- dhcp-3.1-ESV-R3_orig/omapip/errwarn.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ dhcp-3.1-ESV-R3/omapip/errwarn.c.rej	2011-10-10 11:30:40.000000000 -0400
@@ -0,0 +1,76 @@
+***************
+*** 90,97 ****
+  
+    /* Also log it to stderr? */
+    if (log_perror) {
+- 	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+- 	  write (STDERR_FILENO, "\n", 1);
+    }
+  
+  #if !defined (NOMINUM)
+--- 91,98 ----
+  
+    /* Also log it to stderr? */
+    if (log_perror) {
++ 	  r = write (STDERR_FILENO, mbuf, strlen (mbuf));
++ 	  r = write (STDERR_FILENO, "\n", 1);
+    }
+  
+  #if !defined (NOMINUM)
+***************
+*** 139,146 ****
+  #endif
+  
+    if (log_perror) {
+- 	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+- 	  write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
+--- 142,149 ----
+  #endif
+  
+    if (log_perror) {
++ 	  r = write (STDERR_FILENO, mbuf, strlen (mbuf));
++ 	  r = write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
+***************
+*** 173,180 ****
+  #endif
+  
+    if (log_perror) {
+- 	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+- 	  write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
+--- 178,185 ----
+  #endif
+  
+    if (log_perror) {
++ 	  r = write (STDERR_FILENO, mbuf, strlen (mbuf));
++ 	  r = write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
+***************
+*** 206,213 ****
+  #endif
+  
+    if (log_perror) {
+- 	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+- 	  write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
+--- 213,220 ----
+  #endif
+  
+    if (log_perror) {
++ 	  r = write (STDERR_FILENO, mbuf, strlen (mbuf));
++ 	  r = write (STDERR_FILENO, "\n", 1);
+    }
+  #endif
+    return 0;
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/generic.c dhcp-3.1-ESV-R3/omapip/generic.c
--- dhcp-3.1-ESV-R3_orig/omapip/generic.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/generic.c	2011-10-10 14:45:55.000000000 -0400
@@ -292,7 +292,6 @@ isc_result_t omapi_generic_stuff_values 
 isc_result_t omapi_generic_clear_flags (omapi_object_t *o)
 {
 	int i;
-	isc_result_t status;
 	omapi_generic_object_t *g;
 
 	if (o -> type != omapi_type_generic)
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/handle.c dhcp-3.1-ESV-R3/omapip/handle.c
--- dhcp-3.1-ESV-R3_orig/omapip/handle.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/handle.c	2011-10-10 14:46:38.000000000 -0400
@@ -76,7 +76,6 @@ static isc_result_t omapi_handle_table_e
 
 isc_result_t omapi_object_handle (omapi_handle_t *h, omapi_object_t *o)
 {
-	int tabix;
 	isc_result_t status;
 
 	if (o -> handle) {
@@ -285,7 +284,6 @@ static isc_result_t omapi_handle_lookup_
 isc_result_t omapi_handle_td_lookup (omapi_object_t **obj,
 				     omapi_typed_data_t *handle)
 {
-	isc_result_t status;
 	omapi_handle_t h;
 
 	if (handle -> type == omapi_datatype_int)
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/hash.c dhcp-3.1-ESV-R3/omapip/hash.c
--- dhcp-3.1-ESV-R3_orig/omapip/hash.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/hash.c	2011-10-10 15:16:22.000000000 -0400
@@ -103,8 +103,6 @@ void free_hash_table (tp, file, line)
 	const char *file;
 	int line;
 {
-	int i;
-	struct hash_bucket *hbc, *hbn = (struct hash_bucket *)0;
 	struct hash_table *ptr = *tp;
 
 #if defined (DEBUG_MEMORY_LEAKAGE) || \
@@ -197,7 +195,6 @@ void free_hash_bucket (ptr, file, line)
 	const char *file;
 	int line;
 {
-	struct hash_bucket *hp;
 #if defined (DEBUG_MALLOC_POOL)
 	for (hp = free_hash_buckets; hp; hp = hp -> next) {
 		if (hp == ptr) {
@@ -352,7 +349,7 @@ hash_report(struct hash_table *table)
 		return (unsigned char *) "No table.";
 
 	if (table->hash_count == 0)
-		return (char *) "Invalid hash table.";
+		return (unsigned char *) "Invalid hash table.";
 
 	for (i = 0 ; i < table->hash_count ; i++) {
 		curlen = 0;
@@ -381,9 +378,9 @@ hash_report(struct hash_table *table)
 	    pct > 2147483647 ||
 	    minlen > 2147483647 ||
 	    maxlen > 2147483647)
-		return (char *) "Report out of range for display.";
+		return (unsigned char *) "Report out of range for display.";
 
-	sprintf(retbuf, "Contents/Size (%%): %u/%u (%u%%). Min/max: %u/%u",
+	sprintf((char *)retbuf, "Contents/Size (%%): %u/%u (%u%%). Min/max: %u/%u",
 		contents, table->hash_count, pct, minlen, maxlen);
 
 	return retbuf;
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/listener.c dhcp-3.1-ESV-R3/omapip/listener.c
--- dhcp-3.1-ESV-R3_orig/omapip/listener.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/listener.c	2011-10-10 15:17:37.000000000 -0400
@@ -68,12 +68,9 @@ isc_result_t omapi_listen_addr (omapi_ob
 				omapi_addr_t *addr,
 				int max)
 {
-	struct hostent *he;
-	int hix;
 	isc_result_t status;
 	omapi_listener_object_t *obj;
 	int i;
-	struct in_addr ia;
 
 	/* Currently only support IPv4 addresses. */
 	if (addr->addrtype != AF_INET)
@@ -215,8 +212,6 @@ isc_result_t omapi_accept (omapi_object_
 	SOCKLEN_T len;
 	omapi_connection_object_t *obj;
 	omapi_listener_object_t *listener;
-	omapi_addr_t remote_addr;
-	int i;
 	struct sockaddr_in addr;
 	int socket;
 
@@ -238,7 +233,6 @@ isc_result_t omapi_accept (omapi_object_
 	/* If we're recording a trace, remember the connection. */
 	if (trace_record ()) {
 		trace_iov_t iov [3];
-		u_int32_t lsock;
 		iov [0].buf = (char *)&addr.sin_port;
 		iov [0].len = sizeof addr.sin_port;
 		iov [1].buf = (char *)&addr.sin_addr;
@@ -470,8 +464,6 @@ isc_result_t omapi_listener_stuff_values
 					  omapi_object_t *id,
 					  omapi_object_t *l)
 {
-	int i;
-
 	if (l -> type != omapi_type_listener)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/message.c dhcp-3.1-ESV-R3/omapip/message.c
--- dhcp-3.1-ESV-R3_orig/omapip/message.c	2009-09-01 16:32:28.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/message.c	2011-10-10 15:18:16.000000000 -0400
@@ -209,8 +209,6 @@ isc_result_t omapi_message_get_value (om
 isc_result_t omapi_message_destroy (omapi_object_t *h,
 				    const char *file, int line)
 {
-	int i;
-
 	omapi_message_object_t *m;
 	if (h -> type != omapi_type_message)
 		return ISC_R_INVALIDARG;
@@ -261,8 +259,6 @@ isc_result_t omapi_message_stuff_values 
 					 omapi_object_t *id,
 					 omapi_object_t *m)
 {
-	int i;
-
 	if (m -> type != omapi_type_message)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/mrtrace.c dhcp-3.1-ESV-R3/omapip/mrtrace.c
--- dhcp-3.1-ESV-R3_orig/omapip/mrtrace.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/mrtrace.c	2011-10-10 15:19:21.000000000 -0400
@@ -85,7 +85,6 @@ void trace_mr_statp_setup (res_state sta
 	unsigned buflen = 0;
 	char *buf = (char *)0;
 	isc_result_t status;
-	u_int32_t id;
 	int i;
 
 	if (trace_playback ()) {
@@ -412,7 +411,6 @@ unsigned int trace_mr_res_randomid (unsi
 	isc_result_t status;
 
 	if (trace_playback ()) {
-		int nscount;
 		status = trace_get_packet (&trace_mr_randomid, &buflen, &buf);
 		if (status != ISC_R_SUCCESS) {
 			log_error ("trace_mr_statp: no statp packet found.");
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/protocol.c dhcp-3.1-ESV-R3/omapip/protocol.c
--- dhcp-3.1-ESV-R3_orig/omapip/protocol.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/protocol.c	2011-10-10 15:20:02.000000000 -0400
@@ -165,7 +165,6 @@ isc_result_t omapi_protocol_send_message
 	omapi_remote_auth_t *ra;
 	omapi_value_t *signature;
 	isc_result_t status;
-	u_int32_t foo;
 	unsigned auth_len;
 
 	if (po -> type != omapi_type_protocol ||
@@ -947,8 +946,6 @@ isc_result_t omapi_protocol_stuff_values
 					  omapi_object_t *id,
 					  omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != omapi_type_protocol)
 		return ISC_R_INVALIDARG;
 
@@ -1135,8 +1132,6 @@ isc_result_t omapi_protocol_listener_stu
 					    omapi_object_t *id,
 					    omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != omapi_type_protocol_listener)
 		return ISC_R_INVALIDARG;
 
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/support.c dhcp-3.1-ESV-R3/omapip/support.c
--- dhcp-3.1-ESV-R3_orig/omapip/support.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/support.c	2011-10-10 15:21:37.000000000 -0400
@@ -53,7 +53,6 @@ omapi_object_type_t *omapi_type_auth_key
 
 omapi_object_type_t *omapi_object_types;
 int omapi_object_type_count;
-static int ot_max;
 
 #if defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
 void omapi_type_relinquish ()
@@ -298,7 +297,6 @@ isc_result_t omapi_signal (omapi_object_
 isc_result_t omapi_signal_in (omapi_object_t *handle, const char *name, ...)
 {
 	va_list ap;
-	omapi_object_t *outer;
 	isc_result_t status;
 
 	if (!handle)
@@ -368,7 +366,6 @@ isc_result_t omapi_set_value_str (omapi_
 				  const char *name,
 				  omapi_typed_data_t *value)
 {
-	omapi_object_t *outer;
 	omapi_data_string_t *nds;
 	isc_result_t status;
 
@@ -389,8 +386,6 @@ isc_result_t omapi_set_boolean_value (om
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -415,8 +410,6 @@ isc_result_t omapi_set_int_value (omapi_
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -441,8 +434,6 @@ isc_result_t omapi_set_object_value (oma
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -467,8 +458,6 @@ isc_result_t omapi_set_string_value (oma
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
diff -rupN dhcp-3.1-ESV-R3_orig/omapip/trace.c dhcp-3.1-ESV-R3/omapip/trace.c
--- dhcp-3.1-ESV-R3_orig/omapip/trace.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/omapip/trace.c	2011-10-10 15:22:32.000000000 -0400
@@ -319,7 +319,7 @@ trace_type_t *trace_type_register (const
 				   void (*stop_tracing) (trace_type_t *),
 				   const char *file, int line)
 {
-	trace_type_t *ttmp, *tptr;
+	trace_type_t *ttmp;
 	unsigned slen = strlen (name);
 	isc_result_t status;
 
@@ -518,7 +518,6 @@ isc_result_t trace_get_next_packet (trac
 	trace_type_t *ttype;
 	unsigned paylen;
 	int status;
-	int len;
 	fpos_t curpos;
 
 	status = fgetpos (traceinfile, &curpos);
@@ -644,7 +643,6 @@ time_t trace_snoop_time (trace_type_t **
 	unsigned bufmax = 0;
 	unsigned buflen = 0;
 	char *buf = (char *)0;
-	isc_result_t status;
 	time_t result;
 	trace_type_t *ttp;
 	
diff -rupN dhcp-3.1-ESV-R3_orig/server/confpars.c dhcp-3.1-ESV-R3/server/confpars.c
--- dhcp-3.1-ESV-R3_orig/server/confpars.c	2011-10-10 11:28:23.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/confpars.c	2011-10-10 15:26:36.000000000 -0400
@@ -39,7 +39,6 @@ static char copyright[] =
 
 #include "dhcpd.h"
 
-static TIME parsed_time;
 static unsigned char global_host_once = 1;
 
 #if defined (TRACING)
@@ -344,15 +343,12 @@ int parse_statement (cfile, group, type,
 	enum dhcp_token token;
 	const char *val;
 	struct shared_network *share;
-	char *t, *n;
-	struct expression *expr;
-	struct data_string data;
+	char *n;
 	struct hardware hardware;
 	struct executable_statement *et, *ep;
 	struct option *option = NULL;
 	struct option_cache *cache;
 	int lose;
-	struct data_string key_id;
 	int known;
 	isc_result_t status;
 	unsigned code;
@@ -994,7 +990,6 @@ void parse_failover_peer (cfile, group, 
 					    "load balance settings.");
 			if (token != NUMBER) {
 				parse_warn (cfile, "expecting number");
-			      badsplit:
 				skip_to_rbrace (cfile, 1);
 				dhcp_failover_state_dereference (&peer, MDL);
 				return;
@@ -1577,8 +1572,6 @@ void parse_pool_statement (cfile, group,
 
 	/* See if there's already a pool into which we can merge this one. */
 	for (pp = pool -> shared_network -> pools; pp; pp = pp -> next) {
-		struct lease *l;
-
 		if (pp -> group -> statements != pool -> group -> statements)
 			continue;
 #if defined (FAILOVER_PROTOCOL)
@@ -1890,7 +1883,6 @@ int parse_class_declaration (cp, cfile, 
 	char *name;
 	const char *tname;
 	struct executable_statement *stmt = (struct executable_statement *)0;
-	struct expression *expr;
 	int new = 1;
 	isc_result_t status = ISC_R_FAILURE;
 	int matchedonce = 0;
@@ -2345,7 +2337,6 @@ void parse_subnet_declaration (cfile, sh
 	unsigned char addr [4];
 	unsigned len = sizeof addr;
 	int declaration = 0;
-	struct interface_info *ip;
 	isc_result_t status;
 
 	subnet = (struct subnet *)0;
@@ -2624,8 +2615,6 @@ int parse_lease_declaration (struct leas
 	char tbuf [32];
 	struct lease *lease;
 	struct executable_statement *on;
-	struct expression *exp;
-	struct data_string ds;
 	int lose;
 	TIME t;
 	char *s;
@@ -3058,7 +3047,6 @@ int parse_lease_declaration (struct leas
 
 			token = peek_token (&val, (unsigned *)0, cfile);
 			if (token == STRING) {
-			    unsigned char *tuid;
 			    token = next_token (&val, &buflen, cfile);
 			    binding -> value -> type = binding_data;
 			    binding -> value -> value.data.len = buflen;
@@ -3215,7 +3203,6 @@ void parse_address_range (cfile, group, 
 	int dynamic = 0;
 	struct subnet *subnet;
 	struct shared_network *share;
-	struct pool *p;
 	struct pool *pool;
 	isc_result_t status;
 
diff -rupN dhcp-3.1-ESV-R3_orig/server/db.c dhcp-3.1-ESV-R3/server/db.c
--- dhcp-3.1-ESV-R3_orig/server/db.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/db.c	2011-10-10 15:28:50.000000000 -0400
@@ -54,7 +54,6 @@ int write_lease (lease)
 	struct lease *lease;
 {
 	int errors = 0;
-	int i;
 	struct binding *b;
 	char *s;
 	const char *tval;
@@ -148,7 +147,6 @@ int write_lease (lease)
 			++errors;
 	}
 	if (lease -> uid_len) {
-		int i;
 		s = quotify_buf (lease -> uid, lease -> uid_len, MDL);
 		if (s) {
 			errno = 0;
@@ -222,7 +220,7 @@ int write_lease (lease)
 	    }
 	}
 	if (lease -> client_hostname &&
-	    db_printable (lease -> client_hostname)) {
+	    db_printable ((unsigned char *) lease -> client_hostname)) {
 		s = quotify_string (lease -> client_hostname, MDL);
 		if (s) {
 			errno = 0;
@@ -281,7 +279,7 @@ int write_host (host)
 		if (!new_lease_file ())
 			return 0;
 
-	if (!db_printable (host -> name))
+	if (!db_printable ((unsigned char *) host -> name))
 		return 0;
 
 	if (counting)
@@ -419,7 +417,6 @@ int write_group (group)
 	struct group_object *group;
 {
 	int errors = 0;
-	int i;
 
 	/* If the lease file is corrupt, don't try to write any more leases
 	   until we've written a good lease file. */
@@ -427,7 +424,7 @@ int write_group (group)
 		if (!new_lease_file ())
 			return 0;
 
-	if (!db_printable (group -> name))
+	if (!db_printable ((unsigned char *) group -> name))
 		return 0;
 
 	if (counting)
@@ -484,7 +481,6 @@ int write_group (group)
 #if defined (FAILOVER_PROTOCOL)
 int write_failover_state (dhcp_failover_state_t *state)
 {
-	struct tm *t;
 	int errors = 0;
 	const char *tval;
 
@@ -696,8 +692,6 @@ void write_billing_classes ()
 {
 	struct collection *lp;
 	struct class *cp;
-	struct hash_bucket *bp;
-	int i;
 
 	for (lp = collections; lp; lp = lp -> next) {
 	    for (cp = lp -> classes; cp; cp = cp -> nic) {
@@ -714,7 +708,6 @@ int write_billing_class (class)
 	struct class *class;
 {
 	int errors = 0;
-	int i;
 
 	if (lease_file_is_corrupt)
 		if (!new_lease_file ())
diff -rupN dhcp-3.1-ESV-R3_orig/server/ddns.c dhcp-3.1-ESV-R3/server/ddns.c
--- dhcp-3.1-ESV-R3_orig/server/ddns.c	2010-03-17 19:20:59.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/ddns.c	2011-10-10 15:29:34.000000000 -0400
@@ -224,7 +224,6 @@ int ddns_updates (struct packet *packet,
 	struct data_string ddns_fwd_name;
 	struct data_string ddns_rev_name;
 	struct data_string ddns_dhcid;
-	unsigned len;
 	struct data_string d1;
 	struct option_cache *oc;
 	int s1, s2;
@@ -772,7 +771,6 @@ int ddns_removals (struct lease *lease)
 	struct data_string ddns_rev_name;
 	struct data_string ddns_dhcid;
 	isc_result_t rcode;
-	struct binding *binding;
 	int result = 0;
 	int client_updated = 0;
 
diff -rupN dhcp-3.1-ESV-R3_orig/server/dhcp.c dhcp-3.1-ESV-R3/server/dhcp.c
--- dhcp-3.1-ESV-R3_orig/server/dhcp.c	2011-10-10 11:28:23.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/dhcp.c	2011-10-10 15:33:11.000000000 -0400
@@ -268,7 +268,7 @@ void dhcpdiscover (packet, ms_nulltp)
 
 	if (lease && lease -> client_hostname) {
 		if ((strlen (lease -> client_hostname) <= 64) &&
-		    db_printable (lease -> client_hostname))
+		    db_printable ((unsigned char *) lease -> client_hostname))
 			s = lease -> client_hostname;
 		else
 			s = "Hostname Unsuitable for Printing";
@@ -394,7 +394,6 @@ void dhcprequest (packet, ms_nulltp, ip_
 	int ours = 0;
 	struct option_cache *oc;
 	struct data_string data;
-	int status;
 	char msgbuf [1024]; /* XXX */
 	const char *s;
 	char smbuf [19];
@@ -433,7 +432,7 @@ void dhcprequest (packet, ms_nulltp, ip_
 
 	if (lease && lease -> client_hostname) {
 		if ((strlen (lease -> client_hostname) <= 64) &&
-		    db_printable (lease -> client_hostname))
+		    db_printable ((unsigned char *) lease -> client_hostname))
 			s = lease -> client_hostname;
 		else
 			s = "Hostname Unsuitable for Printing";
@@ -736,7 +735,7 @@ void dhcprelease (packet, ms_nulltp)
 
 	if (lease && lease -> client_hostname) {
 		if ((strlen (lease -> client_hostname) <= 64) &&
-		    db_printable (lease -> client_hostname))
+		    db_printable ((unsigned char *) lease -> client_hostname))
 			s = lease -> client_hostname;
 		else
 			s = "Hostname Unsuitable for Printing";
@@ -832,7 +831,7 @@ void dhcpdecline (packet, ms_nulltp)
 
 	if (lease && lease -> client_hostname) {
 		if ((strlen (lease -> client_hostname) <= 64) &&
-		    db_printable (lease -> client_hostname))
+		    db_printable ((unsigned char *) lease -> client_hostname))
 			s = lease -> client_hostname;
 		else
 			s = "Hostname Unsuitable for Printing";
@@ -931,14 +930,13 @@ void dhcpinform (packet, ms_nulltp)
 	char msgbuf [1024];
 	struct data_string d1, prl;
 	struct option_cache *oc;
-	struct expression *expr;
 	struct option_state *options = (struct option_state *)0;
 	struct dhcp_packet raw;
 	struct packet outgoing;
 	unsigned char dhcpack = DHCPACK;
 	struct subnet *subnet = NULL;
 	struct iaddr cip, gip;
-	unsigned i, j;
+	unsigned i;
 	int nulltp;
 	struct sockaddr_in to;
 	struct in_addr from;
@@ -1291,9 +1289,7 @@ void nak_lease (packet, cip)
 	struct packet outgoing;
 	struct hardware hto;
 	unsigned i;
-	struct data_string data;
 	struct option_state *options = (struct option_state *)0;
-	struct expression *expr;
 	struct option_cache *oc = (struct option_cache *)0;
 
 	option_state_allocate (&options, MDL);
@@ -1466,17 +1462,13 @@ void ack_lease (packet, lease, offer, wh
 	TIME max_lease_time;
 	TIME default_lease_time;
 	struct option_cache *oc;
-	struct expression *expr;
-	int status;
 	isc_result_t result;
-	int did_ping = 0;
 	TIME ping_timeout;
 	TIME lease_cltt;
 	struct in_addr from;
 
 	unsigned i, j;
-	int s1, s2;
-	int val;
+	int s1;
 	int ignorep;
 
 	/* If we're already acking this lease, don't do it again. */
@@ -2775,12 +2767,9 @@ void dhcp_reply (lease)
 	struct in_addr from;
 	struct hardware hto;
 	int result;
-	int i;
 	struct lease_state *state = lease -> state;
 	int nulltp, bootpp, unicastp = 1;
-	struct option_tag *ot, *not;
 	struct data_string d1;
-	struct option_cache *oc;
 	const char *s;
 
 	if (!state)
@@ -2857,7 +2846,7 @@ void dhcp_reply (lease)
 
 	if (lease -> client_hostname) {
 		if ((strlen (lease -> client_hostname) <= 64) &&
-		    db_printable (lease -> client_hostname))
+		    db_printable ((unsigned char *) lease -> client_hostname))
 			s = lease -> client_hostname;
 		else
 			s = "Hostname Unsuitable for Printing";
@@ -3000,7 +2989,6 @@ int find_lease (struct lease **lp,
 	struct data_string d1;
 	int have_client_identifier = 0;
 	struct data_string client_identifier;
-	int status;
 	struct hardware h;
 
 	/* Quick check to see if the peer has leases. */
@@ -4019,7 +4007,7 @@ get_server_source_address(struct in_addr
 	if (option_cache_allocate(&oc, MDL)) {
 		a = &packet->interface->primary_address;
 		if (make_const_data(&oc->expression,
-				    (char *)a, sizeof(*a),
+				    (unsigned char *)a, sizeof(*a),
 				    0, 0, MDL)) {
 			option_code_hash_lookup(&oc->option, 
 						dhcp_universe.code_hash,
diff -rupN dhcp-3.1-ESV-R3_orig/server/dhcp.c.orig dhcp-3.1-ESV-R3/server/dhcp.c.orig
--- dhcp-3.1-ESV-R3_orig/server/dhcp.c.orig	2011-07-07 15:18:47.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/dhcp.c.orig	2011-10-10 11:30:39.000000000 -0400
@@ -3905,6 +3905,7 @@ int locate_network (packet)
 	struct data_string data;
 	struct subnet *subnet = (struct subnet *)0;
 	struct option_cache *oc;
+	int norelay = 0;
 
 	/* See if there's a Relay Agent Link Selection Option, or a
 	 * Subnet Selection Option.  The Link-Select and Subnet-Select
@@ -3920,12 +3921,24 @@ int locate_network (packet)
 	   from the interface, if there is one.   If not, fail. */
 	if (!oc && !packet -> raw -> giaddr.s_addr) {
 		if (packet -> interface -> shared_network) {
-			shared_network_reference
-				(&packet -> shared_network,
-				 packet -> interface -> shared_network, MDL);
-			return 1;
+			struct in_addr any_addr;
+			any_addr.s_addr = INADDR_ANY;
+
+			if (!packet -> packet_type && memcmp(&packet -> raw -> ciaddr, &any_addr, 4)) {
+				struct iaddr cip;
+				memcpy(cip.iabuf, &packet -> raw -> ciaddr, 4);
+				cip.len = 4;
+				if (!find_grouped_subnet(&subnet, packet->interface->shared_network, cip, MDL))
+					norelay = 2;
+			}
+
+			if (!norelay) {
+				shared_network_reference(&packet -> shared_network, packet -> interface -> shared_network, MDL);
+				return 1;
+			}
+		} else {
+			return 0;
 		}
-		return 0;
 	}
 
 	/* If there's an option indicating link connection, and it's valid,
@@ -3948,7 +3961,10 @@ int locate_network (packet)
 		data_string_forget (&data, MDL);
 	} else {
 		ia.len = 4;
-		memcpy (ia.iabuf, &packet -> raw -> giaddr, 4);
+		if (norelay)
+			memcpy (ia.iabuf, &packet->raw->ciaddr, 4);
+		else
+			memcpy (ia.iabuf, &packet->raw->giaddr, 4);
 	}
 
 	/* If we know the subnet on which the IP address lives, use it. */
@@ -3956,7 +3972,10 @@ int locate_network (packet)
 		shared_network_reference (&packet -> shared_network,
 					  subnet -> shared_network, MDL);
 		subnet_dereference (&subnet, MDL);
-		return 1;
+		if (norelay)
+			return norelay;
+		else
+			return 1;
 	}
 
 	/* Otherwise, fail. */
diff -rupN dhcp-3.1-ESV-R3_orig/server/dhcpd.c dhcp-3.1-ESV-R3/server/dhcpd.c
--- dhcp-3.1-ESV-R3_orig/server/dhcpd.c	2011-10-10 11:28:22.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/dhcpd.c	2011-10-10 15:34:05.000000000 -0400
@@ -201,7 +201,7 @@ int main (argc, argv, envp)
 	int fd;
 	int i, status;
 	struct servent *ent;
-	unsigned char *s;
+	char *s;
 	int cftest = 0;
 	int lftest = 0;
 #ifndef DEBUG
@@ -216,9 +216,6 @@ int main (argc, argv, envp)
 	struct interface_info *ip;
 	struct parse *parse;
 	int lose;
-	omapi_object_t *auth;
-	struct tsig_key *key;
-	omapi_typed_data_t *td;
 	int no_dhcpd_conf = 0;
 	int no_dhcpd_db = 0;
 	int no_dhcpd_pid = 0;
@@ -971,7 +968,6 @@ int dhcpd_interface_setup_hook (struct i
 	   necessary. */
 	if (!ia) {
 		const char *fnn = "fallback-net";
-		char *s;
 		status = shared_network_allocate (&ip -> shared_network, MDL);
 		if (status != ISC_R_SUCCESS)
 			log_fatal ("No memory for shared subnet: %s",
diff -rupN dhcp-3.1-ESV-R3_orig/server/failover.c dhcp-3.1-ESV-R3/server/failover.c
--- dhcp-3.1-ESV-R3_orig/server/failover.c	2009-09-01 16:32:28.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/failover.c	2011-10-10 15:48:48.000000000 -0400
@@ -65,7 +65,6 @@ void dhcp_failover_startup ()
 {
 	dhcp_failover_state_t *state;
 	isc_result_t status;
-	dhcp_failover_listener_t *l;
 
 	for (state = failover_states; state; state = state -> next) {
 		dhcp_failover_state_transition (state, "startup");
@@ -182,7 +181,6 @@ isc_result_t dhcp_failover_link_initiate
 {
 	isc_result_t status;
 	dhcp_failover_link_t *obj;
-	omapi_value_t *value = (omapi_value_t *)0;
 	dhcp_failover_state_t *state;
 	omapi_object_t *o;
 	int i;
@@ -287,8 +285,6 @@ isc_result_t dhcp_failover_link_signal (
 	isc_result_t status;
 	dhcp_failover_link_t *link;
 	omapi_object_t *c;
-	u_int16_t nlen;
-	u_int32_t vlen;
 	dhcp_failover_state_t *s, *state = (dhcp_failover_state_t *)0;
 	char *sname;
 	int slen;
@@ -622,7 +618,6 @@ static isc_result_t do_a_failover_option
 	unsigned op_size;
 	unsigned op_count;
 	int i;
-	isc_result_t status;
 	
 	if (link -> imsg_count + 2 > link -> imsg_len) {
 		log_error ("FAILOVER: message overflow at option code.");
@@ -1182,8 +1177,6 @@ isc_result_t dhcp_failover_listener_stuf
 					   omapi_object_t *id,
 					   omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcp_type_failover_listener)
 		return ISC_R_INVALIDARG;
 
@@ -1243,11 +1236,8 @@ isc_result_t dhcp_failover_state_signal 
 					 const char *name, va_list ap)
 {
 	isc_result_t status;
-	omapi_connection_object_t *c;
-	omapi_protocol_object_t *obj;
 	dhcp_failover_state_t *state;
 	dhcp_failover_link_t *link;
-	char *peer_name;
 
 	if (!o || o -> type != dhcp_type_failover_state)
 		return ISC_R_INVALIDARG;
@@ -1904,7 +1894,6 @@ isc_result_t dhcp_failover_peer_state_ch
 	enum failover_state previous_state = state -> partner.state;
 	enum failover_state new_state;
 	int startupp;
-	isc_result_t status;
 
 	new_state = msg -> server_state;
 	startupp = (msg -> server_flags & FTF_SERVER_STARTUP) ? 1 : 0;
@@ -2369,7 +2358,6 @@ dhcp_failover_pool_dobalance(dhcp_failov
 	struct lease *next = (struct lease *)0;
 	struct shared_network *s;
 	struct pool *p;
-	int polarity;
 	binding_state_t peer_lease_state;
 	binding_state_t my_lease_state;
 	struct lease **lq;
@@ -2636,7 +2624,6 @@ dhcp_failover_pool_check(struct pool *po
 
 int dhcp_failover_state_pool_check (dhcp_failover_state_t *state)
 {
-	struct lease *lp;
 	struct shared_network *s;
 	struct pool *p;
 
@@ -2965,7 +2952,7 @@ isc_result_t dhcp_failover_state_set_val
 
 void dhcp_failover_keepalive (void *vs)
 {
-	dhcp_failover_state_t *state = vs;
+	return;
 }
 
 void dhcp_failover_reconnect (void *vs)
@@ -2997,7 +2984,6 @@ void dhcp_failover_reconnect (void *vs)
 void dhcp_failover_startup_timeout (void *vs)
 {
 	dhcp_failover_state_t *state = vs;
-	isc_result_t status;
 
 #if defined (DEBUG_FAILOVER_TIMING)
 	log_info ("dhcp_failover_startup_timeout");
@@ -3009,7 +2995,6 @@ void dhcp_failover_startup_timeout (void
 void dhcp_failover_link_startup_timeout (void *vl)
 {
 	dhcp_failover_link_t *link = vl;
-	isc_result_t status;
 	omapi_object_t *p;
 
 	for (p = (omapi_object_t *)link; p -> inner; p = p -> inner)
@@ -3488,7 +3473,6 @@ isc_result_t dhcp_failover_state_remove 
 int dhcp_failover_state_match (dhcp_failover_state_t *state,
 			       u_int8_t *addr, unsigned addrlen)
 {
-	struct option_cache *oc;
 	struct data_string ds;
 	int i;
 	
@@ -4071,7 +4055,6 @@ isc_result_t dhcp_failover_put_message (
 					omapi_object_t *connection,
 					int msg_type, u_int32_t xid, ...)
 {
-	unsigned count = 0;
 	unsigned size = 0;
 	int bad_option = 0;
 	int opix = 0;
@@ -4184,7 +4167,6 @@ void dhcp_failover_timeout (void *vstate
 {
 	dhcp_failover_state_t *state = vstate;
 	dhcp_failover_link_t *link;
-	isc_result_t status;
 
 #if defined (DEBUG_FAILOVER_TIMING)
 	log_info ("dhcp_failover_timeout");
@@ -4303,7 +4285,6 @@ isc_result_t dhcp_failover_send_connect 
 	dhcp_failover_link_t *link;
 	dhcp_failover_state_t *state;
 	isc_result_t status;
-	char hba [32];
 #if defined (DEBUG_FAILOVER_MESSAGES)	
 	char obuf [64];
 	unsigned obufix = 0;
@@ -5462,7 +5443,7 @@ isc_result_t dhcp_failover_generate_upda
 {
 	struct shared_network *s;
 	struct pool *p;
-	struct lease *l, *n;
+	struct lease *l;
 	int i;
 #define FREE_LEASES 0
 #define ACTIVE_LEASES 1
diff -rupN dhcp-3.1-ESV-R3_orig/server/mdb.c dhcp-3.1-ESV-R3/server/mdb.c
--- dhcp-3.1-ESV-R3_orig/server/mdb.c	2011-10-10 11:28:22.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/mdb.c	2011-10-10 15:51:47.000000000 -0400
@@ -317,7 +317,6 @@ isc_result_t delete_host (hd, commit)
 	struct host_decl *hp = (struct host_decl *)0;
 	struct host_decl *np = (struct host_decl *)0;
 	struct host_decl *foo;
-	struct executable_statement *esp;
 	int hw_head = 0, uid_head = 1;
 
 	/* Don't need to do it twice. */
@@ -452,7 +451,6 @@ int find_hosts_by_haddr (struct host_dec
 			 const unsigned char *haddr, unsigned hlen,
 			 const char *file, int line)
 {
-	struct host_decl *foo;
 	struct hardware h;
 	int ret;
 
@@ -488,7 +486,6 @@ int find_host_for_network (struct subnet
 			   struct iaddr *addr, struct shared_network *share)
 {
 	int i;
-	struct subnet *subnet;
 	struct iaddr ip_address;
 	struct host_decl *hp;
 	struct data_string fixed_addr;
@@ -545,7 +542,6 @@ void new_address_range (cfile, low, high
 	unsigned min, max, i;
 	char lowbuf [16], highbuf [16], netbuf [16];
 	struct shared_network *share = subnet -> shared_network;
-	isc_result_t status;
 	struct lease *lt = (struct lease *)0;
 
 	/* All subnets should have attached shared network structures. */
@@ -830,7 +826,6 @@ void enter_lease (lease)
 	struct lease *lease;
 {
 	struct lease *comp = (struct lease *)0;
-	isc_result_t status;
 
 	if (find_lease_by_ip_addr (&comp, lease -> ip_addr, MDL)) {
 		if (!comp -> pool) {
@@ -877,7 +872,6 @@ int supersede_lease (comp, lease, commit
 	int pimmediate;
 {
 	struct lease *lp, **lq, *prev;
-	TIME lp_next_state;
 #if defined (FAILOVER_PROTOCOL)
 	int do_pool_check = 0;
 
@@ -1590,7 +1584,6 @@ void pool_timer (vpool)
 	void *vpool;
 {
 	struct pool *pool;
-	struct lease *lt = (struct lease *)0;
 	struct lease *next = (struct lease *)0;
 	struct lease *lease = (struct lease *)0;
 #define FREE_LEASES 0
@@ -2314,7 +2307,6 @@ void expire_all_pools ()
 {
 	struct shared_network *s;
 	struct pool *p;
-	struct hash_bucket *hb;
 	int i;
 	struct lease *l;
 	struct lease **lptr[RESERVED_LEASES+1];
diff -rupN dhcp-3.1-ESV-R3_orig/server/omapi.c dhcp-3.1-ESV-R3/server/omapi.c
--- dhcp-3.1-ESV-R3_orig/server/omapi.c	2009-07-23 17:43:35.000000000 -0400
+++ dhcp-3.1-ESV-R3/server/omapi.c	2011-10-10 15:55:45.000000000 -0400
@@ -212,7 +212,6 @@ isc_result_t dhcp_lease_set_value  (omap
 {
 	struct lease *lease;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -399,8 +398,6 @@ isc_result_t dhcp_lease_get_value (omapi
 isc_result_t dhcp_lease_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct lease *lease;
-	isc_result_t status;
-	u_int8_t flagbuf;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -477,7 +474,6 @@ isc_result_t dhcp_lease_signal_handler (
 {
 	struct lease *lease;
 	isc_result_t status;
-	int updatep = 0;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -911,9 +907,8 @@ isc_result_t dhcp_host_set_value  (omapi
 				   omapi_data_string_t *name,
 				   omapi_typed_data_t *value)
 {
-	struct host_decl *host, *hp;
+	struct host_decl *host;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_host)
 		return ISC_R_INVALIDARG;
@@ -1172,7 +1167,6 @@ isc_result_t dhcp_host_get_value (omapi_
 isc_result_t dhcp_host_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct host_decl *host;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_host)
 		return ISC_R_INVALIDARG;
@@ -1593,7 +1587,6 @@ isc_result_t dhcp_pool_set_value  (omapi
 {
 	struct pool *pool;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_pool)
 		return ISC_R_INVALIDARG;
@@ -1639,8 +1632,6 @@ isc_result_t dhcp_pool_get_value (omapi_
 isc_result_t dhcp_pool_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct pool *pool;
-	isc_result_t status;
-	struct permit *pc, *pn;
 
 	if (h -> type != dhcp_type_pool)
 		return ISC_R_INVALIDARG;
@@ -1737,10 +1728,6 @@ isc_result_t dhcp_pool_stuff_values (oma
 isc_result_t dhcp_pool_lookup (omapi_object_t **lp,
 			       omapi_object_t *id, omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct pool *pool;
-
 	/* Can't look up pools yet. */
 
 	/* If we get to here without finding a pool, no valid key was
@@ -1913,11 +1900,6 @@ isc_result_t dhcp_class_set_value  (omap
 				    omapi_data_string_t *name,
 				    omapi_typed_data_t *value)
 {
-	struct class *class;
-	struct class *superclass = 0;
-	isc_result_t status;
-	int foo;
-
 	if (h -> type != dhcp_type_class)
 		return ISC_R_INVALIDARG;
 
@@ -1952,8 +1934,6 @@ isc_result_t dhcp_class_get_value (omapi
 isc_result_t dhcp_class_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct class *class;
-	isc_result_t status;
-	int i;
 
 	if (h -> type != dhcp_type_class && h -> type != dhcp_type_subclass)
 		return ISC_R_INVALIDARG;
@@ -2230,11 +2210,6 @@ isc_result_t dhcp_subclass_set_value  (o
 				       omapi_data_string_t *name,
 				       omapi_typed_data_t *value)
 {
-	struct class *subclass = 0;
-	struct class *superclass = 0;
-	isc_result_t status;
-	int foo;
-
 	if (h -> type != dhcp_type_subclass)
 		return ISC_R_INVALIDARG;
 
